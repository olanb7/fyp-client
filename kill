conf/click-mkclgw.pl:73:	unless ($ret_map->{$i}) {
conf/click-mkclgw.pl:75:	    $ret_map->{$i} = 1;
conf/click-mkclgw.pl:281:	#  <label> <ip-addr> <ip-addr> <net-addr>
conf/click-mkclgw.pl:296:	#  <label> <ip-addr>
conf/click-mkclgw.pl:322:	#   <label> <ip-addr> <net-addr> <eth>
conf/click-mkclgw.pl:337:	#  <label> <ip-addr> <eth-addr>
conf/click-mkclgw.pl:366:	#   <clust-label> <ip-addr> <ip-addrs> [ <ip-addr> <ip-net> ]
conf/click-mkclgw.pl:918:		    "rw", $port_map->{_ext_to_gw}, 
conf/click-mkclgw.pl:983:	$self->connect ($cl, $p1, "rw", $port_map->{_drop},
conf/click-mkclgw.pl:1152:    my $c = $map->{LBSEED};
conf/click-mkclgw.pl:1155:    $c = $map->{LBNODES};
conf/click-mkclgw.pl:1206:		$map->{INTERNAL}->mapped_label (),
conf/make-ip-conf.pl:3:# make-ip-conf.pl -- make a Click IP router configuration
conf/make-ip-conf.pl:70:print "// Generated by make-ip-conf.pl\n";
conf/ron/stop-all.pl:4:    print "stop-all.pl [nodelist]\n";
conf/ron/stop-all.pl:56:	$command = "ssh $name[$i] -l ron yipal/click-export/conf/stop-traceroute.sh $n";
conf/ron/stop-all.pl:61:	$command = "ssh $name[$i] -l ron yipal/click-export/conf/stop-server.sh $n";
conf/ron/stop-all.pl:66:	$command = "ssh $name[$i] -l ron yipal/click-export/conf/stop-client.sh $n";
conf/ron/stop-all.pl:71:	$command = "ssh $name[$i] -l ron yipal/click-export/conf/stop-datacollect.sh $n";
userlevel/click.cc:388:      router_file = clp->vstr;
userlevel/click.cc:393:      for (const char *s = clp->vstr; *s; s++)
userlevel/click.cc:394:	  if (*s == '=' && s > clp->vstr) {
userlevel/click.cc:395:	      if (!click_lexer()->global_scope().define(String(clp->vstr, s), s + 1, false))
userlevel/click.cc:396:		  errh->error("parameter '%.*s' multiply defined", s - clp->vstr, clp->vstr);
userlevel/click.cc:407:      output_file = clp->vstr;
userlevel/click.cc:411:      handlers.push_back(clp->vstr);
userlevel/click.cc:419:      exit_handler = clp->vstr;
userlevel/click.cc:423:      cs_ports.push_back(clp->val.i);
userlevel/click.cc:427:      cs_unix_sockets.push_back(clp->vstr);
userlevel/click.cc:431:      allow_reconfigure = !clp->negated;
userlevel/click.cc:443:      warnings = !clp->negated;
userlevel/click.cc:447:      warnings = clp->negated;
userlevel/click.cc:452:      nthreads = clp->val.i;
userlevel/click.cc:459:      set_clickpath(clp->vstr);
bsdmodule/clickfs.cc:46:    if (mp->mnt_flag & MNT_UPDATE)
bsdmodule/clickfs.cc:57:    mp->mnt_data = (qaddr_t) cmp;
bsdmodule/clickfs.cc:59:    mp->mnt_stat.f_bsize  = DEV_BSIZE;
bsdmodule/clickfs.cc:60:    mp->mnt_stat.f_iosize = DEV_BSIZE;
bsdmodule/clickfs.cc:61:    mp->mnt_stat.f_owner  = 0;
bsdmodule/clickfs.cc:62:    mp->mnt_stat.f_blocks = 1;
bsdmodule/clickfs.cc:63:    mp->mnt_stat.f_bfree  = 1;
bsdmodule/clickfs.cc:64:    mp->mnt_stat.f_bavail = 1;
bsdmodule/clickfs.cc:65:    mp->mnt_stat.f_files  = 1;
bsdmodule/clickfs.cc:66:    mp->mnt_stat.f_ffree  = 1;
bsdmodule/clickfs.cc:67:    mp->mnt_stat.f_flags  = mp->mnt_flag;
bsdmodule/clickfs.cc:69:    strcpy(mp->mnt_stat.f_mntonname, path);
bsdmodule/clickfs.cc:70:    strcpy(mp->mnt_stat.f_mntfromname, "clickfs");
bsdmodule/clickfs.cc:71:    strcpy(mp->mnt_stat.f_fstypename, "clickfs");
bsdmodule/clickfs.cc:73:    error = clickfs_rootvnode(mp, &cmp->click_root);
bsdmodule/clickfs.cc:85:    struct clickfs_mount *cmp = (struct clickfs_mount *)mp->mnt_data;
bsdmodule/clickfs.cc:96:    free(mp->mnt_data, M_CLICKFS);
bsdmodule/clickfs.cc:97:    mp->mnt_data = 0;
bsdmodule/clickfs.cc:105:    struct clickfs_mount *cmp = (struct clickfs_mount *)mp->mnt_data;
bsdmodule/clickfs.cc:107:    *vpp = cmp->click_root;
bsdmodule/clickfs.cc:117:    memcpy(sbp, &mp->mnt_stat, sizeof(*sbp));
bsdmodule/clickfs_vnops.cc:65:    vp->v_data = de;
bsdmodule/clickfs_vnops.cc:66:    vp->v_type = clickfs_vtype[de->type];
bsdmodule/clickfs_vnops.cc:67:    vp->v_vflag = VV_ROOT;
bsdmodule/clickfs_vnops.cc:74:    struct componentname *cnp = ap->a_cnp;
bsdmodule/clickfs_vnops.cc:75:    struct vnode **vpp = ap->a_vpp;
bsdmodule/clickfs_vnops.cc:76:    struct vnode *dvp = ap->a_dvp;
bsdmodule/clickfs_vnops.cc:77:    char *pname = cnp->cn_nameptr;
bsdmodule/clickfs_vnops.cc:78:    int plen = cnp->cn_namelen;
bsdmodule/clickfs_vnops.cc:79:    struct thread *td = cnp->cn_thread;
bsdmodule/clickfs_vnops.cc:85:    if (dvp->v_type != VDIR)
bsdmodule/clickfs_vnops.cc:87:    if (cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME)
bsdmodule/clickfs_vnops.cc:97:    if (cnp->cn_flags & ISDOTDOT)
bsdmodule/clickfs_vnops.cc:106:	error = (cnp->cn_nameiop == LOOKUP) ? ENOENT : EROFS;
bsdmodule/clickfs_vnops.cc:110:    error = getnewvnode("click", dvp->v_mount, &clickfs_vnodeops, vpp);
bsdmodule/clickfs_vnops.cc:129:    struct vnode *vp = ap->a_vp;
bsdmodule/clickfs_vnops.cc:130:    struct vattr *vap = ap->a_vap;
bsdmodule/clickfs_vnops.cc:134:    vap->va_type = vp->v_type;
bsdmodule/clickfs_vnops.cc:135:    vap->va_mode = cde->perm;
bsdmodule/clickfs_vnops.cc:136:    vap->va_fileid = cde->fileno;
bsdmodule/clickfs_vnops.cc:137:    vap->va_nlink = cde->file_refcnt;
bsdmodule/clickfs_vnops.cc:138:    vap->va_flags = 0;
bsdmodule/clickfs_vnops.cc:139:    vap->va_blocksize = PAGE_SIZE;
bsdmodule/clickfs_vnops.cc:140:    vap->va_fsid = vp->v_mount->mnt_stat.f_fsid.val[0];
bsdmodule/clickfs_vnops.cc:141:    nanotime(&vap->va_ctime);
bsdmodule/clickfs_vnops.cc:142:    vap->va_atime = vap->va_mtime = vap->va_ctime;
bsdmodule/clickfs_vnops.cc:143:    vap->va_uid = vap->va_gid = 0;
bsdmodule/clickfs_vnops.cc:146:	    vap->va_bytes = vap->va_size = (cde->file_refcnt-2)*sizeof(*cde);
bsdmodule/clickfs_vnops.cc:149:	    vap->va_bytes = vap->va_size = 0;
bsdmodule/clickfs_vnops.cc:152:	    vap->va_bytes = vap->va_size = strlen(cde->data.slink.name);
bsdmodule/clickfs_vnops.cc:177:    struct vnode *vp = ap->a_vp;
bsdmodule/clickfs_vnops.cc:182:    vp->v_data = NULL;
bsdmodule/clickfs_vnops.cc:183:    vp->v_type = VNON;
bsdmodule/clickfs_vnops.cc:184:    VOP_UNLOCK(vp, 0, ap->a_td);
bsdmodule/clickfs_vnops.cc:192:    struct vnode *vp = ap->a_vp;
bsdmodule/clickfs_vnops.cc:193:    struct ucred *cred = ap->a_cred;
bsdmodule/clickfs_vnops.cc:194:    mode_t mode = ap->a_mode;
bsdmodule/clickfs_vnops.cc:233:    struct uio *uio = ap->a_uio;
bsdmodule/clickfs_vnops.cc:234:    struct vnode *vp = ap->a_vp;
bsdmodule/clickfs_vnops.cc:238:    if (vp->v_type != VDIR)
bsdmodule/clickfs_vnops.cc:279:    struct vnode *vp = ap->a_vp;
bsdmodule/clickfs_vnops.cc:295:    struct vnode *vp = ap->a_vp;
bsdmodule/clickfs_vnops.cc:297:    struct uio *uio = ap->a_uio;
bsdmodule/clickfs_vnops.cc:303:    if (ap->a_vp->v_type != VREG)
bsdmodule/clickfs_vnops.cc:350:    struct vnode *vp = ap->a_vp;
bsdmodule/clickfs_vnops.cc:352:    struct uio *uio = ap->a_uio;
bsdmodule/clickfs_vnops.cc:359:    if (ap->a_vp->v_type != VREG)
bsdmodule/clickfs_vnops.cc:435:    struct vnode *vp = ap->a_vp;
bsdmodule/clickfs_vnops.cc:437:    int flags = ap->a_fflag;
bsdmodule/clickfs_vnops.cc:449:    struct vnode *vp = ap->a_vp;
bsdmodule/clickfs_vnops.cc:456:		   strlen(cde->data.slink.name), ap->a_uio);
bsdmodule/clickfs_vnops.cc:462:    struct vnode *vp = ap->a_vp;
apps/csclient/csclient.cc:452:      return handle_err_code(code); /* no workaround for top-level router handlers */
apps/clicky/src/crouter.cc:206:	emap->parse_all_files(r, CLICK_DATADIR, &_gerrh);
apps/clicky/src/crouter.cc:208:	    emap->set_driver_mask(_driver->driver_mask());
apps/clicky/src/crouter.cc:210:	    int driver = emap->pick_driver(_selected_driver, r, 0);
apps/clicky/src/crouter.cc:211:	    emap->set_driver_mask(1 << driver);
apps/clicky/src/dialogs.cc:477:    int driver_mask = (cd ? cd->driver_mask() : emap->provided_driver_mask());
apps/clicky/src/clicky.cc:151:	    set_clickpath(clp->vstr);
apps/clicky/src/clicky.cc:155:	    if (clp->negated)
apps/clicky/src/clicky.cc:158:		css_text += clicky::dcss_set::expand_imports(file_string(clp->vstr, ErrorHandler::default_handler()), clp->vstr, ErrorHandler::default_handler());
apps/clicky/src/clicky.cc:162:	    css_text += clicky::dcss_set::expand_imports(clp->vstr, "<style>", ErrorHandler::default_handler());
apps/clicky/src/clicky.cc:166:	    wfiles.push_back(clp->vstr);
apps/clicky/src/clicky.cc:171:	    if (strchr(clp->vstr, ':'))
apps/clicky/src/clicky.cc:172:		wfiles.push_back(clp->vstr);
apps/clicky/src/clicky.cc:174:		wfiles.push_back("localhost:" + String(clp->vstr));
apps/clicky/src/clicky.cc:179:	    wfiles.push_back(clp->vstr);
apps/clicky/src/clicky.cc:190:	    pdf_file = clp->vstr;
apps/clicky/src/clicky.cc:194:	    pdf_scale = 2.5 / clp->val.d;
apps/clicky/src/clicky.cc:198:	    pdf_multipage = !clp->negated;
apps/clicky/src/clicky.cc:202:	    show_list = !clp->negated;
apps/clicky/src/clicky.cc:206:	    show_list = clp->negated;
apps/clicky/src/clicky.cc:210:	    show_toolbar = !clp->negated;
apps/clicky/src/clicky.cc:214:	    show_toolbar = clp->negated;
apps/clicky/src/clicky.cc:218:	    const char *s = clp->vstr, *end = s + strlen(s);
apps/clicky/src/clicky.cc:219:	    if ((s = cp_integer(s, end, 10, &width)) != clp->vstr
apps/clicky/src/clicky.cc:235:	    wfiles.push_back(clp->vstr);
apps/clicky/src/dwidget.cc:263:	    RouterT *subr = pp->_resolved_router;
apps/clicky/src/dwidget.cc:266:		cc.push_back(delt_conn(pp->_elt[it->from_eindex()], it->from_port(), c.to, c.to_port));
apps/clicky/src/dwidget.cc:273:	    RouterT *subr = pp->_resolved_router;
apps/clicky/src/dwidget.cc:276:		cc.push_back(delt_conn(c.from, c.from_port, pp->_elt[it->to_eindex()], it->to_port()));
apps/clicky/src/dwidget.cc:308:    // can't depend on p->_display being set yet
apps/clicky/src/dwidget.cc:309:    if (!p->root() && p->_des->display == dedisp_expanded)
apps/clicky/src/dwidget.cc:310:	return p->display_name() + "/" + name();
apps/clicky/src/dwidget.cc:1365:    while (!p->root() && p->display() == dedisp_expanded)
apps/clicky/src/dwidget.cc:1366:	p = p->parent();
apps/clicky/src/dwidget.cc:1367:    for (std::vector<dconn *>::iterator it = p->_conn.begin();
apps/clicky/src/dwidget.cc:1368:	 it != p->_conn.end(); ++it)
apps/clicky/src/dwidget.cc:1391:    while (!p->root() && p->display() == dedisp_expanded)
apps/clicky/src/dwidget.cc:1392:	p = p->parent();
apps/clicky/src/dwidget.cc:1393:    for (std::vector<dconn *>::iterator it = p->_conn.begin();
apps/clicky/src/dwidget.cc:1394:	 it != p->_conn.end(); ++it)
apps/clicky/src/dwidget.cc:1413:    while (!p->root() && p->display() == dedisp_expanded)
apps/clicky/src/dwidget.cc:1414:	p = p->_parent;
apps/clicky/src/dwidget.cc:1415:    for (std::vector<dconn *>::iterator it = p->_conn.begin();
apps/clicky/src/dwidget.cc:1416:	 it != p->_conn.end(); ++it)
apps/clicky/src/dstyle.cc:1018:	    if (p->name() == name)
apps/clicky/src/dstyle.cc:1351:	if (p->name() == (*begin)->name) {
apps/clicky/src/dstyle.cc:1357:	} else if (p->name() < (*begin)->name)
apps/clicky/src/dstyle.cc:1363:		if (p->name() == (*m)->name)
apps/clicky/src/dstyle.cc:1365:		else if (p->name() < (*m)->name)
config.status.lineno:1020:    test $ac_file = include/click/config.h:config.h.in && echo > stamp-h
install-sh:320:# time-stamp-start: "scriptversion="
install-sh:321:# time-stamp-format: "%:y-%02m-%02d.%02H"
install-sh:322:# time-stamp-end: "$"
Makefile:46:bsdmodule: Makefile click-buildtool stamp-h
Makefile:48:linuxmodule: Makefile click-buildtool stamp-h
Makefile:50:ns: Makefile click-buildtool stamp-h
Makefile:52:userlevel: Makefile click-buildtool click-compile stamp-h
Makefile:54:exopc: Makefile click-buildtool stamp-h
Makefile:59:install: Makefile click-buildtool click-compile stamp-h installch
Makefile:87:install-local-include: stamp-h installch
Makefile:153:config.h: stamp-h
Makefile:154:stamp-h: $(srcdir)/config.h.in $(srcdir)/config-bsdmodule.h.in $(srcdir)/config-linuxmodule.h.in $(srcdir)/config-ns.h.in $(srcdir)/config-userlevel.h.in config.status
Makefile:157:	echo > stamp-h
Makefile:170:	-rm -f config.cache config.log click-buildtool click-compile config.mk stamp-h
etc/pkg-Makefile:79:elementmap-$(package).xml: $(clickbindir)/click-mkelemmap always
etc/pkg-Makefile:80:	r="$(DRIVERS) $(package)"; echo $(srcdir) | $(CLICK_BUILDTOOL) findelem -r "$$r" -P | $(clickbindir)/click-mkelemmap -r "$(package)" -t "$(DRIVERS)" -s `cd $(srcdir) && pwd` > elementmap-$(package).xml
etc/pkg-Makefile:82:install: install-obj install-man elementmap-$(package).xml always
etc/pkg-Makefile:84:	$(INSTALL_DATA) elementmap-$(package).xml $(DESTDIR)$(clickdatadir)/elementmap-$(package).xml
etc/pkg-Makefile:88:install-man: always elementmap-$(package).xml
etc/pkg-Makefile:91:	$(clickbindir)/click-elem2man -L -d $(DESTDIR)$(mandir)/mann -P $(package) -e $(clickdatadir)/elementmap.xml elementmap-$(package).xml
etc/pkg-Makefile:94:	/bin/rm -f $(DESTDIR)$(clickdatadir)/elementmap-$(package).xml
etc/pkg-Makefile:97:uninstall-man: always elementmap-$(package).xml
etc/pkg-Makefile:98:	$(clickbindir)/click-elem2man -L -d $(DESTDIR)$(mandir)/mann -P $(package) -e $(clickdatadir)/elementmap.xml -u elementmap-$(package).xml
etc/pkg-Makefile:102:	-rm -f elementmap-$(package).xml conftest.*
etc/ron/lookupiprouteron.cc:124:      if (Packet *q = p->clone())
etc/ron/lookupiprouteron.cc:154:      if (Packet *q = p->clone())
etc/ron/lookupiprouteron.cc:166:    dst_entry = _dst_table->insert(p->dst_ip_anno(), 0);
etc/ron/lookupiprouteron.cc:186:      if (Packet *q = p->clone()) {
etc/ron/lookupiprouteron.cc:244:      // _dst_table->insert(IPAddress(p->ip_header()->ip_src), portno);
etc/ron/lookupiprouteron.cc:261:    dst_match = _dst_table->lookup(IPAddress(p->ip_header()->ip_src), false);
etc/ron/lookupiprouteron.cc:274:      //_dst_table->insert(IPAddress(p->ip_header()->ip_src), port);
etc/ron/lookupiprouteron.cc:282:      // _dst_table->insert(IPAddress(p->ip_header()->ip_src), portno);
etc/ron/lookupiprouteron.cc:312:    if (Packet *q = p->clone())
etc/ron/lookupiprouteron.cc:323:  const click_ip  *iph = p->ip_header();
etc/ron/lookupiprouteron.cc:324:  const click_tcp *tcph= p->tcp_header();
etc/ron/lookupiprouteron.cc:330:  tcph = p->tcp_header();
etc/ron/lookupiprouteron.cc:332:  match = _flow_table->lookup(IPAddress(p->ip_header()->ip_src), p->dst_ip_anno(),
etc/ron/lookupiprouteron.cc:357:		    IPAddress(p->ip_header()->ip_src).s().c_str(),
etc/ron/lookupiprouteron.cc:358:		    p->dst_ip_anno().s().c_str());
etc/ron/lookupiprouteron.cc:364:    dst_match = _dst_table->lookup(p->dst_ip_anno(), true);
etc/ron/lookupiprouteron.cc:367:    new_entry = _flow_table->add(IPAddress(p->ip_header()->ip_src), p->dst_ip_anno(),
etc/ron/lookupiprouteron.cc:376:		    IPAddress(p->ip_header()->ip_src).s().c_str(),
etc/ron/lookupiprouteron.cc:377:		    p->dst_ip_anno().s().c_str() );
etc/ron/lookupiprouteron.cc:406:  tcph = p->tcp_header();
etc/ron/lookupiprouteron.cc:410:  match = _flow_table->lookup(IPAddress(p->ip_header()->ip_src), p->dst_ip_anno(),
etc/ron/lookupiprouteron.cc:422:  p->kill();
etc/ron/lookupiprouteron.cc:431:  tcph = p->tcp_header();
etc/ron/lookupiprouteron.cc:434:  match = _flow_table->lookup(IPAddress(p->ip_header()->ip_src), p->dst_ip_anno(),
etc/ron/lookupiprouteron.cc:449:  p->kill();
etc/ron/lookupiprouteron.cc:458:  tcph = p->tcp_header();
etc/ron/lookupiprouteron.cc:462:  match = _flow_table->lookup(IPAddress(p->ip_header()->ip_src), p->dst_ip_anno(),
etc/ron/lookupiprouteron.cc:475:  p->kill();
etc/ron/lookupiprouteron.cc:485:  if (p->ip_header()->ip_p != IP_PROTO_TCP) {
etc/ron/lookupiprouteron.cc:486:    rtprintf("non-TCP proto(%d)\n", p->ip_header()->ip_p);
etc/ron/lookupiprouteron.cc:492:  tcph = p->tcp_header();
etc/ron/lookupiprouteron.cc:510:  tcph = p->tcp_header();
etc/ron/lookupiprouteron.cc:512:  match = _flow_table->lookup(p->dst_ip_anno(),IPAddress(p->ip_header()->ip_src),
etc/ron/lookupiprouteron.cc:529:	     p->dst_ip_anno().s().c_str(),
etc/ron/lookupiprouteron.cc:530:	     IPAddress(p->ip_header()->ip_src).s().c_str() );
etc/ron/lookupiprouteron.cc:533:      _dst_table->insert(IPAddress(p->ip_header()->ip_src), inport);
etc/ron/lookupiprouteron.cc:558:    p->kill();
etc/ron/lookupiprouteron.cc:566:  tcph = p->tcp_header();
etc/ron/lookupiprouteron.cc:568:  match = _flow_table->lookup(p->dst_ip_anno(),IPAddress(p->ip_header()->ip_src),
etc/ron/lookupiprouteron.cc:584:  p->kill();
etc/ron/lookupiprouteron.cc:590:  tcph = p->tcp_header();
etc/ron/lookupiprouteron.cc:591:  match = _flow_table->lookup(p->dst_ip_anno(),IPAddress(p->ip_header()->ip_src),
etc/ron/lookupiprouteron.cc:608:  p->kill();
etc/ron/lookupiprouteron.cc:614:  tcph = p->tcp_header();
etc/ron/lookupiprouteron.cc:616:  match = _flow_table->lookup(p->dst_ip_anno(),IPAddress(p->ip_header()->ip_src),
etc/ron/lookupiprouteron.cc:631:  p->kill();
etc/ron/lookupiprouteron.cc:641:  if (p->ip_header()->ip_p != IP_PROTO_TCP) {
etc/ron/lookupiprouteron.cc:642:    rtprintf("non-TCP proto(%d)\n", p->ip_header()->ip_p);
etc/ron/lookupiprouteron.cc:648:  tcph = p->tcp_header();
etc/ron/lookupiprouteron.cc:677:  tcph = p->tcp_header();
etc/ron/lookupiprouteron.cc:679:  _t->add(IPAddress(p->ip_header()->ip_src), p->dst_ip_anno(),
etc/ron/lookupiprouteron.cc:713:  tcphdr->th_sport = p->tcp_header()->th_dport;
etc/ron/lookupiprouteron.cc:714:  tcphdr->th_dport = p->tcp_header()->th_sport;
etc/ron/lookupiprouteron.cc:716:  tcphdr->th_ack   = htonl(ntohl(p->tcp_header()->th_seq) + 1);
etc/ron/lookupiprouteron.cc:727:  iphdr->ip_src = p->ip_header()->ip_dst;
etc/ron/lookupiprouteron.cc:728:  iphdr->ip_dst = p->ip_header()->ip_src;
etc/ron/lookupiprouteron.cc:744:  p->kill();
etc/ron/lookupiprouteron.cc:964:      tp = p->next;
etc/ron/lookupiprouteron.cc:999:  for(p = probes; p != NULL; p = p->next) {
etc/ron/lookupiprouteron.cc:1000:    if (p->port_number == port)
etc/ron/lookupiprouteron.cc:1007:      prev->next = p->next;
etc/ron/lookupiprouteron.cc:1008:      p->next = probes;
etc/ron/lookupiprouteron.cc:1014:    p->next = probes;
etc/ron/lookupiprouteron.cc:1017:  p->rtt_sec  = rtt_sec;
etc/ron/lookupiprouteron.cc:1018:  p->rtt_usec = rtt_usec;
etc/ron/lookupiprouteron.cc:1019:  p->last_probe_time = tv.tv_sec;
etc/ron/lookupiprouteron.cc:1029:  for(p = probes; p != NULL; p = p->next) {
etc/ron/lookupiprouteron.cc:1030:    if (p->port_number == port) {
etc/ron/lookupiprouteron.cc:1031:      p->last_probe_time = tv.tv_sec;
etc/ron/lookupiprouteron.cc:1032:      p->rtt_sec = 0xffff;
etc/ron/lookupiprouteron.cc:1033:      p->rtt_usec = 0xffff;
etc/ron/lookupiprouteron.cc:1034:      p->first_syn = true;
etc/ron/lookupiprouteron.cc:1036:	prev->next = p->next;
etc/ron/lookupiprouteron.cc:1037:	p->next = probes;
etc/ron/lookupiprouteron.cc:1048:  p->port_number = port;
etc/ron/lookupiprouteron.cc:1049:  p->last_probe_time = tv.tv_sec;
etc/ron/lookupiprouteron.cc:1050:  p->rtt_sec = 0xffff;
etc/ron/lookupiprouteron.cc:1051:  p->rtt_usec = 0xffff;
etc/ron/lookupiprouteron.cc:1052:  p->first_syn = true;
etc/ron/lookupiprouteron.cc:1054:  p->next = probes;
etc/ron/lookupiprouteron.cc:1064:  for(p = probes; p != NULL; p = p->next) {
etc/ron/lookupiprouteron.cc:1065:    //click_chatter("checking port %d to %d", p->port_number, port);
etc/ron/lookupiprouteron.cc:1066:    if (p->port_number == port) {
etc/ron/lookupiprouteron.cc:1067:      if (p->first_syn) {
etc/ron/lookupiprouteron.cc:1068:	p->rtt_sec = sec;
etc/ron/lookupiprouteron.cc:1069:	p->rtt_usec = usec;
etc/ron/lookupiprouteron.cc:1070:	p->first_syn = false;
etc/ron/lookupiprouteron.cc:1080:  p->port_number = port;
etc/ron/lookupiprouteron.cc:1081:  p->last_probe_time = tv.tv_sec;
etc/ron/lookupiprouteron.cc:1082:  p->rtt_sec = sec;
etc/ron/lookupiprouteron.cc:1083:  p->rtt_usec = usec;
etc/ron/lookupiprouteron.cc:1085:  p->next = probes;
etc/ron/lookupiprouteron.cc:1099:  for(p = probes; p != NULL; p = p->next)
etc/ron/lookupiprouteron.cc:1100:    click_chatter(" port %d %06d.%06d", p->port_number, p->rtt_sec, p->rtt_usec);
etc/ron/lookupiprouteron.cc:1102:  for(p = probes; p != NULL; p = p->next) {
etc/ron/lookupiprouteron.cc:1103:    if ( ((p->rtt_sec <= fastest_sec) && (p->rtt_usec < fastest_usec)) ||
etc/ron/lookupiprouteron.cc:1104:	 (p->rtt_sec < fastest_sec)) {
etc/ron/lookupiprouteron.cc:1105:      fastest_sec = p->rtt_sec;
etc/ron/lookupiprouteron.cc:1106:      fastest_usec = p->rtt_usec;
etc/ron/lookupiprouteron.cc:1107:      port = p->port_number;
etc/ron/lookupiprouteron.cc:1132:  for(p = probes; p != NULL; p = p->next) {
etc/ron/lookupiprouteron.cc:1133:    if (p->port_number != not1 && p->port_number != not2) {
etc/ron/lookupiprouteron.cc:1134:      last_used = p->port_number;
etc/ron/lookupiprouteron.cc:1137:    bv[p->port_number - 1] = true;
etc/ron/ipencappaint.cc:80:  click_ip *ip = reinterpret_cast<click_ip *>( p->data());
etc/ron/ipencappaint.cc:82:  ip->ip_v = 4;
etc/ron/ipencappaint.cc:83:  ip->ip_hl = sizeof(click_ip) >> 2;
etc/ron/ipencappaint.cc:84:  ip->ip_len = htons(p->length() );
etc/ron/ipencappaint.cc:85:  ip->ip_id = htons(_id++);
etc/ron/ipencappaint.cc:86:  ip->ip_p = _ip_p;
etc/ron/ipencappaint.cc:87:  ip->ip_src = _ip_src;
etc/ron/ipencappaint.cc:90:  p->data()[ sizeof(click_ip) ] = _color;
etc/ron/ipencappaint.cc:93:  ip->ip_dst = p_in->dst_ip_anno().in_addr();
etc/ron/ipencappaint.cc:96:  ip->ip_tos = 0;
etc/ron/ipencappaint.cc:97:  ip->ip_off = 0;
etc/ron/ipencappaint.cc:98:  ip->ip_ttl = 250;
etc/ron/ipencappaint.cc:100:  ip->ip_sum = 0;
etc/ron/ipencappaint.cc:103:    ip->ip_sum = ip_fast_csum((unsigned char *)ip, (sizeof(click_ip)) >> 2);
etc/ron/ipencappaint.cc:106:  ip->ip_sum = click_in_cksum((unsigned char *)ip, (sizeof(click_ip) ));
etc/ron/ipencappaint.cc:111:  p->set_dst_ip_anno(IPAddress(ip->ip_dst));
etc/ron/ipencappaint.cc:112:  p->set_ip_header(ip, sizeof(click_ip));
etc/ron/ipdecappaint.cc:40:  assert(p->has_network_header());
etc/ron/ipdecappaint.cc:41:  const click_ip *ip = p->ip_header();
etc/ron/ipdecappaint.cc:43:  if (ip->ip_p != IP_PROTO_IPIP) {
etc/ron/ipdecappaint.cc:44:    p->kill();
etc/ron/ipdecappaint.cc:48:  SET_PAINT_ANNO(p, p->data()[ sizeof(click_ip)] );
etc/ron/ipdecappaint.cc:52:  p->pull( (int)p->ip_header_offset() + p->ip_header_length() + 1);
etc/ron/portclassifier.cc:58:  const click_tcp *tcph= p->tcp_header();
etc/ron/policyprobe.cc:73:  const click_ip  *iph = p->ip_header();
etc/ron/policyprobe.cc:74:  const click_tcp *tcph= p->tcp_header();
etc/ron/policyprobe.cc:81:  flowentry = _flowtable->lookup(IPAddress(p->ip_header()->ip_src),
etc/ron/policyprobe.cc:83:				 IPAddress(p->ip_header()->ip_dst),
etc/ron/policyprobe.cc:89:    flowentry = _flowtable->insert(IPAddress(p->ip_header()->ip_src),
etc/ron/policyprobe.cc:91:				   IPAddress(p->ip_header()->ip_dst),
etc/ron/policyprobe.cc:97:    //flowentry->syn_pkt = Packet::make(p->data(), p->length());
etc/ron/policyprobe.cc:98:    flowentry->syn_pkt = p->clone();
etc/ron/policyprobe.cc:119:  const click_tcp *tcph= p->tcp_header();
etc/ron/policyprobe.cc:120:  flowentry = _flowtable->lookup(IPAddress(p->ip_header()->ip_src),
etc/ron/policyprobe.cc:122:				 IPAddress(p->ip_header()->ip_dst),
etc/ron/policyprobe.cc:126:    p->kill();
etc/ron/policyprobe.cc:139:  const click_tcp *tcph= p->tcp_header();
etc/ron/policyprobe.cc:140:  flowentry = _flowtable->lookup(IPAddress(p->ip_header()->ip_src),
etc/ron/policyprobe.cc:142:				 IPAddress(p->ip_header()->ip_dst),
etc/ron/policyprobe.cc:145:    p->kill();
etc/ron/policyprobe.cc:154:  const click_tcp *tcph= p->tcp_header();
etc/ron/policyprobe.cc:156:  flowentry = _flowtable->lookup(IPAddress(p->ip_header()->ip_src),
etc/ron/policyprobe.cc:158:				 IPAddress(p->ip_header()->ip_dst),
etc/ron/policyprobe.cc:162:    p->kill();
etc/ron/policyprobe.cc:170:  const click_tcp *tcph= p->tcp_header();
etc/ron/policyprobe.cc:173:  flowentry = _flowtable->lookup(IPAddress(p->ip_header()->ip_dst),
etc/ron/policyprobe.cc:175:				 IPAddress(p->ip_header()->ip_src),
etc/ron/policyprobe.cc:180:    p->kill();
etc/ron/policyprobe.cc:186:    p->kill();
etc/ron/policyprobe.cc:210:    //p->kill(); // send_rst already does this
etc/ron/policyprobe.cc:230:  const click_tcp *tcph= p->tcp_header();
etc/ron/policyprobe.cc:231:  flowentry = _flowtable->lookup(IPAddress(p->ip_header()->ip_dst),
etc/ron/policyprobe.cc:233:				 IPAddress(p->ip_header()->ip_src),
etc/ron/policyprobe.cc:237:    p->kill();
etc/ron/policyprobe.cc:250:  const click_tcp *tcph= p->tcp_header();
etc/ron/policyprobe.cc:251:  flowentry = _flowtable->lookup(IPAddress(p->ip_header()->ip_dst),
etc/ron/policyprobe.cc:253:				 IPAddress(p->ip_header()->ip_src),
etc/ron/policyprobe.cc:256:    p->kill();
etc/ron/policyprobe.cc:264:  const click_tcp *tcph= p->tcp_header();
etc/ron/policyprobe.cc:266:  flowentry = _flowtable->lookup(IPAddress(p->ip_header()->ip_dst),
etc/ron/policyprobe.cc:268:			     IPAddress(p->ip_header()->ip_src),
etc/ron/policyprobe.cc:272:    p->kill();
etc/ron/policyprobe.cc:460:    if (p->match(src,sport,dst,dport))
etc/ron/policyprobe.cc:462:    p = p->next;
etc/ron/policyprobe.cc:479:    if (p->match(src,sport,dst,dport))
etc/ron/policyprobe.cc:481:    p = p->next;
etc/ron/policyprobe.cc:493:    if (p->match(src,sport,dst,dport)) {
etc/ron/policyprobe.cc:494:      *last = p->next;
etc/ron/policyprobe.cc:498:      last = &(p->next);
etc/ron/policyprobe.cc:499:      p = p->next;
etc/ron/discardnotify.cc:74:    p->kill();
etc/ron/divertsocket.cc:464:  len = recvfrom(_fd, p->data(), p->length(), 0, (sockaddr *)&sa, &fromlen);
etc/ron/divertsocket.cc:469:    p->timestamp_anno() = Timestamp::now();
etc/ron/divertsocket.cc:470:    p->change_headroom_and_length(2, len);
etc/ron/divertsocket.cc:474:    p->kill();
etc/ron/divertsocket.cc:490:  memcpy(&sa.sin_addr.s_addr, p->data() + 16, 4);
etc/ron/divertsocket.cc:493:  n = sendto(_fd, p->data(), p->length() , 0,
etc/ron/divertsocket.cc:499:  p->kill();
etc/ron/divertsocket.cc:505:  assert(p->length() >= 20);
etc/ron/ronroutemodular.cc:86:    p->kill();
etc/ron/ronroutemodular.cc:91:  if (p->ip_header()->ip_p != IP_PROTO_TCP) {
etc/ron/ronroutemodular.cc:92:    dprintf("non-TCP proto(%d)", p->ip_header()->ip_p);
etc/ron/ronroutemodular.cc:99:  tcph = p->tcp_header();
etc/ron/ronroutemodular.cc:100:  _flowtable->insert(IPAddress(p->ip_header()->ip_src), ntohs(tcph->th_sport),
etc/ron/ronroutemodular.cc:101:		     IPAddress(p->ip_header()->ip_dst), ntohs(tcph->th_dport),
etc/ron/ronroutemodular.cc:124:  if (p->ip_header()->ip_p != IP_PROTO_TCP) {
etc/ron/ronroutemodular.cc:125:    dprintf("non-TCP proto(%d)", p->ip_header()->ip_p);
etc/ron/ronroutemodular.cc:130:  tcph = p->tcp_header();
etc/ron/ronroutemodular.cc:131:  entry = _flowtable->lookup(IPAddress(p->ip_header()->ip_dst),
etc/ron/ronroutemodular.cc:133:			     IPAddress(p->ip_header()->ip_src),
etc/ron/ronroutemodular.cc:139:    p->kill();
etc/ron/ronroutemodular.cc:144:  tcph = p->tcp_header();
etc/ron/ronroutemodular.cc:170:  tcphdr->th_sport = p->tcp_header()->th_dport;
etc/ron/ronroutemodular.cc:171:  tcphdr->th_dport = p->tcp_header()->th_sport;
etc/ron/ronroutemodular.cc:173:  tcphdr->th_ack   = htonl(ntohl(p->tcp_header()->th_seq) + 1);
etc/ron/ronroutemodular.cc:184:  iphdr->ip_src = p->ip_header()->ip_dst;
etc/ron/ronroutemodular.cc:185:  iphdr->ip_dst = p->ip_header()->ip_src;
etc/ron/ronroutemodular.cc:201:  p->kill();
etc/ron/printtime.cc:88:  if (!p->has_network_header()) {
etc/ron/printtime.cc:93:  const click_ip *iph = p->ip_header();
etc/ron/printtime.cc:106:    const click_tcp *tcph = p->tcp_header();
etc/ron/printtime.cc:131:    const click_udp *udph = p->udp_header();
etc/ron/ipencap2.cc:76:  click_ip *ip = reinterpret_cast<click_ip *>(p->data());
etc/ron/ipencap2.cc:78:  ip->ip_v = 4;
etc/ron/ipencap2.cc:79:  ip->ip_hl = sizeof(click_ip) >> 2;
etc/ron/ipencap2.cc:80:  ip->ip_len = htons(p->length());
etc/ron/ipencap2.cc:81:  ip->ip_id = htons(_id++);
etc/ron/ipencap2.cc:82:  ip->ip_p = _ip_p;
etc/ron/ipencap2.cc:83:  ip->ip_src = _ip_src;
etc/ron/ipencap2.cc:84:  ip->ip_dst = p_in->dst_ip_anno().in_addr();
etc/ron/ipencap2.cc:86:  ip->ip_tos = 0;
etc/ron/ipencap2.cc:87:  ip->ip_off = 0;
etc/ron/ipencap2.cc:88:  ip->ip_ttl = 250;
etc/ron/ipencap2.cc:90:  ip->ip_sum = 0;
etc/ron/ipencap2.cc:93:    ip->ip_sum = ip_fast_csum((unsigned char *)ip, sizeof(click_ip) >> 2);
etc/ron/ipencap2.cc:96:  ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
etc/ron/ipencap2.cc:101:  p->set_dst_ip_anno(IPAddress(ip->ip_dst));
etc/ron/ipencap2.cc:102:  p->set_ip_header(ip, sizeof(click_ip));
etc/ron/policyprobe.hh:295:      p = p->next;
etc/ron/policyprobe.hh:324:      fprintf(stderr, " timerqueue: %Lf %d %d ", p->time, p->action, p->data);
etc/ron/policyprobe.hh:325:      p->entry->print();
etc/ron/policyprobe.hh:327:      p = p->next;
etc/ron/policyprobe.hh:335:    while(p && p->time <= time) {
etc/ron/policyprobe.hh:336:      last = &(p->next);
etc/ron/policyprobe.hh:337:      p = p->next;
etc/ron/policyprobe.hh:383:      if ( (p->entry == entry) && ((data == -1) || (p->data == data))) {
etc/ron/policyprobe.hh:384:	*last = p->next;
etc/ron/policyprobe.hh:388:	last = &(p->next);
etc/ron/policyprobe.hh:389:	p = p->next;
etc/ron/printtime.hh:20:Prints out IP packets in a human-readable tcpdump-like format, preceded by
missing:357:# time-stamp-start: "scriptversion="
missing:358:# time-stamp-format: "%:y-%02m-%02d.%02H"
missing:359:# time-stamp-end: "$"
include/click/ip6address.hh:202:    return *reinterpret_cast<IP6Address *>(p->anno_u8() + DST_IP6_ANNO_OFFSET);
include/click/ip6address.hh:208:    memcpy(p->anno_u8() + DST_IP6_ANNO_OFFSET, a.data(), DST_IP6_ANNO_SIZE);
include/click/ip6address.hh:214:    memcpy(p->anno_u8() + DST_IP6_ANNO_OFFSET, &a, DST_IP6_ANNO_SIZE);
include/click/element.hh:632:	p->kill();
include/click/list.hh:312:	    (p->*member)._next = n;
include/click/routerthread.hh:129:    struct Client {			// top-level stride clients
include/click/packet.hh:98:     * WritablePacket *q = p->push(14);
include/click/packet.hh:170:     * WritablePacket *q = p->put(100);
include/click/packet.hh:854:    skb()->next = p->skb();
include/click/packet.hh:884:    skb()->prev = p->skb();
include/click/packet.hh:1259:  struct mbuf *m = p->m();
include/click/packet.hh:1263:  p->_head = (unsigned char *)
include/click/packet.hh:1267:  p->_data = (unsigned char *)m->m_data;
include/click/packet.hh:1268:  p->_tail = (unsigned char *)(m->m_data + m->m_len);
include/click/packet.hh:1269:  p->_end = p->_head + (
include/click/packet.hh:1295:  p->_m = m;
include/click/packet.hh:1333: * WritablePacket *q = p->uniqueify();
include/click/packet.hh:1885:    *xanno() = *p->xanno();
include/click/packet.hh:1886:    set_packet_type_anno(p->packet_type_anno());
include/click/packet.hh:1887:    set_device_anno(p->device_anno());
include/click/packet.hh:1888:    set_timestamp_anno(p->timestamp_anno());
include/click/hashmap.hh:50:  V *findp_force(const K &k, const V &v) { if (Pair *p = find_pair_force(k, v)) return &p->value; else return 0; }
include/click/hashmap.hh:193:  return (p ? &p->value : 0);
include/click/hashmap.hh:201:  const V *v = (p ? &p->value : &default_value);
include/click/hashmap.hh:253:  void **findp_force(const K &k, void *v) { if (Pair *p = find_pair_force(k, v)) return &p->value; else return 0; }
include/click/hashmap.hh:397:  return (p ? &p->value : 0);
include/click/hashmap.hh:405:  return (p ? p->value : default_value);
linuxmodule/proclikefs.c:213:    for (p = pfs->fs.fs_supers.next; p != &pfs->fs.fs_supers; p = p->next) {
linuxmodule/proclikefs.c:241:	filp->f_op = dummy;
linuxmodule/proclikefs.c:246:    for (p = sb->s_files.next; p != &sb->s_files; p = p->next) {
linuxmodule/proclikefs.c:248:	filp->f_op = dummy;
linuxmodule/proclikefs.c:325:	memcpy(&fo->llseek, &dummy_inode.i_fop->llseek,
linuxmodule/proclikefs.c:341:    for (filp = inuse_filps; filp; filp = filp->f_next) {
linuxmodule/proclikefs.c:342:	struct dentry *dentry = filp->f_dentry;
linuxmodule/proclikefs.c:348:	filp->f_op = &pfs->pfs_pfo->pfo_op;
linuxmodule/proclikefs.c:358:    for (p = pfs->fs.fs_supers.next; p != &pfs->fs.fs_supers; p = p->next) {
linuxmodule/clickfs.cc:299:    struct inode *inode = filp->f_dentry->d_inode;
linuxmodule/clickfs.cc:301:    uint32_t f_pos = filp->f_pos;
linuxmodule/clickfs.cc:310:	if (my_filldir("..", 2, filp->f_dentry->d_parent->d_inode->i_ino, f_pos, DT_DIR, &mfd))
linuxmodule/clickfs.cc:321:    filp->f_pos = f_pos;
linuxmodule/clickfs.cc:536:    bool reading = (filp->f_flags & O_ACCMODE) != O_WRONLY;
linuxmodule/clickfs.cc:537:    bool writing = (filp->f_flags & O_ACCMODE) != O_RDONLY;
linuxmodule/clickfs.cc:544:	|| (filp->f_flags & O_APPEND)
linuxmodule/clickfs.cc:545:	|| (writing && !(filp->f_flags & O_TRUNC)))
linuxmodule/clickfs.cc:567:    filp->private_data = reinterpret_cast<void *>(stringno);
linuxmodule/clickfs.cc:584:	struct inode *inode = filp->f_dentry->d_inode;
linuxmodule/clickfs.cc:684:    struct inode *inode = filp->f_dentry->d_inode;
linuxmodule/clickfs.cc:779:    bool writing = (filp->f_flags & O_ACCMODE) != O_RDONLY;
linuxmodule/clickfs.cc:783:    int f_count = atomic_read(&filp->f_count);
basic-array.cc:79:		if(!strcmp(chksta.mac->unparse().c_str(), lkup->mac->unparse().c_str())) {
basic-array.cc:163:	struct click_wifi *w = (struct click_wifi *) p->data();
config.sub:360:	| romp-* | rs6000-* \
config.sub:373:	| ymp-* \
config.sub:927:		basic_machine=romp-ibm
config.sub:1124:		basic_machine=ymp-cray
config.sub:1148:		basic_machine=romp-ibm
config.sub:1456:        mep-*)
config.sub:1655:# time-stamp-start: "timestamp='"
config.sub:1656:# time-stamp-format: "%:y-%02m-%02d"
config.sub:1657:# time-stamp-end: "'"
drivers/e1000-2.x/e1000_proc.c:98:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:99:	struct net_device_stats *stats = &bdp->net_stats;
drivers/e1000-2.x/e1000_proc.c:136:				(unsigned long) (bdp->irq_level));
drivers/e1000-2.x/e1000_proc.c:139:				bdp->device->name);
drivers/e1000-2.x/e1000_proc.c:141:	hwaddr = bdp->device->dev_addr;
drivers/e1000-2.x/e1000_proc.c:172:	if (bdp->device->flags & IFF_UP)
drivers/e1000-2.x/e1000_proc.c:271:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:303:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:313:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:323:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:333:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:343:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:354:	strncpy(page, bdp->device->name, PAGE_SIZE);
drivers/e1000-2.x/e1000_proc.c:363:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:373:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:386:					  (unsigned long) (bdp->irq_level));
drivers/e1000-2.x/e1000_proc.c:393:	unsigned char *hwaddr = bdp->device->dev_addr;
drivers/e1000-2.x/e1000_proc.c:402:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:412:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:426:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:439:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:454:	if (bdp->device->flags & IFF_UP)
drivers/e1000-2.x/e1000_proc.c:468:					  (unsigned long) bdp->net_stats.rx_packets);
drivers/e1000-2.x/e1000_proc.c:477:					  (unsigned long) bdp->net_stats.tx_packets);
drivers/e1000-2.x/e1000_proc.c:486:					  (unsigned long) bdp->net_stats.rx_bytes);
drivers/e1000-2.x/e1000_proc.c:495:					  (unsigned long) bdp->net_stats.tx_bytes);
drivers/e1000-2.x/e1000_proc.c:504:					  (unsigned long) bdp->net_stats.rx_errors);
drivers/e1000-2.x/e1000_proc.c:513:					  (unsigned long) bdp->net_stats.rx_errors);
drivers/e1000-2.x/e1000_proc.c:522:					  (unsigned long) bdp->net_stats.rx_dropped);
drivers/e1000-2.x/e1000_proc.c:531:					  (unsigned long) bdp->net_stats.tx_dropped);
drivers/e1000-2.x/e1000_proc.c:540:					  (unsigned long) bdp->net_stats.multicast);
drivers/e1000-2.x/e1000_proc.c:549:					  (unsigned long) bdp->net_stats.collisions);
drivers/e1000-2.x/e1000_proc.c:558:					  (unsigned long) bdp->net_stats.rx_length_errors);
drivers/e1000-2.x/e1000_proc.c:567:					  (unsigned long) bdp->net_stats.rx_over_errors);
drivers/e1000-2.x/e1000_proc.c:576:					  (unsigned long) bdp->net_stats.rx_crc_errors);
drivers/e1000-2.x/e1000_proc.c:585:					  (unsigned long) bdp->net_stats.rx_frame_errors);
drivers/e1000-2.x/e1000_proc.c:594:					  (unsigned long) bdp->net_stats.rx_fifo_errors);
drivers/e1000-2.x/e1000_proc.c:603:					  (unsigned long) bdp->net_stats.rx_missed_errors);
drivers/e1000-2.x/e1000_proc.c:612:					  (unsigned long) bdp->net_stats.tx_aborted_errors);
drivers/e1000-2.x/e1000_proc.c:621:					  (unsigned long) bdp->net_stats.tx_carrier_errors);
drivers/e1000-2.x/e1000_proc.c:630:					  (unsigned long) bdp->net_stats.tx_fifo_errors);
drivers/e1000-2.x/e1000_proc.c:639:					  (unsigned long) bdp->net_stats.tx_heartbeat_errors);
drivers/e1000-2.x/e1000_proc.c:648:					  (unsigned long) bdp->net_stats.tx_window_errors);
drivers/e1000-2.x/e1000_proc.c:656:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:664:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:671:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:678:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:685:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:692:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:699:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:706:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:713:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:720:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:727:	PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_proc.c:740:	pdep->read_proc = read_proc;
drivers/e1000-2.x/e1000_proc.c:741:	pdep->data = bdp;
drivers/e1000-2.x/e1000_proc.c:751:	dev_dir = create_proc_entry(bdp->device->name, S_IFDIR, e1000_proc_dir);
drivers/e1000-2.x/e1000_proc.c:753:	strncpy(info, bdp->device->name, sizeof(info));
drivers/e1000-2.x/e1000_proc.c:897:	if(bdp->bddp->MacType >= MAC_LIVENGOOD)
drivers/e1000-2.x/ans_driver.h:61:		((((bd_config_t *)(bps))->bddp->MacType < MAC_LIVENGOOD) ? \
drivers/e1000-2.x/ans_driver.h:71:#define BD_ANS_DRV_PHY_ID(bps)    (((bd_config_t *)(bps))->bddp->PhyId)
drivers/e1000-2.x/ans_driver.h:72:#define BD_ANS_DRV_REV_ID(bps)    (((bd_config_t *)(bps))->bddp->RevId)
drivers/e1000-2.x/ans_driver.h:73:#define BD_ANS_DRV_SUBSYS_ID(bps) (((bd_config_t *)(bps))->bddp->SubSystemId)
drivers/e1000-2.x/e1000_main.c:258:        bdp->device = dev;
drivers/e1000-2.x/e1000_main.c:269:        bdp->timer_val = -1;
drivers/e1000-2.x/e1000_main.c:272:        Adapter = (PADAPTER_STRUCT) bdp->bddp;
drivers/e1000-2.x/e1000_main.c:275:        bdp->iANSdata = kmalloc(sizeof(iANSsupport_t), GFP_KERNEL);
drivers/e1000-2.x/e1000_main.c:276:        memset((PVOID) bdp->iANSdata, 0, sizeof(iANSsupport_t));
drivers/e1000-2.x/e1000_main.c:277:        bd_ans_drv_InitANS(bdp, bdp->iANSdata);
drivers/e1000-2.x/e1000_main.c:378:        bdp->device = dev;
drivers/e1000-2.x/e1000_main.c:380:        Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_main.c:384:        bdp->vendor = pcid->vendor;
drivers/e1000-2.x/e1000_main.c:388:        bdp->irq_level = pcid->irq;
drivers/e1000-2.x/e1000_main.c:444:        bdp->mem_start = pci_resource_start(pcid, 0);
drivers/e1000-2.x/e1000_main.c:448:                   (void *) bdp->mem_start,
drivers/e1000-2.x/e1000_main.c:471:            printk("  irq_level = 0x%x\n", bdp->irq_level);
drivers/e1000-2.x/e1000_main.c:542:        next_bdp = bdp->bd_next;
drivers/e1000-2.x/e1000_main.c:545:            next_dev = next_bdp->device;
drivers/e1000-2.x/e1000_main.c:548:        Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_main.c:565:        kfree(bdp->iANSdata);
drivers/e1000-2.x/e1000_main.c:853:    Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_main.c:859:    if(bdp->flags & BOARD_OPEN)
drivers/e1000-2.x/e1000_main.c:888:        bdp->flags |= PROMISCUOUS;
drivers/e1000-2.x/e1000_main.c:892:        bdp->flags &= ~PROMISCUOUS;
drivers/e1000-2.x/e1000_main.c:901:    init_timer(&bdp->timer_id);
drivers/e1000-2.x/e1000_main.c:906:    bdp->timer_id.expires = bdp->timer_val = jiffies + 200;
drivers/e1000-2.x/e1000_main.c:907:    bdp->timer_id.data = (ulong_t) dev;
drivers/e1000-2.x/e1000_main.c:908:    bdp->timer_id.function = (void *) &e1000_watchdog;
drivers/e1000-2.x/e1000_main.c:911:    add_timer(&bdp->timer_id);
drivers/e1000-2.x/e1000_main.c:922:    bdp->flags |= BOARD_OPEN;
drivers/e1000-2.x/e1000_main.c:957:    Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_main.c:972:    del_timer(&bdp->timer_id);
drivers/e1000-2.x/e1000_main.c:984:    free_contig(bdp->base_tx_tbds);
drivers/e1000-2.x/e1000_main.c:985:    bdp->base_tx_tbds = NULL;
drivers/e1000-2.x/e1000_main.c:1014:    free_contig(bdp->base_rx_rbds);
drivers/e1000-2.x/e1000_main.c:1015:    bdp->base_rx_rbds = NULL;
drivers/e1000-2.x/e1000_main.c:1017:    bdp->flags &= ~BOARD_OPEN;
drivers/e1000-2.x/e1000_main.c:1040:    Adapter = (PADAPTER_STRUCT) bdp->bddp;
drivers/e1000-2.x/e1000_main.c:1058:      if(bdp->iANSdata->iANS_status == IANS_COMMUNICATION_UP) {
drivers/e1000-2.x/e1000_main.c:1065:    if(bdp->tx_out_res == 0)
drivers/e1000-2.x/e1000_main.c:1130:    Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_main.c:1131:    // stats = &bdp->net_stats;
drivers/e1000-2.x/e1000_main.c:1160:    if(bdp->iANSdata->iANS_status == IANS_COMMUNICATION_UP) {
drivers/e1000-2.x/e1000_main.c:1218:      bdp->tx_out_res = 1;
drivers/e1000-2.x/e1000_main.c:1249:    return (&bdp->net_stats);
drivers/e1000-2.x/e1000_main.c:1283:    Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_main.c:1375:    dev = bdp->device;
drivers/e1000-2.x/e1000_main.c:1376:    Adapter = (PADAPTER_STRUCT) bdp->bddp;
drivers/e1000-2.x/e1000_main.c:1407:    memcpy(bdp->eaddr.bytes, &Adapter->perm_node_address[0],
drivers/e1000-2.x/e1000_main.c:1444:    bdp->flags = BOARD_PRESENT;
drivers/e1000-2.x/e1000_main.c:1484:    dev = bdp->device;
drivers/e1000-2.x/e1000_main.c:1486:    Adapter = (PADAPTER_STRUCT) bdp->bddp; /* Setup Shared Memory Structures */
drivers/e1000-2.x/e1000_main.c:1501:        bdp->flags = BOARD_DISABLED;
drivers/e1000-2.x/e1000_main.c:1556:    Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_main.c:1602:    memcpy(bdp->eaddr.bytes, addr->sa_data, DL_MAC_ADDR_LEN);
drivers/e1000-2.x/e1000_main.c:1662:    PADAPTER_STRUCT Adapter = (PADAPTER_STRUCT) bdp->bddp;
drivers/e1000-2.x/e1000_main.c:1666:               bdp->device->name, (void *) bdp->mem_start,
drivers/e1000-2.x/e1000_main.c:1667:               bdp->irq_level, Adapter->cur_line_speed,
drivers/e1000-2.x/e1000_main.c:1672:               bdp->device->name, (void *) bdp->mem_start, bdp->irq_level);
drivers/e1000-2.x/e1000_main.c:1847:    PADAPTER_STRUCT Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_main.c:1958:        printk("e1000: %s Link is Down\n", bdp->device->name);
drivers/e1000-2.x/e1000_main.c:1995:    Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_main.c:1996:    stats = &bdp->net_stats;
drivers/e1000-2.x/e1000_main.c:2188:    Adapter = (PADAPTER_STRUCT) bdp->bddp;
drivers/e1000-2.x/e1000_main.c:2337:    Adapter = (PADAPTER_STRUCT) bdp->bddp;
drivers/e1000-2.x/e1000_main.c:2349:    if (!bdp->flags || (bdp->flags & BOARD_DISABLED)) {
drivers/e1000-2.x/e1000_main.c:2384:            mod_timer(&bdp->timer_id, jiffies);
drivers/e1000-2.x/e1000_main.c:2494:    Adapter = (PADAPTER_STRUCT) bdp->bddp;
drivers/e1000-2.x/e1000_main.c:2495:    dev = bdp->device;
drivers/e1000-2.x/e1000_main.c:2541:    if (freed_some && bdp->tx_out_res){
drivers/e1000-2.x/e1000_main.c:2542:      bdp->tx_out_res = 0;
drivers/e1000-2.x/e1000_main.c:2544:      if(bdp->iANSdata->iANS_status == IANS_COMMUNICATION_UP) {
drivers/e1000-2.x/e1000_main.c:2607:    Adapter = (PADAPTER_STRUCT) bdp->bddp;
drivers/e1000-2.x/e1000_main.c:2611:    if ((dev->flags & IFF_PROMISC) && !(bdp->flags & PROMISCUOUS)) {
drivers/e1000-2.x/e1000_main.c:2614:        bdp->flags |= PROMISCUOUS;
drivers/e1000-2.x/e1000_main.c:2618:        bdp->flags &= ~PROMISCUOUS;
drivers/e1000-2.x/e1000_main.c:2623:    if ((dev->flags & IFF_ALLMULTI) && !(bdp->flags & ALL_MULTI)) {
drivers/e1000-2.x/e1000_main.c:2627:        bdp->flags |= ALL_MULTI;
drivers/e1000-2.x/e1000_main.c:2633:        bdp->flags &= ~ALL_MULTI;
drivers/e1000-2.x/e1000_main.c:2909:    Adapter = (PADAPTER_STRUCT) bdp->bddp;
drivers/e1000-2.x/e1000_main.c:2910:    dev = bdp->device;
drivers/e1000-2.x/e1000_main.c:2911:    // stats = &bdp->net_stats;
drivers/e1000-2.x/e1000_main.c:2957:                    (bdp->iANSdata->tag_mode == IANS_BD_TAGGING_802_3AC ?
drivers/e1000-2.x/e1000_main.c:3025:                if(bdp->iANSdata->iANS_status == IANS_COMMUNICATION_UP) {
drivers/e1000-2.x/e1000_main.c:3137:    Adapter = (PADAPTER_STRUCT) bdp->bddp;
drivers/e1000-2.x/e1000_main.c:3143:    if (bdp->flags & BOARD_PRESENT) {
drivers/e1000-2.x/e1000_main.c:3186:    if (bdp->iANSdata->reporting_mode == IANS_STATUS_REPORTING_ON) {
drivers/e1000-2.x/e1000_main.c:3191:    mod_timer(&bdp->timer_id, jiffies + (2 * HZ));
drivers/e1000-2.x/e1000_main.c:3391:        printk("e1000_sw_init: [brd %d] begin\n", bdp->bd_number);
drivers/e1000-2.x/e1000_main.c:3393:    Adapter = bdp->bddp;
drivers/e1000-2.x/e1000_main.c:3395:    mem_base = bdp->mem_start;
drivers/e1000-2.x/e1000_main.c:3396:    bd_no = bdp->bd_number;
drivers/e1000-2.x/e1000_main.c:3437:    bdp->base_tx_tbds = (void *) kmalloc(
drivers/e1000-2.x/e1000_main.c:3443:    if (bdp->base_tx_tbds == NULL) {
drivers/e1000-2.x/e1000_main.c:3448:        (((unsigned long) bdp->base_tx_tbds + 4096) & ~4096);
drivers/e1000-2.x/e1000_main.c:3489:    bdp->base_rx_rbds = (void *) kmalloc(
drivers/e1000-2.x/e1000_main.c:3495:    if (bdp->base_rx_rbds == 0) {
drivers/e1000-2.x/e1000_main.c:3500:        (((unsigned long) bdp->base_rx_rbds + 4096) & ~4096);
drivers/e1000-2.x/e1000_main.c:3551:            skb->dev = bdp->device;
drivers/e1000-2.x/e1000_main.c:3563:         ((mltcst_cb_t *)&bdp->mc_data)->MulticastBuffer;
drivers/e1000-2.x/e1000_main.c:3565:    Adapter->pmc_buff = (mltcst_cb_t *) bdp->mc_data;
drivers/e1000-2.x/e1000_main.c:3628:        bdp->bd_number = 0;
drivers/e1000-2.x/e1000_main.c:3629:        bdp->bd_next = NULL;
drivers/e1000-2.x/e1000_main.c:3630:        bdp->bd_prev = NULL;
drivers/e1000-2.x/e1000_main.c:3638:        bdp->bd_number = 1;        /* it is at least 1 */
drivers/e1000-2.x/e1000_main.c:3641:            bdp->bd_number++;    /* set the board number */
drivers/e1000-2.x/e1000_main.c:3644:        bdp->bd_next = NULL;
drivers/e1000-2.x/e1000_main.c:3645:        bdp->bd_prev = temp_bd;
drivers/e1000-2.x/e1000_main.c:3672:    bdp->bddp = Adapter;
drivers/e1000-2.x/e1000_main.c:3675:        printk("bdp->bddp = 0x%p\n", bdp->bddp);
drivers/e1000-2.x/e1000_main.c:3679:        (bdp->mc_data =
drivers/e1000-2.x/e1000_main.c:3685:    memset(bdp->mc_data, 0x00, sizeof(mltcst_cb_t));
drivers/e1000-2.x/e1000_main.c:3688:        printk("bdp->mc_data = 0x%p\n", bdp->mc_data);
drivers/e1000-2.x/e1000_main.c:3722:        free_contig(bdp->mc_data);
drivers/e1000-2.x/e1000_main.c:3723:        bdp->mc_data = NULL;
drivers/e1000-2.x/e1000_main.c:3725:        free_contig(bdp->bddp);
drivers/e1000-2.x/e1000_main.c:3726:        bdp->bddp = NULL;
drivers/e1000-2.x/e1000_main.c:3730:            e1000first = (bd_config_t *) bdp->bd_next;
drivers/e1000-2.x/e1000_main.c:3731:            if (bdp->bd_next)
drivers/e1000-2.x/e1000_main.c:3732:                ((bd_config_t *) bdp->bd_next)->bd_prev = NULL;
drivers/e1000-2.x/e1000_main.c:3734:            if (bdp->bd_next)
drivers/e1000-2.x/e1000_main.c:3735:                ((bd_config_t *) bdp->bd_next)->bd_prev = bdp->bd_prev;
drivers/e1000-2.x/e1000_main.c:3736:            if (bdp->bd_prev)
drivers/e1000-2.x/e1000_main.c:3737:                ((bd_config_t *) bdp->bd_prev)->bd_next = bdp->bd_next;
drivers/e1000-2.x/e1000_main.c:3937:  PADAPTER_STRUCT Adapter = (PADAPTER_STRUCT) bdp->bddp;
drivers/e1000-2.x/e1000_main.c:3963:  PADAPTER_STRUCT Adapter = (PADAPTER_STRUCT) bdp->bddp;
drivers/e1000-2.x/e1000_main.c:3980:  PADAPTER_STRUCT Adapter = (PADAPTER_STRUCT) bdp->bddp;
drivers/e1000-2.x/e1000_main.c:4094:  PADAPTER_STRUCT Adapter = (PADAPTER_STRUCT) bdp->bddp;
drivers/e1000-2.x/e1000_main.c:4121:    dp->BufferAddress = virt_to_bus(skb->tail);
drivers/e1000-2.x/e1000_main.c:4122:    dp->ReceiveStatus = 0;
drivers/e1000-2.x/e1000_main.c:4165:  Adapter = bdp->bddp;
drivers/e1000-2.x/ans_driver.c:59:    iANSdata->link_status = (UINT32 *)&(((bd_config_t *)bps)->bddp->ans_link);
drivers/e1000-2.x/ans_driver.c:60:    iANSdata->line_speed  = &(((bd_config_t *)bps)->bddp->ans_speed);
drivers/e1000-2.x/ans_driver.c:61:    iANSdata->duplex      = &(((bd_config_t *)bps)->bddp->ans_duplex);
drivers/e1000-2.x/ans_driver.c:63:    iANSdata->suspended = &(((bd_config_t *)bps)->bddp->AdapterStopped);
drivers/e1000-2.x/ans_driver.c:64:    iANSdata->in_reset  = &(((bd_config_t *)bps)->bddp->AdapterStopped);
drivers/e1000-4.x/src/e1000_main.c:2431:		adapter->vlgrp->vlan_devices[vid] = NULL;
drivers/e1000-4.x/src/e1000_hw.c:1883:        /* Set up Op-code, Phy Address, and register address in the MDI
drivers/e1000-4.x/src/e1000_hw.c:1964:        /* Set up Op-code, Phy Address, register address, and data intended
drivers/e1000-6.x/src/Makefile:123:  CFLAGS += -ffixed-8 -mno-fp-regs
drivers/e1000-6.x/src/e1000_main.c:414:		if(!adapter->vlgrp->vlan_devices[vid]) {
drivers/e1000-6.x/src/e1000_main.c:424:					!adapter->vlgrp->vlan_devices[old_vid])
drivers/e1000-6.x/src/e1000_main.c:2773:		if(IPPROTO_UDP == ip->protocol) {
drivers/e1000-6.x/src/e1000_main.c:2775:			if(ntohs(udp->dest) == 67) {
drivers/e1000-6.x/src/e1000_main.c:2788:			if(IPPROTO_UDP == ip->protocol) {
drivers/e1000-6.x/src/e1000_main.c:2791:						(ip->ihl << 2));
drivers/e1000-6.x/src/e1000_main.c:2792:				if(ntohs(udp->dest) == 67) {
drivers/e1000-6.x/src/e1000_main.c:4355:		adapter->vlgrp->vlan_devices[vid] = NULL;
drivers/e1000-6.x/src/e1000_main.c:4378:			if(!adapter->vlgrp->vlan_devices[vid])
drivers/e1000-6.x/src/e1000_hw.c:2755:        /* Set up Op-code, Phy Address, and register address in the MDI
drivers/e1000-6.x/src/e1000_hw.c:2861:        /* Set up Op-code, Phy Address, register address, and data intended
drivers/e1000-7.x/src/Makefile:129:  CFLAGS += -ffixed-8 -mno-fp-regs
drivers/e1000-7.x/src/e1000_main.c:450:		if (!adapter->vlgrp->vlan_devices[vid]) {
drivers/e1000-7.x/src/e1000_main.c:460:					!adapter->vlgrp->vlan_devices[old_vid])
drivers/e1000-7.x/src/e1000_main.c:1609:			  adapter->vlgrp->vlan_devices[adapter->mng_vlan_id])) {
drivers/e1000-7.x/src/e1000_main.c:3372:			if (IPPROTO_UDP == ip->protocol) {
drivers/e1000-7.x/src/e1000_main.c:3375:						(ip->ihl << 2));
drivers/e1000-7.x/src/e1000_main.c:3376:				if (ntohs(udp->dest) == 67) {
drivers/e1000-7.x/src/e1000_main.c:5181:		adapter->vlgrp->vlan_devices[vid] = NULL;
drivers/e1000-7.x/src/e1000_main.c:5208:			if (!adapter->vlgrp->vlan_devices[vid])
drivers/e1000-7.x/src/e1000_hw.c:3537:        /* Set up Op-code, Phy Address, and register address in the MDI
drivers/e1000-7.x/src/e1000_hw.c:3675:        /* Set up Op-code, Phy Address, register address, and data intended
drivers/e1000-5.x/src/Makefile:121:  CFLAGS += -ffixed-8 -mno-fp-regs
drivers/e1000-5.x/src/e1000_main.c:3099:		adapter->vlgrp->vlan_devices[vid] = NULL;
drivers/e1000-5.x/src/e1000_main.c:3118:			if(!adapter->vlgrp->vlan_devices[vid])
drivers/e1000-5.x/src/e1000_hw.c:2531:        /* Set up Op-code, Phy Address, and register address in the MDI
drivers/e1000-5.x/src/e1000_hw.c:2637:        /* Set up Op-code, Phy Address, register address, and data intended
elements/radio/b8b10.cc:117:    int qbits = p->length() * 10;
elements/radio/b8b10.cc:123:    for(pi = 0; pi < (int)p->length(); pi++){
elements/radio/b8b10.cc:124:      int x10 = x8to10[p->data()[pi] & 0xff];
elements/radio/b8b10.cc:133:    p->kill();
elements/radio/b8b10.cc:138:    int pbits = p->length() * 8;
elements/radio/b8b10.cc:145:      int x10 = ((p->data()[pi] << pj) & 0xff) << 2;
elements/radio/b8b10.cc:146:      x10 |= (p->data()[pi+1] & 0xff) >> (6-pj);
elements/radio/b8b10.cc:155:    p->kill();
elements/radio/checkpattern.cc:46:  if(p->length() != _len)
elements/radio/checkpattern.cc:47:    click_chatter("CheckPattern: p->length() %d _len %d",
elements/radio/checkpattern.cc:48:                p->length(), _len);
elements/radio/checkpattern.cc:50:  for(i = 0; i < _len && i < p->length(); i++){
elements/radio/checkpattern.cc:51:    if((p->data()[i]&0xff) != (i&0xff)){
elements/radio/checkpattern.cc:53:                  i, p->data()[i] & 0xff, i & 0xff);
elements/radio/sendpattern.cc:48:    p->data()[i] = i & 0xff;
elements/radio/bim.cc:181:  send_packet(p->data(), p->length());
elements/radio/bim.cc:182:  p->kill();
elements/radio/scramble.cc:54:  len = p->length();
elements/radio/scramble.cc:57:    p->data()[i] ^= pattern[j];
elements/userlevel/fromdump.cc:170:    outp->magic = SWAPLONG(hp->magic);
elements/userlevel/fromdump.cc:171:    outp->version_major = SWAPSHORT(hp->version_major);
elements/userlevel/fromdump.cc:172:    outp->version_minor = SWAPSHORT(hp->version_minor);
elements/userlevel/fromdump.cc:173:    outp->thiszone = SWAPLONG(hp->thiszone);
elements/userlevel/fromdump.cc:174:    outp->sigfigs = SWAPLONG(hp->sigfigs);
elements/userlevel/fromdump.cc:175:    outp->snaplen = SWAPLONG(hp->snaplen);
elements/userlevel/fromdump.cc:176:    outp->linktype = SWAPLONG(hp->linktype);
elements/userlevel/fromdump.cc:182:    outp->ts.tv.tv_sec = SWAPLONG(hp->ts.tv.tv_sec);
elements/userlevel/fromdump.cc:183:    outp->ts.tv.tv_usec = SWAPLONG(hp->ts.tv.tv_usec);
elements/userlevel/fromdump.cc:184:    outp->caplen = SWAPLONG(hp->caplen);
elements/userlevel/fromdump.cc:185:    outp->len = SWAPLONG(hp->len);
elements/userlevel/fromdump.cc:403:    p->set_mac_header(p->data());
elements/userlevel/todump.cc:3: * todump.{cc,hh} -- element writes packets to tcpdump-like file
elements/userlevel/todump.cc:202:    const Timestamp& ts = p->timestamp_anno();
elements/userlevel/todump.cc:212:    unsigned to_write = p->length();
elements/userlevel/todump.cc:220:	|| fwrite(p->data(), 1, to_write, _fp) == 0) {
elements/userlevel/todump.cc:254:	p->kill();
elements/userlevel/fakepcap.cc:3: * fakepcap.{cc,hh} -- a faked-up pcap-like interface
elements/userlevel/fakepcap.cc:124:    const uint8_t *data = p->data();
elements/userlevel/fakepcap.cc:125:    const uint8_t *end_data = p->end_data();
elements/userlevel/fakepcap.cc:305:	int header_off = header_ptr - reinterpret_cast<uintptr_t>(p->data());
elements/userlevel/fakepcap.cc:306:	if (Packet *q = p->shift_data(-(header_ptr & 3), false)) {
elements/userlevel/fakepcap.cc:309:	    end_data = p->end_data();
elements/userlevel/fakepcap.cc:318:	    p->set_ip_header(iph, iph->ip_hl << 2);
elements/userlevel/fakepcap.cc:319:	    p->set_dst_ip_anno(iph->ip_dst);
elements/userlevel/fakepcap.cc:324:	    p->set_ip6_header(reinterpret_cast<const click_ip6*>(iph));
elements/userlevel/fromdump.hh:27:FromDump also transparently reads gzip- and bzip2-compressed tcpdump files, if
elements/userlevel/kerneltun.cc:463:    int cc = read(_fd, p->data(), _mtu_in);
elements/userlevel/kerneltun.cc:465:	p->take(_mtu_in - cc);
elements/userlevel/kerneltun.cc:471:		p->pull(4);
elements/userlevel/kerneltun.cc:474:		p->pull(2);
elements/userlevel/kerneltun.cc:478:	    uint16_t etype = *(uint16_t *)(p->data() + 2);
elements/userlevel/kerneltun.cc:479:	    p->pull(4);
elements/userlevel/kerneltun.cc:481:		checked_output_push(1, p->clone());
elements/userlevel/kerneltun.cc:486:	    int af = ntohl(*(unsigned *)p->data());
elements/userlevel/kerneltun.cc:487:	    p->pull(4);
elements/userlevel/kerneltun.cc:490:		checked_output_push(1, p->clone());
elements/userlevel/kerneltun.cc:497:	    uint16_t etype = *(uint16_t *)(p->data() + 14);
elements/userlevel/kerneltun.cc:498:	    p->pull(16);
elements/userlevel/kerneltun.cc:500:		checked_output_push(1, p->clone());
elements/userlevel/kerneltun.cc:506:	    p->timestamp_anno().set_now();
elements/userlevel/kerneltun.cc:539:	if (p->length() < sizeof(click_ether)) {
elements/userlevel/kerneltun.cc:544:	check_length = p->length() - sizeof(click_ether);
elements/userlevel/kerneltun.cc:547:	iph = p->ip_header();
elements/userlevel/kerneltun.cc:549:	if (!p->has_network_header()
elements/userlevel/kerneltun.cc:550:	    || p->network_length() < (int) sizeof(click_ip)) {
elements/userlevel/kerneltun.cc:553:	    p->kill();
elements/userlevel/kerneltun.cc:560:	p->change_headroom_and_length(p->headroom() + p->network_header_offset(), p->network_length());
elements/userlevel/kerneltun.cc:561:	check_length = p->length();
elements/userlevel/kerneltun.cc:574:	    uint16_t ethertype = ((const click_ether *) p->data())->ether_type;
elements/userlevel/kerneltun.cc:575:	    if ((q = p->push(4)))
elements/userlevel/kerneltun.cc:580:	    p = p->push(2);
elements/userlevel/kerneltun.cc:587:	if ((q = p->push(4)))
elements/userlevel/kerneltun.cc:592:	if ((q = p->push(4)))
elements/userlevel/kerneltun.cc:597:	if ((q = p->push(16))) {
elements/userlevel/kerneltun.cc:611:	int w = write(_fd, p->data(), p->length());
elements/userlevel/kerneltun.cc:612:	if (w != (int) p->length() && (errno != ENOBUFS || !_ignore_q_errs || !_printed_write_err)) {
elements/userlevel/kerneltun.cc:616:	p->kill();
elements/userlevel/todevice.cc:185:	retval = ((uint32_t) write(_fd, p->data(), p->length()) == p->length() ? 0 : -1);
elements/userlevel/todevice.cc:188:	retval = send(_fd, p->data(), p->length(), 0);
elements/userlevel/fromhost.cc:101:    /* we want an ethertap-like interface */
elements/userlevel/fromhost.cc:202:    int cc = read(_fd, p->data(), _mtu_in);
elements/userlevel/fromhost.cc:204:	p->take(_mtu_in - cc);
elements/userlevel/fromhost.cc:206:	p->pull(4);
elements/userlevel/fromhost.cc:207:	p->set_mac_header(p->data());
elements/userlevel/fromhost.cc:208:	const click_ip *ip = reinterpret_cast<const click_ip *>(p->data() + sizeof(click_ether));
elements/userlevel/fromhost.cc:209:	p->set_dst_ip_anno(IPAddress(ip->ip_dst));
elements/userlevel/fromhost.cc:210:	p->set_ip_header(ip, ip->ip_hl << 2);
elements/userlevel/fromhost.cc:211:	p->timestamp_anno().set_now();
elements/userlevel/fromhost.cc:214:	p->kill();
elements/userlevel/fromfile.cc:490:	    p->shrink_data(_buffer + _pos, size);
elements/userlevel/fromfile.cc:491:	    p->timestamp_anno().assign(sec, subsec);
elements/userlevel/fromfile.cc:497:	    if (read(p->data(), size, errh) < (int)size) {
elements/userlevel/fromfile.cc:498:		p->kill();
elements/userlevel/fromfile.cc:501:		p->timestamp_anno().assign(sec, subsec);
elements/userlevel/fromfile.cc:516:	    p->shrink_data(data, size);
elements/userlevel/fromfile.cc:517:	    p->timestamp_anno().assign(sec, subsec);
elements/userlevel/fromfile.cc:522:	    memcpy(p->data(), data, data_size);
elements/userlevel/fromfile.cc:524:		&& read(p->data() + data_size, size - data_size, errh) != (int)(size - data_size)) {
elements/userlevel/fromfile.cc:525:		p->kill();
elements/userlevel/fromfile.cc:528:	    p->timestamp_anno().assign(sec, subsec);
elements/userlevel/tohost.cc:80:    if (p->length() < sizeof(click_ether)) {
elements/userlevel/tohost.cc:82:	p->kill();
elements/userlevel/tohost.cc:87:    WritablePacket *q = p->push(4);
elements/userlevel/tohost.cc:89:	click_ether *e = (click_ether *) (p->data() + 4);
elements/userlevel/socket.cc:434:  while (p->length()) {
elements/userlevel/socket.cc:438:      _remote.in.sin_addr = p->dst_ip_anno();
elements/userlevel/socket.cc:443:      len = write(_active, p->data(), p->length());
elements/userlevel/socket.cc:445:      len = sendto(_active, p->data(), p->length(), 0,
elements/userlevel/socket.cc:467:      p->pull(len);
elements/userlevel/socket.cc:470:  p->kill();
elements/userlevel/socket.cc:498:      p->kill();
elements/userlevel/socket.cc:501:    p->kill();
elements/userlevel/khandlerproxy.cc:158:    if (khp->check_handler_name(str, errh) < 0)
elements/userlevel/khandlerproxy.cc:160:    khp->set_handler(str, Handler::OP_READ | Handler::OP_WRITE, handler_hook);
elements/userlevel/khandlerproxy.cc:193:    String fn = khp->handler_name_to_file_name(hname);
elements/userlevel/khandlerproxy.cc:200:	    if (khp->_verbose)
elements/userlevel/khandlerproxy.cc:201:		khp->complain_about_open(ErrorHandler::default_handler(), hname, err);
elements/userlevel/khandlerproxy.cc:203:	    khp->complain_about_open(0, hname, err);
elements/userlevel/khandlerproxy.cc:210:	    return khp->complain_about_open(errh, hname, errno);
elements/userlevel/khandlerproxy.cc:218:		return khp->complain(errh, hname, CSERR_UNSPECIFIED, fn + ": " + String(strerror(errno)));
elements/userlevel/khandlerproxy.cc:225:	    khp->complain(errh, hname, CSERR_HANDLER_ERROR, "Error executing kernel write handler '" + String(hname) + "'");
elements/userlevel/khandlerproxy.cc:226:	    if (!khp->_detailed_error_message) {
elements/userlevel/khandlerproxy.cc:227:		khp->complain(errh, hname, CSERR_HANDLER_ERROR, "(Check /click/errors for details.)");
elements/userlevel/khandlerproxy.cc:228:		khp->_detailed_error_message = true;
elements/userlevel/ipflowrawsockets.cc:49:      _flowid(p), _ip_p(p->ip_header()->ip_p),
elements/userlevel/ipflowrawsockets.cc:163:    while (p->length()) {
elements/userlevel/ipflowrawsockets.cc:164:	w = sendto(_wd, p->data(), p->length(), 0, (const struct sockaddr*)&sin, sizeof(sin));
elements/userlevel/ipflowrawsockets.cc:167:	p->pull(w);
elements/userlevel/ipflowrawsockets.cc:172:    p->kill();
elements/userlevel/ipflowrawsockets.cc:302:    memcpy(p->data(), data, length);
elements/userlevel/ipflowrawsockets.cc:303:    p = p->put(length);
elements/userlevel/ipflowrawsockets.cc:307:    p->timestamp_anno().assign(pkthdr->ts.tv_sec, pkthdr->ts.tv_usec);
elements/userlevel/ipflowrawsockets.cc:328:    p->take(p->length());
elements/userlevel/ipflowrawsockets.cc:332:	if (p->length() && fake_pcap_force_ip(p, f->datalink())) {
elements/userlevel/ipflowrawsockets.cc:334:	    p->pull((uintptr_t)p->ip_header() - (uintptr_t)p->data());
elements/userlevel/ipflowrawsockets.cc:337:	    p->kill();
elements/userlevel/ipflowrawsockets.cc:340:	len = read(fd, p->end_data(), p->tailroom());
elements/userlevel/ipflowrawsockets.cc:343:	    p = p->put(len);
elements/userlevel/ipflowrawsockets.cc:349:	    p->timestamp_anno().set_timeval_ioctl(fd, SIOCGSTAMP);
elements/userlevel/ipflowrawsockets.cc:353:		switch (p->ip_header()->ip_p) {
elements/userlevel/ipflowrawsockets.cc:356:		    //	      p->tcp_header()->th_dport);
elements/userlevel/ipflowrawsockets.cc:357:		    if (f->sport() != p->tcp_header()->th_dport)
elements/userlevel/ipflowrawsockets.cc:362:		    //      p->udp_header()->uh_dport);
elements/userlevel/ipflowrawsockets.cc:363:		    if (f->sport() != p->udp_header()->uh_dport)
elements/userlevel/ipflowrawsockets.cc:375:	p->kill();
elements/userlevel/fromdevice.cc:260:	// linux pcap-0.4-16) want to have a filter installed before they
elements/userlevel/fromdevice.cc:343:    if (p->data()[0] & 1) {
elements/userlevel/fromdevice.cc:344:	if (memcmp(bcast_addr, p->data(), 6) == 0)
elements/userlevel/fromdevice.cc:345:	    p->set_packet_type_anno(Packet::BROADCAST);
elements/userlevel/fromdevice.cc:347:	    p->set_packet_type_anno(Packet::MULTICAST);
elements/userlevel/fromdevice.cc:351:    p->set_timestamp_anno(Timestamp::make_usec(pkthdr->ts.tv_sec, pkthdr->ts.tv_usec));
elements/userlevel/fromdevice.cc:352:    p->set_mac_header(p->data());
elements/userlevel/fromdevice.cc:382:	int len = recvfrom(_linux_fd, p->data(), p->length(), MSG_TRUNC, (sockaddr *)&sa, &fromlen);
elements/userlevel/fromdevice.cc:385:		assert(p->length() == (uint32_t)_snaplen);
elements/userlevel/fromdevice.cc:388:		p->take(_snaplen - len);
elements/userlevel/fromdevice.cc:389:	    p->set_packet_type_anno((Packet::PacketType)sa.sll_pkttype);
elements/userlevel/fromdevice.cc:390:	    p->timestamp_anno().set_timeval_ioctl(_linux_fd, SIOCGSTAMP);
elements/userlevel/fromdevice.cc:391:	    p->set_mac_header(p->data());
elements/userlevel/fromdevice.cc:397:	    p->kill();
elements/userlevel/rawsocket.cc:218:      if ((int)p->length() < (int)sizeof(click_ip)) {
elements/userlevel/rawsocket.cc:219:	errh->error("runt IP packet (%d bytes)", p->length());
elements/userlevel/rawsocket.cc:220:	p->kill();
elements/userlevel/rawsocket.cc:222:	const click_ip *ip = (const click_ip *) p->data();
elements/userlevel/rawsocket.cc:228:	sin.sin_addr = ip->ip_dst;
elements/userlevel/rawsocket.cc:230:	while (p->length()) {
elements/userlevel/rawsocket.cc:232:	  len = sendto(_fd, p->data(), p->length(), 0,
elements/userlevel/rawsocket.cc:252:	    p->pull(len);
elements/userlevel/rawsocket.cc:256:	p->kill();
elements/userlevel/printold.cc:58:  if (p->timestamp_anno().sec() == 0) {
elements/userlevel/printold.cc:64:  if (bytes < 0 || (int) p->length() < bytes)
elements/userlevel/printold.cc:65:      bytes = p->length();
elements/userlevel/printold.cc:74:  long age_s = tv_now.sec() - p->timestamp_anno().sec();
elements/userlevel/printold.cc:75:  long age_u = tv_now.usec() - p->timestamp_anno().usec();
elements/userlevel/printold.cc:84:		  name().c_str(), age_ms, &p->timestamp_anno(), age_s, age_u);
elements/userlevel/printold.cc:90:  pcap_tv.tv_sec = (long) p->user_anno_i(0);
elements/userlevel/printold.cc:91:  pcap_tv.tv_usec = (long) p->user_anno_i(1);
elements/userlevel/printold.cc:96:    long age2_s = p->timestamp_anno().tv_sec - pcap_tv.tv_sec;
elements/userlevel/printold.cc:97:    long age2_u = p->timestamp_anno().tv_usec - pcap_tv.tv_usec;
elements/userlevel/printold.cc:116:  sprintf(sa.reserve(9), "(%5ld msecs) %4d | %n", age_ms, p->length(), &len);
elements/userlevel/printold.cc:122:    sprintf(buf + pos, "%02x", p->data()[i] & 0xff);
elements/bsdmodule/fastudpsrc.hh:121:    udp->uh_sum = 0;
elements/bsdmodule/fastudpsrc.hh:130:        udp->uh_sum = ~csum & 0xFFFF;
elements/bsdmodule/fastudpsrc.hh:132:        udp->uh_sum = 0;
elements/bsdmodule/todevice.cc:139:	struct mbuf *m = p->steal_m();
elements/bsdmodule/tohost.cc:95:    struct mbuf *m = p->steal_m();
elements/bsdmodule/tohost.cc:117:    (*ifp->if_input)(ifp, m);
elements/bsdmodule/fastudpsrc.cc:84:    udp->uh_sport = htons(_sport+_incr);
elements/bsdmodule/fastudpsrc.cc:85:    udp->uh_dport = htons(_dport+_incr);
elements/bsdmodule/fastudpsrc.cc:115:    ip->ip_v = 4;
elements/bsdmodule/fastudpsrc.cc:116:    ip->ip_hl = sizeof(click_ip) >> 2;
elements/bsdmodule/fastudpsrc.cc:117:    ip->ip_len = htons(_len-14);
elements/bsdmodule/fastudpsrc.cc:118:    ip->ip_id = 0;
elements/bsdmodule/fastudpsrc.cc:119:    ip->ip_p = IP_PROTO_UDP;
elements/bsdmodule/fastudpsrc.cc:120:    ip->ip_src = _sipaddr;
elements/bsdmodule/fastudpsrc.cc:121:    ip->ip_dst = _dipaddr;
elements/bsdmodule/fastudpsrc.cc:122:    ip->ip_tos = 0;
elements/bsdmodule/fastudpsrc.cc:123:    ip->ip_off = 0;
elements/bsdmodule/fastudpsrc.cc:124:    ip->ip_ttl = 250;
elements/bsdmodule/fastudpsrc.cc:125:    ip->ip_sum = 0;
elements/bsdmodule/fastudpsrc.cc:126:    ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/bsdmodule/fastudpsrc.cc:129:    udp->uh_sport = htons(_sport);
elements/bsdmodule/fastudpsrc.cc:130:    udp->uh_dport = htons(_dport);
elements/bsdmodule/fromdevice.cc:81:    if (ifp->if_spare2 == NULL)	// not for click.
elements/bsdmodule/fromdevice.cc:92:    FromDevice *me = (FromDevice *)(ifp->if_spare2);
elements/bsdmodule/fromdevice.cc:99:    if (!me->_polling && (ifp->if_ipending & IFF_POLLING) &&
elements/bsdmodule/fromdevice.cc:105:	    if (prp->ifp == ifp) {
elements/bsdmodule/fromdevice.cc:106:		me->_poll_handler = prp->handler;
elements/bsdmodule/fromdevice.cc:108:		prp->handler = NULL;
elements/bsdmodule/fromdevice.cc:109:		prp->ifp = NULL;
elements/bsdmodule/fromdevice.cc:110:		printf("Click FromDevice(%s) taking control over NIC driver polling\n", ifp->if_xname);
elements/bsdmodule/fromdevice.cc:116:			ifp->if_xname);
elements/bsdmodule/fromdevice.cc:155:    if (ifp->if_spare3 == NULL) { // not for click...
elements/bsdmodule/fromdevice.cc:162:    FromHost *me = (FromHost *)(ifp->if_spare3);
elements/bsdmodule/fromdevice.cc:330:	    if (prp->ifp == NULL)
elements/bsdmodule/fromdevice.cc:332:	prp->handler = _poll_handler;
elements/bsdmodule/fromdevice.cc:333:	prp->ifp = _dev;
elements/bsdmodule/fromdevice.cc:386:		    if (prp->ifp == NULL)
elements/bsdmodule/fromdevice.cc:388:		prp->handler = _poll_handler;
elements/bsdmodule/fromdevice.cc:389:		prp->ifp = _dev;
elements/app/ftpportmapper.cc:101:  const click_ip *iph = p->ip_header();
elements/app/ftpportmapper.cc:103:  const click_tcp *tcph = p->tcp_header();
elements/app/ftpportmapper.cc:104:  unsigned data_offset = p->transport_header_offset() + (tcph->th_off<<2);
elements/app/ftpportmapper.cc:105:  const unsigned char *data = p->data() + data_offset;
elements/app/ftpportmapper.cc:106:  unsigned len = p->length() - data_offset;
elements/app/ftpportmapper.cc:176:    wp = p->put(buflen - port_arg_len);
elements/app/ftpportmapper.cc:178:    wp = p->uniqueify();
elements/app/ftpportmapper.cc:179:    wp->take(port_arg_len - buflen);
elements/app/ftpportmapper.cc:181:  memmove(wp->data() + data_offset + port_arg_offset + buflen,
elements/app/ftpportmapper.cc:182:	  wp->data() + data_offset + port_arg_offset + port_arg_len,
elements/app/ftpportmapper.cc:184:  memcpy(wp->data() + data_offset + port_arg_offset,
elements/app/ftpportmapper.cc:190:  click_ip *wp_iph = wp->ip_header();
elements/app/ftpportmapper.cc:192:  wp_iph->ip_len = htons(wp->length() - wp->ip_header_offset());
elements/app/ftpportmapper.cc:202:  click_tcp *wp_tcph = wp->tcp_header();
elements/app/ftpportmapper.cc:213:  unsigned wp_tcp_len = wp->length() - wp->transport_header_offset();
elements/ipsec/des.cc:78:  unsigned char *idat = p->data();
elements/ipsec/des.cc:79:  struct esp_new *esp = (struct esp_new *)p->data();
elements/ipsec/des.cc:82:  unsigned char *ivp = esp->esp_iv;
elements/ipsec/des.cc:83:  int i, plen = p->length() - sizeof(esp_new) - _ignore;
elements/ipsec/des.cc:84:  idat = p->data() + sizeof(esp_new);
elements/ipsec/des.cc:90:     if(sa_data==NULL) {click_chatter("DES: No SADataTuple annotation. Check man page\n"); p->kill(); return 0;}
elements/ipsec/ipsecroutetable.cc:202:    const click_ip *ip = reinterpret_cast< const click_ip *>(p->data());
elements/ipsec/ipsecroutetable.cc:204:    int port = lookup_route(p->dst_ip_anno(), gw, spi, sa_data);
elements/ipsec/ipsecroutetable.cc:212:	       click_chatter("No Ipsec tunnel for %s. Wrong tunnel setup", p->dst_ip_anno().unparse().c_str());
elements/ipsec/ipsecroutetable.cc:222:	    if(ip->ip_p != 50) {
elements/ipsec/ipsecroutetable.cc:230:            struct esp_new * esp =(struct esp_new *)(p->data()+sizeof(click_ip));
elements/ipsec/ipsecroutetable.cc:231:            sa_data = _sa_table.lookup(SPI(ntohl(esp->esp_spi)));
elements/ipsec/ipsecroutetable.cc:233:		click_chatter("Invalid SPI %d, Dropping packet",ntohl(esp->esp_spi));
elements/ipsec/ipsecroutetable.cc:234:	p->kill();
elements/ipsec/ipsecroutetable.cc:243:	    p->set_dst_ip_anno(gw);
elements/ipsec/ipsecroutetable.cc:248:	    click_chatter("IPsecRouteTable: no route for %s", p->dst_ip_anno().unparse().c_str());
elements/ipsec/ipsecroutetable.cc:249:	p->kill();
elements/ipsec/sha1.cc:67:    SHA1_update (&ctx, (u_char*) p->data(), p->length());
elements/ipsec/sha1.cc:69:    WritablePacket *q = p->put(12);
elements/ipsec/sha1.cc:76:    const u_char *ah = p->data()+p->length()-12;
elements/ipsec/sha1.cc:80:    SHA1_update (&ctx, (u_char*) p->data(), p->length()-12);
elements/ipsec/sha1.cc:89:	p->kill();
elements/ipsec/sha1.cc:92:    p->take(12);
elements/ipsec/hmacsha1.cc:74:    HMAC(sa_data->Authentication_key,KEY_SIZE,(u_char*) p->data(),p->length(),digest,&len);
elements/ipsec/hmacsha1.cc:75:    WritablePacket *q = p->put(12);
elements/ipsec/hmacsha1.cc:81:    const u_char *ah = p->data()+p->length()-12;
elements/ipsec/hmacsha1.cc:84:    HMAC(sa_data->Authentication_key,KEY_SIZE,(u_char*) p->data(),p->length()-12,digest,&len);
elements/ipsec/hmacsha1.cc:92:	p->kill();
elements/ipsec/hmacsha1.cc:96:    p->take(12);
elements/ipsec/desp.cc:87:  struct esp_new *esp = (struct esp_new *) p->data();
elements/ipsec/desp.cc:93:  if(!checkreplaywindow(sa,(unsigned long)ntohl(esp->esp_rpl))) {
elements/ipsec/desp.cc:94:      p->kill(); //The packet failed replay check and it is therefore dropped
elements/ipsec/desp.cc:99:  p->pull(sizeof(esp_new));
elements/ipsec/desp.cc:101:  blks = p->length();
elements/ipsec/desp.cc:102:  blk = p->data();
elements/ipsec/desp.cc:106:    p->kill();
elements/ipsec/desp.cc:110:  blk = p->data() + p->length() - (blks + 2);
elements/ipsec/desp.cc:115:    p->kill();
elements/ipsec/desp.cc:119:  p->take(blks+2);
elements/ipsec/esp.cc:60:  if (p->has_network_header())
elements/ipsec/esp.cc:61:      ip_p = p->ip_header()->ip_p;
elements/ipsec/esp.cc:65:  int plen = p->length();
elements/ipsec/esp.cc:68:  WritablePacket *q = p->push(sizeof(esp_new));
elements/ipsec/esp.cc:76:  esp->esp_spi = htonl((uint32_t)IPSEC_SPI_ANNO(p));
elements/ipsec/esp.cc:77:  esp->esp_rpl = htonl(sa_data->cur_rpl);
elements/ipsec/esp.cc:84:  memmove(&esp->esp_iv[0], &i, 4);
elements/ipsec/esp.cc:86:  memmove(&esp->esp_iv[4], &i, 4);
elements/ipsec/aes.cc:77:  struct esp_new *esp = (struct esp_new *)p->data();
elements/ipsec/aes.cc:80:  unsigned char *ivp = esp->esp_iv;
elements/ipsec/aes.cc:81:  unsigned char * idat = p->data() + sizeof(esp_new);
elements/ipsec/aes.cc:82:  int plen = p->length() - sizeof(esp_new) - _ignore;
elements/ipsec/aes.cc:98:        p->kill();
elements/ipsec/aes.cc:106:        p->kill();
elements/ipsec/ipsecencap.cc:129:  click_ip *ip = reinterpret_cast<click_ip *>(p->data());
elements/ipsec/ipsecencap.cc:134:  _iph.ip_dst = p->dst_ip_anno();
elements/ipsec/ipsecencap.cc:139: ip->ip_len = htons(p->length());
elements/ipsec/ipsecencap.cc:140: ip->ip_id = htons(_id.fetch_and_add(1));
elements/ipsec/ipsecencap.cc:144:    ip->ip_sum = ip_fast_csum((unsigned char *)ip, sizeof(click_ip) >> 2);
elements/ipsec/ipsecencap.cc:146:    ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/ipsec/ipsecencap.cc:148:  ip->ip_sum = ip_fast_csum((unsigned char *)ip, sizeof(click_ip) >> 2);
elements/ipsec/ipsecencap.cc:150:  ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/ipsec/ipsecencap.cc:153:  p->set_dst_ip_anno(IPAddress(ip->ip_dst));
elements/ipsec/ipsecencap.cc:154:  p->set_ip_header(ip, sizeof(click_ip));
elements/analysis/aggregatelen.cc:36:	p->kill();
elements/analysis/aggregatelen.cc:44:    if (_ip && !p->has_network_header())
elements/analysis/aggregatelen.cc:47:	offset = p->network_header_offset();
elements/analysis/aggregatelen.cc:51:    uint32_t len = p->length() - offset + EXTRA_LENGTH_ANNO(p);
elements/analysis/fromnlanrdump.cc:282:    if (p->network_header_length() != sizeof(click_ip)) { // there were ip options
elements/analysis/fromflandump.hh:25:FromFlanDump also transparently reads gzip- and bzip2-compressed files, if you
elements/analysis/aggregateipflows.cc:41:    const click_ip *iph = p->ip_header();
elements/analysis/aggregateipflows.cc:43:	return reinterpret_cast<const click_ip *>(p->icmp_header() + 1); // know it exists
elements/analysis/aggregateipflows.cc:216:	    hpinfo->_fragment_head = p->next();
elements/analysis/aggregateipflows.cc:217:	    p->kill();
elements/analysis/aggregateipflows.cc:231:    sinfo->_first_timestamp = p->timestamp_anno();
elements/analysis/aggregateipflows.cc:242:    finfo->_last_timestamp = p->timestamp_anno();
elements/analysis/aggregateipflows.cc:249:	&& p->transport_length() >= 14
elements/analysis/aggregateipflows.cc:251:	if (p->tcp_header()->th_flags & TH_RST)
elements/analysis/aggregateipflows.cc:253:	else if (p->tcp_header()->th_flags & TH_FIN)
elements/analysis/aggregateipflows.cc:255:	else if (p->tcp_header()->th_flags & TH_SYN)
elements/analysis/aggregateipflows.cc:319:    const click_icmp *icmph = p->icmp_header();
elements/analysis/aggregateipflows.cc:320:    if (p->has_transport_header()
elements/analysis/aggregateipflows.cc:328:	if ((unsigned)p->transport_length() >= sizeof(click_icmp) + embedded_hlen
elements/analysis/aggregateipflows.cc:356:	    int age = p->timestamp_anno().sec() - finfo->_last_timestamp.sec();
elements/analysis/aggregateipflows.cc:362:		    && p->ip_header()->ip_p == IP_PROTO_TCP
elements/analysis/aggregateipflows.cc:363:		    && (p->tcp_header()->th_flags & TH_SYN))) {
elements/analysis/aggregateipflows.cc:417:	for (Packet *p = hpinfo->_fragment_head; p; p = p->next())
elements/analysis/aggregateipflows.cc:423:	for (Packet *p = hpinfo->_fragment_head; p; p = p->next())
elements/analysis/aggregateipflows.cc:458:    p->set_next(0);
elements/analysis/aggregateipflows.cc:459:    _active_sec = p->timestamp_anno().sec();
elements/analysis/aggregateipflows.cc:475:    const click_ip *iph = p->ip_header();
elements/analysis/aggregateipflows.cc:479:    if (!p->timestamp_anno()) {
elements/analysis/aggregateipflows.cc:484:	p->timestamp_anno().set_now();
elements/analysis/aggregateipflows.cc:488:    if (p->has_network_header() && iph->ip_p == IP_PROTO_ICMP
elements/analysis/aggregateipflows.cc:495:    if (!p->has_network_header()
elements/analysis/aggregateipflows.cc:511:	if (udp_ptr + 4 > p->end_data())
elements/analysis/aggregateipflows.cc:547:    _active_sec = p->timestamp_anno().sec();
elements/analysis/aggregateipaddrpair.cc:121:    if (p->has_network_header()) {
elements/analysis/aggregateipaddrpair.cc:122:	const click_ip *iph = p->ip_header();
elements/analysis/aggregateipaddrpair.cc:128:	    if (!p->timestamp_anno()) {
elements/analysis/aggregateipaddrpair.cc:133:		p->timestamp_anno().set_now();
elements/analysis/aggregateipaddrpair.cc:136:	    if (finfo->aggregate && SEC_OLDER(finfo->last_timestamp.sec(), p->timestamp_anno().sec() - _timeout)) {
elements/analysis/aggregateipaddrpair.cc:151:	    finfo->last_timestamp = p->timestamp_anno();
elements/analysis/aggregateipaddrpair.cc:152:	    _active_sec = p->timestamp_anno().sec();
elements/analysis/fromtcpdump.cc:578:	    p->kill();
elements/analysis/fromtcpdump.cc:607:	    p->kill();
elements/analysis/timefilter.cc:128:    const Timestamp& tv = p->timestamp_anno();
elements/analysis/aggregatelast.cc:131:	    SET_FIRST_TIMESTAMP_ANNO(p, p->timestamp_anno());
elements/analysis/aggpktcounter.cc:191:	    f->add(p->anno_u32(_anno), port);
elements/analysis/ipsumdump_ip.cc:41:    int network_length = d.p->network_length();
elements/analysis/ipsumdump_ip.cc:99:	    d.v = d.p->length();
elements/analysis/ipsumdump_ip.cc:108:	  uint32_t allow_len = (d.iph ? network_length : d.p->length());
elements/analysis/ipsumdump_ip.cc:131:    click_ip *iph = d.p->ip_header();
elements/analysis/ipsumdump_ip.cc:164:	if (d.p->network_length() < ip_hl) {
elements/analysis/ipsumdump_ip.cc:165:	    if (!(d.p = d.p->put(ip_hl - d.p->network_length())))
elements/analysis/ipsumdump_ip.cc:167:	    iph = d.p->ip_header();
elements/analysis/ipsumdump_ip.cc:170:	    d.p->set_ip_header(iph, ip_hl);
elements/analysis/ipsumdump_ip.cc:173:	memcpy(d.p->network_header() + sizeof(click_ip), d.vptr[0], olen);
elements/analysis/ipsumdump_ip.cc:174:	memset(d.p->network_header() + sizeof(click_ip) + olen,
elements/analysis/ipsumdump_ip.cc:180:	uint32_t allow_len = (iph ? network_length : d.p->length());
elements/analysis/ipsumdump_ip.cc:190:	    if (!(d.p = d.p->put(more)))
elements/analysis/ipsumdump_ip.cc:192:	    iph = d.p->ip_header();
elements/analysis/ipsumdump_ip.cc:193:	    d.p->set_ip_header(iph, d.v);
elements/analysis/ipsumdump_ip.cc:194:	    memset(d.p->transport_header() - more, IPOPT_EOL, more);
elements/analysis/ipsumdump_ip.cc:199:	d.want_len = d.p->network_header_offset() + d.v;
elements/analysis/ipsumdump_ip.cc:337:	    && p->network_length() > (int)(d.iph->ip_hl << 2)
elements/analysis/ipsumdump_ip.cc:340:	    && p->transport_length() >= (dport ? 4 : 2)) {
elements/analysis/ipsumdump_ip.cc:341:	    const click_udp *udph = p->udp_header();
elements/analysis/ipsumdump_ip.cc:355:    click_ip *iph = d.p->ip_header();
elements/analysis/ipsumdump_ip.cc:362:	d.p->udp_header()->uh_sport = htons(d.v);
elements/analysis/ipsumdump_ip.cc:365:	d.p->udp_header()->uh_dport = htons(d.v);
elements/analysis/fromipsumdump.cc:507:	    d.p->kill();
elements/analysis/fromipsumdump.cc:516:    if (d.p && d.is_ip && d.p->ip_header())
elements/analysis/fromipsumdump.cc:519:    if (d.p && d.is_ip && d.p->ip_header()) {
elements/analysis/fromipsumdump.cc:522:	if (!d.p->ip_header()->ip_len) {
elements/analysis/fromipsumdump.cc:524:	    if (ip_len >= (uint32_t) d.p->network_header_offset())
elements/analysis/fromipsumdump.cc:525:		ip_len -= d.p->network_header_offset();
elements/analysis/fromipsumdump.cc:529:		ip_len = d.p->network_length();
elements/analysis/fromipsumdump.cc:530:	    d.p->ip_header()->ip_len = htons(ip_len);
elements/analysis/fromipsumdump.cc:532:	    ip_len = ntohs(d.p->ip_header()->ip_len);
elements/analysis/fromipsumdump.cc:535:	if (d.p->ip_header()->ip_p == IP_PROTO_UDP
elements/analysis/fromipsumdump.cc:536:	    && IP_FIRSTFRAG(d.p->ip_header())
elements/analysis/fromipsumdump.cc:537:	    && !d.p->udp_header()->uh_ulen) {
elements/analysis/fromipsumdump.cc:538:	    int len = ip_len - d.p->network_header_length();
elements/analysis/fromipsumdump.cc:539:	    d.p->udp_header()->uh_ulen = htons(len);
elements/analysis/fromipsumdump.cc:543:	d.p->set_dst_ip_anno(d.p->ip_header()->ip_dst);
elements/analysis/fromipsumdump.cc:548:	    if (ip_len > (uint32_t) d.p->network_length())
elements/analysis/fromipsumdump.cc:549:		xlen = ip_len - d.p->network_length();
elements/analysis/fromipsumdump.cc:550:	    if (!xlen || (d.p = d.p->put(xlen))) {
elements/analysis/fromipsumdump.cc:552:		    memset(d.p->end_data() - xlen, 0, xlen);
elements/analysis/fromipsumdump.cc:554:		set_checksums(d.p, d.p->ip_header());
elements/analysis/fromipsumdump.cc:560:    if (d.p && d.want_len > d.p->length())
elements/analysis/fromipsumdump.cc:561:	SET_EXTRA_LENGTH_ANNO(d.p, d.want_len - d.p->length());
elements/analysis/fromipsumdump.cc:569:    uint32_t length = p->length() + extra_length;
elements/analysis/fromipsumdump.cc:570:    if (htons(length) != p->ip_header()->ip_len) {
elements/analysis/fromipsumdump.cc:571:	if (WritablePacket *q = p->uniqueify()) {
elements/analysis/fromipsumdump.cc:573:	    ip->ip_len = htons(length);
elements/analysis/fromipsumdump.cc:574:	    if (ip->ip_p == IP_PROTO_UDP)
elements/analysis/fromipsumdump.cc:575:		q->udp_header()->uh_ulen = htons(length - (ip->ip_hl << 2));
elements/analysis/fromipsumdump.cc:599:	_multipacket_length = (p->length() + EXTRA_LENGTH_ANNO(p)) / count;
elements/analysis/fromipsumdump.cc:601:	if (_multipacket_length < p->length()) {
elements/analysis/fromipsumdump.cc:602:	    _multipacket_length = p->length();
elements/analysis/fromipsumdump.cc:606:	_multipacket_end_timestamp = p->timestamp_anno();
elements/analysis/fromipsumdump.cc:608:	    _multipacket_timestamp_delta = (p->timestamp_anno() - FIRST_TIMESTAMP_ANNO(p)) / (count - 1);
elements/analysis/fromipsumdump.cc:609:	    p->timestamp_anno() = FIRST_TIMESTAMP_ANNO(p);
elements/analysis/fromipsumdump.cc:613:	_work_packet = set_packet_lengths(p, _multipacket_length - p->length());
elements/analysis/fromipsumdump.cc:619:    if ((p = p->clone())) {
elements/analysis/fromipsumdump.cc:621:	SET_EXTRA_LENGTH_ANNO(p, _multipacket_length - p->length());
elements/analysis/fromipsumdump.cc:652:	_timing_offset = Timestamp::now() - p->timestamp_anno();
elements/analysis/fromipsumdump.cc:656:    Timestamp t = p->timestamp_anno() + _timing_offset;
elements/analysis/fromipsumdump.cc:698:	    p->kill();
elements/analysis/fromipsumdump.cc:731:	    p->kill();
elements/analysis/fromflandump.cc:346:	p->shrink_packet(_pos - sizeof(DAGCell) + DAGCell::PAYLOAD_OFFSET, sizeof(DAGCell) - DAGCell::PAYLOAD_OFFSET);
elements/analysis/fromflandump.cc:347:	p->set_timestamp_anno(tv);
elements/analysis/fromflandump.cc:355:	memcpy(wp->data(), &cell->payload, sizeof(cell->payload));
elements/analysis/fromflandump.cc:356:	wp->set_timestamp_anno(tv);
elements/analysis/toipflowdumps.cc:47:      _flowid(p), _ip_p(p->ip_header()->ip_p),
elements/analysis/toipflowdumps.cc:54:	const click_icmp *icmph = p->icmp_header();
elements/analysis/toipflowdumps.cc:70:	_first_timestamp = p->timestamp_anno() - Timestamp::epsilon();
elements/analysis/toipflowdumps.cc:432:	assert(p->ip_header()->ip_p == IP_PROTO_ICMP);
elements/analysis/toipflowdumps.cc:434:	sa << p->timestamp_anno() << ' ' << (PAINT_ANNO(p) & 1 ? '>' : '<') << " ICMP_error";
elements/analysis/toipflowdumps.cc:446:    const click_ip *iph = p->ip_header();
elements/analysis/toipflowdumps.cc:449:    _pkt[_npkt].timestamp = p->timestamp_anno() - _first_timestamp;
elements/analysis/toipflowdumps.cc:456:	const click_tcp *tcph = p->tcp_header();
elements/analysis/toipflowdumps.cc:832:	p->kill();
elements/analysis/fromdagdump.hh:25:FromDAGDump also transparently reads gzip- and bzip2-compressed files, if you
elements/analysis/storetimestamp.cc:52:    int offset = (_offset < 0 ? p->length() : _offset);
elements/analysis/storetimestamp.cc:53:    int delta = offset + 8 - p->length();
elements/analysis/storetimestamp.cc:54:    if (WritablePacket *q = p->put(delta < 0 ? 0 : delta)) {
elements/analysis/aggregateip.cc:82:	p->kill();
elements/analysis/aggregateip.cc:89:    if (!p->has_network_header())
elements/analysis/aggregateip.cc:92:    const click_ip *iph = p->ip_header();
elements/analysis/aggregateip.cc:93:    int offset = p->length();
elements/analysis/aggregateip.cc:96:	offset = p->network_header_offset();
elements/analysis/aggregateip.cc:100:	    offset = p->transport_header_offset();
elements/analysis/aggregateip.cc:104:	    offset = p->transport_header_offset();
elements/analysis/aggregateip.cc:109:	else if (iph->ip_p == IPPROTO_TCP && p->transport_header_offset() + sizeof(click_tcp) <= p->length()) {
elements/analysis/aggregateip.cc:110:	    const click_tcp *tcph = (const click_tcp *)p->transport_header();
elements/analysis/aggregateip.cc:111:	    offset = p->transport_header_offset() + (tcph->th_off << 2);
elements/analysis/aggregateip.cc:113:	    offset = p->transport_header_offset() + sizeof(click_udp);
elements/analysis/aggregateip.cc:117:	    offset = p->transport_header_offset();
elements/analysis/aggregateip.cc:122:    if (offset + 4 > (int)p->length())
elements/analysis/aggregateip.cc:125:    uint32_t udata = *((const uint32_t *)(p->data() + offset));
elements/analysis/aggregateip.cc:158:	return NameInfo::revquery_int(NameInfo::T_IP_PROTO, e, aip->_f.proto());
elements/analysis/aggregateip.cc:160:	return String(aip->_f.bit_offset());
elements/analysis/aggregateip.cc:162:	return String(aip->_f.bit_length());
elements/analysis/aggregateip.cc:164:	return aip->_f.unparse(e, false);
elements/analysis/toipsumdump.cc:220:	uint32_t total_len = p->length(), len = p->length();
elements/analysis/toipsumdump.cc:227:	Timestamp end_timestamp = p->timestamp_anno();
elements/analysis/toipsumdump.cc:231:	    p->set_timestamp_anno(FIRST_TIMESTAMP_ANNO(p));
elements/analysis/toipsumdump.cc:242:		p->timestamp_anno() = end_timestamp;
elements/analysis/toipsumdump.cc:244:		p->timestamp_anno() += timestamp_delta;
elements/analysis/toipsumdump.cc:266:    p->kill();
elements/analysis/toipsumdump.cc:276:	p->kill();
elements/analysis/ipsumdump_link.cc:36:    if (!d.p->has_mac_header()) {
elements/analysis/ipsumdump_link.cc:37:	if (!d.p->has_network_header() || d.p->data() < d.p->network_header())
elements/analysis/ipsumdump_link.cc:38:	    mac = d.p->data();
elements/analysis/ipsumdump_link.cc:42:	mac = d.p->mac_header();
elements/analysis/ipsumdump_link.cc:45:    if (!d.p->has_network_header())
elements/analysis/ipsumdump_link.cc:46:	network = d.p->end_data();
elements/analysis/ipsumdump_link.cc:48:	network = d.p->network_header();
elements/analysis/ipsumdump_link.cc:75:    if (!d.p->mac_header() && !(d.p = d.p->push_mac_header(14)))
elements/analysis/ipsumdump_link.cc:79:	memcpy(d.p->ether_header()->ether_shost, d.u8, 6);
elements/analysis/ipsumdump_link.cc:82:	memcpy(d.p->ether_header()->ether_dhost, d.u8, 6);
elements/analysis/ipsumdump_link.cc:85:	d.p->ether_header()->ether_type = htons(d.v);
elements/analysis/ipsumdumpinfo.cc:192:	else if (d.p->network_length() > (int) offsetof(click_ip, ip_p)
elements/analysis/ipsumdumpinfo.cc:202:	else if ((int) (d.p->transport_length() + EXTRA_LENGTH_ANNO(d.p)) >= l)
elements/analysis/ipsumdumpinfo.cc:350:    d.iph = (p->has_network_header() ? p->ip_header() : 0);
elements/analysis/ipsumdumpinfo.cc:351:    d.tcph = (p->has_transport_header() ? p->tcp_header() : 0);
elements/analysis/ipsumdumpinfo.cc:352:    d.udph = (p->has_transport_header() ? p->udp_header() : 0);
elements/analysis/ipsumdumpinfo.cc:353:    d.icmph = (p->has_transport_header() ? p->icmp_header() : 0);
elements/analysis/ipsumdumpinfo.cc:360:    else if (p->network_length() < (int) offsetof(click_ip, ip_id))
elements/analysis/ipsumdumpinfo.cc:371:	if (p->network_length() > ip_len) {
elements/analysis/ipsumdumpinfo.cc:372:	    SET_EXTRA_LENGTH_ANNO(p, EXTRA_LENGTH_ANNO(p) + p->network_length() - ip_len);
elements/analysis/ipsumdumpinfo.cc:373:	    p->take(p->network_length() - ip_len);
elements/analysis/ipsumdumpinfo.cc:374:	} else if (d.careful_trunc && p->network_length() + EXTRA_LENGTH_ANNO(p) < (uint32_t) ip_len) {
elements/analysis/ipsumdumpinfo.cc:377:	    BAD2("truncated IP missing ", (ntohs(d.iph->ip_len) - p->network_length() - EXTRA_LENGTH_ANNO(p)), scratch);
elements/analysis/ipsumdumpinfo.cc:383:	|| p->network_length() <= (int)(d.iph->ip_hl << 2)
elements/analysis/ipsumdumpinfo.cc:387:    else if (p->transport_length() > 12
elements/analysis/ipsumdumpinfo.cc:393:	|| p->network_length() <= (int)(d.iph->ip_hl << 2)
elements/analysis/ipsumdumpinfo.cc:400:	|| p->network_length() <= (int)(d.iph->ip_hl << 2)
elements/analysis/ipsumdumpinfo.cc:409:	uint32_t full_len = p->length() + EXTRA_LENGTH_ANNO(p);
elements/analysis/ipsumdumpinfo.cc:410:	uint32_t ip_len = p->network_header_offset() + ntohs(d.iph->ip_len);
elements/analysis/ipsumdumpinfo.cc:420:    if (!p->has_network_header())
elements/analysis/ipsumdumpinfo.cc:421:	p->set_network_header(p->data(), 0);
elements/analysis/ipsumdumpinfo.cc:422:    if (p->network_length() < (int) sizeof(click_ip)) {
elements/analysis/ipsumdumpinfo.cc:423:	if (!(p = p->put(sizeof(click_ip) - p->network_length())))
elements/analysis/ipsumdumpinfo.cc:425:	p->set_network_header(p->network_header(), sizeof(click_ip));
elements/analysis/ipsumdumpinfo.cc:426:	click_ip *iph = p->ip_header();
elements/analysis/ipsumdumpinfo.cc:443:    click_ip *iph = p->ip_header();
elements/analysis/ipsumdumpinfo.cc:464:	    && want_len < (uint32_t) p->transport_header_offset() + len)
elements/analysis/ipsumdumpinfo.cc:465:	    len = want_len - p->transport_header_offset();
elements/analysis/ipsumdumpinfo.cc:467:	if (p->transport_length() < len) {
elements/analysis/ipsumdumpinfo.cc:469:	    if (!(p = p->put(xlen - p->transport_length())))
elements/analysis/ipsumdumpinfo.cc:471:	    if (p->ip_header()->ip_p == IP_PROTO_TCP && len >= 13)
elements/analysis/ipsumdumpinfo.cc:472:		p->tcp_header()->th_off = sizeof(click_tcp) >> 2;
elements/analysis/ipsumdumpinfo.cc:474:		click_udp *udph = p->udp_header();
elements/analysis/ipsumdumpinfo.cc:479:		p->take(xlen - len);
elements/analysis/fromnetflowsumdump.cc:252:    uint32_t length = p->length() + extra_length;
elements/analysis/fromnetflowsumdump.cc:253:    if (htons(length) != p->ip_header()->ip_len) {
elements/analysis/fromnetflowsumdump.cc:254:	if (WritablePacket *q = p->uniqueify()) {
elements/analysis/fromnetflowsumdump.cc:256:	    ip->ip_len = htons(length);
elements/analysis/fromnetflowsumdump.cc:257:	    if (ip->ip_p == IP_PROTO_UDP)
elements/analysis/fromnetflowsumdump.cc:258:		q->udp_header()->uh_ulen = htons(length - (ip->ip_hl << 2));
elements/analysis/fromnetflowsumdump.cc:282:	_multipacket_length = (p->length() + EXTRA_LENGTH_ANNO(p)) / count;
elements/analysis/fromnetflowsumdump.cc:284:	if (_multipacket_length < p->length()) {
elements/analysis/fromnetflowsumdump.cc:285:	    _multipacket_length = p->length();
elements/analysis/fromnetflowsumdump.cc:289:	_multipacket_end_timestamp = p->timestamp_anno();
elements/analysis/fromnetflowsumdump.cc:291:	    _multipacket_timestamp_delta = (p->timestamp_anno() - FIRST_TIMESTAMP_ANNO(p)) / (count - 1);
elements/analysis/fromnetflowsumdump.cc:292:	    p->timestamp_anno() = FIRST_TIMESTAMP_ANNO(p);
elements/analysis/fromnetflowsumdump.cc:296:	_work_packet = set_packet_lengths(p, _multipacket_length - p->length());
elements/analysis/fromnetflowsumdump.cc:302:    if ((p = p->clone())) {
elements/analysis/fromnetflowsumdump.cc:304:	SET_EXTRA_LENGTH_ANNO(p, _multipacket_length - p->length());
elements/analysis/settimestampdelta.cc:57:    Timestamp& tv = p->timestamp_anno();
elements/analysis/ipsumdump_anno.cc:38:	d.u32[0] = p->timestamp_anno().sec();
elements/analysis/ipsumdump_anno.cc:39:	d.u32[1] = p->timestamp_anno().nsec();
elements/analysis/ipsumdump_anno.cc:42:	d.v = p->timestamp_anno().sec();
elements/analysis/ipsumdump_anno.cc:45:	d.v = p->timestamp_anno().usec();
elements/analysis/ipsumdump_anno.cc:49:	  uint64_t v3 = ((uint64_t)p->timestamp_anno().sec() * 1000000) + p->timestamp_anno().usec();
elements/analysis/ipsumdump_anno.cc:55:	  d.u32[1] = (p->timestamp_anno().sec() * 1000000) + p->timestamp_anno().usec();
elements/analysis/ipsumdump_anno.cc:84:	p->set_timestamp_anno(Timestamp::make_nsec(d.u32[0], d.u32[1]));
elements/analysis/ipsumdump_anno.cc:87:	p->timestamp_anno().set_sec(d.v);
elements/analysis/ipsumdump_anno.cc:90:	p->timestamp_anno().set_subsec(Timestamp::usec_to_subsec(d.v));
elements/analysis/ipsumdump_anno.cc:95:	p->set_timestamp_anno(Timestamp::make_usec(v3 / 1000000, v3 % 1000000));
elements/analysis/ipsumdump_anno.cc:99:	p->set_timestamp_anno(Timestamp::make_usec(d.u32[0] / 1000000, d.u32[0] % 1000000));
elements/analysis/ipsumdump_udp.cc:39:    int transport_length = d.p->transport_length();
elements/analysis/ipsumdump_udp.cc:60:    int ip_p = d.p->ip_header()->ip_p;
elements/analysis/ipsumdump_udp.cc:63:    if (d.p->transport_length() < (int) sizeof(click_udp)
elements/analysis/ipsumdump_udp.cc:64:	&& !(d.p = d.p->put(sizeof(click_udp) - d.p->transport_length())))
elements/analysis/ipsumdump_udp.cc:69:	d.p->udp_header()->uh_ulen = htons(d.v);
elements/analysis/fromnlanrdump.hh:26:FromNLANRDump also transparently reads gzip- and bzip2-compressed files, if
elements/analysis/aggcounter.cc:232:	amount = p->length() + (_use_extra_length ? EXTRA_LENGTH_ANNO(p) : 0);
elements/analysis/aggcounter.cc:233:	if (_ip_bytes && p->has_network_header())
elements/analysis/aggcounter.cc:234:	    amount -= p->network_header_offset();
elements/analysis/timestampaccum.cc:43:    _usec_accum += (Timestamp::now() - p->timestamp_anno()).doubleval();
elements/analysis/ipsumdump_icmp.cc:44:    int transport_length = d.p->transport_length();
elements/analysis/ipsumdump_icmp.cc:99:    if (d.p->transport_length() < (int) sizeof(click_icmp)
elements/analysis/ipsumdump_icmp.cc:100:	&& !(d.p = d.p->put(sizeof(click_icmp) - d.p->transport_length())))
elements/analysis/ipsumdump_icmp.cc:103:    click_icmp *icmph = d.p->icmp_header();
elements/analysis/ipsumdump_icmp.cc:110:	if (d.p->transport_length() < len
elements/analysis/ipsumdump_icmp.cc:111:	    && !(d.p = d.p->put(len - d.p->transport_length())))
elements/analysis/ipsumdump_icmp.cc:124:	    if (d.p->transport_length() < (int) sizeof(click_icmp_sequenced)) {
elements/analysis/ipsumdump_icmp.cc:125:		if (!(d.p = d.p->put(sizeof(click_icmp_sequenced) - d.p->transport_length())))
elements/analysis/ipsumdump_icmp.cc:127:		icmph = d.p->icmp_header();
elements/analysis/ipsumdump_icmp.cc:136:	    if (d.p->transport_length() < (int) sizeof(click_icmp_sequenced)) {
elements/analysis/ipsumdump_icmp.cc:137:		if (!(d.p = d.p->put(sizeof(click_icmp_sequenced) - d.p->transport_length())))
elements/analysis/ipsumdump_icmp.cc:139:		icmph = d.p->icmp_header();
elements/analysis/ipsumdump_icmp.cc:147:	    if (d.p->transport_length() < (int) sizeof(click_icmp_needfrag)) {
elements/analysis/ipsumdump_icmp.cc:148:		if (!(d.p = d.p->put(sizeof(click_icmp_needfrag) - d.p->transport_length())))
elements/analysis/ipsumdump_icmp.cc:150:		icmph = d.p->icmp_header();
elements/analysis/ipsumdump_icmp.cc:188:	    if (NameInfo::query_int(NameInfo::T_ICMP_CODE + d.p->icmp_header()->icmp_type, d.e, str, &d.v)
elements/analysis/ipsumdump_payload.cc:42:	off = p->transport_header_offset();
elements/analysis/ipsumdump_payload.cc:43:	uint32_t nlen = len + p->network_header_offset();
elements/analysis/ipsumdump_payload.cc:47:		if (p->transport_length() >= 13
elements/analysis/ipsumdump_payload.cc:48:		    && ((uint32_t) off + (p->tcp_header()->th_off << 2) <= nlen
elements/analysis/ipsumdump_payload.cc:50:		    off += (p->tcp_header()->th_off << 2);
elements/analysis/ipsumdump_payload.cc:58:	len -= off - p->network_header_offset();
elements/analysis/ipsumdump_payload.cc:61:	len = p->length();
elements/analysis/ipsumdump_payload.cc:86:    if (!d.is_ip || (d.p->ip_header()->ip_len == 0 && d.want_len == 0))
elements/analysis/ipsumdump_payload.cc:89:	click_ip *iph = d.p->ip_header();
elements/analysis/ipsumdump_payload.cc:91:	    + d.p->network_header_offset();
elements/analysis/ipsumdump_payload.cc:95:	    click_tcp *tcph = d.p->tcp_header();
elements/analysis/ipsumdump_payload.cc:102:		if (!(d.p = d.p->put(th_delta)))
elements/analysis/ipsumdump_payload.cc:104:		iph = d.p->ip_header(); // may have shifted
elements/analysis/ipsumdump_payload.cc:105:		unsigned char *tx = d.p->transport_header() + sizeof(click_tcp);
elements/analysis/ipsumdump_payload.cc:106:		memmove(tx + th_delta, tx, d.p->end_data() - (tx + th_delta));
elements/analysis/ipsumdump_payload.cc:108:		d.p->tcp_header()->th_off = (sizeof(click_tcp) + th_delta) >> 2;
elements/analysis/ipsumdump_payload.cc:116:		if (!(d.p = d.p->put(ip_delta)))
elements/analysis/ipsumdump_payload.cc:118:		iph = d.p->ip_header(); // may have shifted
elements/analysis/ipsumdump_payload.cc:119:		unsigned char *nx = d.p->network_header() + sizeof(click_ip);
elements/analysis/ipsumdump_payload.cc:120:		memmove(nx + ip_delta, nx, d.p->end_data() - (nx + ip_delta));
elements/analysis/ipsumdump_payload.cc:123:		d.p->set_ip_header(iph, sizeof(click_ip) + ip_delta);
elements/analysis/ipsumdump_payload.cc:138:    payload_info(d.p, d.is_ip ? d.p->ip_header() : 0, off, len);
elements/analysis/ipsumdump_payload.cc:145:	if (!d.p || (d.p->length() - off < plen
elements/analysis/ipsumdump_payload.cc:146:		     && !(d.p = d.p->put(plen - (d.p->length() - off)))))
elements/analysis/ipsumdump_payload.cc:148:	memcpy(d.p->data() + off, d.vptr[0], plen);
elements/analysis/ipsumdump_payload.cc:166:	if (off + len > (uint32_t) d.p->length())
elements/analysis/ipsumdump_payload.cc:167:	    len = d.p->length() - off;
elements/analysis/ipsumdump_payload.cc:169:	    String s = String::make_stable((const char *)(d.p->data() + off), len);
elements/analysis/ipsumdump_payload.cc:174:	    md5_append(&pms, (const md5_byte_t *) (d.p->data() + off), len);
elements/analysis/ipsumdump_payload.cc:224:	if (off + len > (uint32_t) d.p->length())
elements/analysis/ipsumdump_payload.cc:225:	    len = d.p->length() - off;
elements/analysis/ipsumdump_payload.cc:228:	md5_append(&pms, (const md5_byte_t *) (d.p->data() + off), len);
elements/analysis/anonipaddr.cc:279:    const click_ip *in_iph = p->ip_header();
elements/analysis/anonipaddr.cc:280:    if (!p->has_network_header() || in_iph->ip_v != 4) {
elements/analysis/anonipaddr.cc:283:    } else if (WritablePacket *q = p->uniqueify()) {
elements/analysis/eraseippayload.cc:40:    click_ip *ip = p->ip_header();
elements/analysis/eraseippayload.cc:41:    if (ip->ip_p == IP_PROTO_TCP) {
elements/analysis/eraseippayload.cc:42:	int off = p->transport_header_offset() + (p->tcp_header()->th_off << 2);
elements/analysis/eraseippayload.cc:43:	if (off < (int) p->length())
elements/analysis/eraseippayload.cc:44:	    memset(p->data() + off, 0, p->length() - off);
elements/analysis/eraseippayload.cc:45:	if (p->transport_header_offset() + 18 <= (int) p->length())
elements/analysis/eraseippayload.cc:46:	    p->tcp_header()->th_sum = 0;
elements/analysis/eraseippayload.cc:47:    } else if (ip->ip_p == IP_PROTO_UDP) {
elements/analysis/eraseippayload.cc:48:	int off = p->transport_header_offset() + sizeof(click_udp);
elements/analysis/eraseippayload.cc:49:	if (off < (int) p->length())
elements/analysis/eraseippayload.cc:50:	    memset(p->data() + off, 0, p->length() - off);
elements/analysis/eraseippayload.cc:51:	if (p->transport_header_offset() + 8 <= (int) p->length())
elements/analysis/eraseippayload.cc:52:	    p->udp_header()->uh_sum = 0;
elements/analysis/eraseippayload.cc:53:    } else if (ip->ip_p == IP_PROTO_ICMP) {
elements/analysis/eraseippayload.cc:56:	p->kill();
elements/analysis/ipsumdump_tcp.cc:40:    int transport_length = d.p->transport_length();
elements/analysis/ipsumdump_tcp.cc:111:    click_tcp *tcph = d.p->tcp_header();
elements/analysis/ipsumdump_tcp.cc:127:	    if (!(d.p = d.p->put(more)))
elements/analysis/ipsumdump_tcp.cc:129:	    tcph = d.p->tcp_header();
elements/analysis/ipsumdump_tcp.cc:130:	    memset(d.p->transport_header() + d.v - more, TCPOPT_EOL, more);
elements/analysis/ipsumdump_tcp.cc:147:	if (d.p->transport_length() < th_off) {
elements/analysis/ipsumdump_tcp.cc:148:	    if (!(d.p = d.p->put(th_off - d.p->transport_length())))
elements/analysis/ipsumdump_tcp.cc:150:	    tcph = d.p->tcp_header();
elements/analysis/ipsumdump_tcp.cc:154:	memcpy(d.p->transport_header() + sizeof(click_tcp), d.vptr[0], olen);
elements/analysis/ipsumdump_tcp.cc:155:	memset(d.p->transport_header() + sizeof(click_tcp) + olen,
elements/analysis/fromcapdump.cc:382:	    p->kill();
elements/analysis/fromcapdump.cc:411:	    p->kill();
elements/analysis/anonipaddr.hh:14:anonymizes top-level IP addresses in passing packets
elements/analysis/anonipaddr.hh:21:p-bit prefix, then the corresponding output addresses also share the same
elements/analysis/anonipaddr.hh:22:p-bit prefix. AnonymizeIPAddr was based on Greg Minshall's tcpdpriv(1); see
elements/analysis/fromdagdump.cc:348:	SET_EXTRA_LENGTH_ANNO(p, wire_length - p->length());
elements/analysis/timerange.cc:48:    const Timestamp& tv = p->timestamp_anno();
elements/analysis/ipsumdumpinfo.hh:208:    if ((!is_ip || !p->has_network_header()
elements/analysis/ipsumdumpinfo.hh:209:	 || p->network_length() < (int) sizeof(click_ip))
elements/analysis/ipsumdumpinfo.hh:212:    return !ip_p || !p->ip_header()->ip_p || p->ip_header()->ip_p == ip_p;
elements/analysis/ipsumdumpinfo.hh:218:    assert(is_ip && p->network_header());
elements/analysis/ipsumdumpinfo.hh:219:    if (!IP_FIRSTFRAG(p->ip_header()))
elements/analysis/ipsumdumpinfo.hh:221:    if (p->transport_length() < 8)
elements/ethernet/arpprint.cc:5: * Shameless graft of ipprint.hh/cc and tcpdump-3.8.3/print-arp.c
elements/ethernet/arpprint.cc:116:    if (!p->has_network_header())
elements/ethernet/arpprint.cc:123:	sa << p->timestamp_anno() << ": ";
elements/ethernet/arpprint.cc:125:    if (p->network_length() < (int) sizeof(click_arp))
elements/ethernet/arpprint.cc:126:	sa << "truncated-arp (" << p->network_length() << ")";
elements/ethernet/arpprint.cc:128:	const click_ether_arp *ap = (const click_ether_arp *) p->network_header();
elements/ethernet/arpprint.cc:129:	uint16_t hrd = ntohs(ap->ea_hdr.ar_hrd);
elements/ethernet/arpprint.cc:130:	uint16_t pro = ntohs(ap->ea_hdr.ar_pro);
elements/ethernet/arpprint.cc:131:	uint8_t hln = ap->ea_hdr.ar_hln;
elements/ethernet/arpprint.cc:132:	uint8_t pln = ap->ea_hdr.ar_pln;
elements/ethernet/arpprint.cc:133:	uint16_t op = ntohs(ap->ea_hdr.ar_op);
elements/ethernet/arpprint.cc:137:	    sa << "arp-#" << op << " for proto #" << pro << " (" << pln << ") "
elements/ethernet/arpprint.cc:141:	const unsigned char *sha = (const unsigned char *)ap->arp_sha;
elements/ethernet/arpprint.cc:142:	const unsigned char *spa = (const unsigned char *)ap->arp_spa;
elements/ethernet/arpprint.cc:143:	const unsigned char *tha = (const unsigned char *)ap->arp_tha;
elements/ethernet/arpprint.cc:144:	const unsigned char *tpa = (const unsigned char *)ap->arp_tpa;
elements/ethernet/arpprint.cc:185:	    sa << "arp-#" << op;
elements/ethernet/ip6ndsolicitor.cc:70:	t->p->kill();
elements/ethernet/ip6ndsolicitor.cc:109:	    e->p->kill();
elements/ethernet/ip6ndsolicitor.cc:192: * May call p->kill().
elements/ethernet/ip6ndsolicitor.cc:210:      Packet *q = p->push(sizeof(click_ether));
elements/ethernet/ip6ndsolicitor.cc:218:        ae->p->kill();
elements/ethernet/ip6ndsolicitor.cc:245:  if (p->length() < sizeof(click_ether) + sizeof(click_ip6) + sizeof(click_nd_sol))
elements/ethernet/ip6ndsolicitor.cc:248:  click_ether *ethh = (click_ether *) p->data();
elements/ethernet/ip6ndsolicitor.cc:285:    p->kill();
elements/ethernet/ip6ndadvertiser.cc:226:   click_ether *e = (click_ether *) p->data();
elements/ethernet/ip6ndadvertiser.cc:241:  if (p->length() >= sizeof(*e) + sizeof(click_ip6) + sizeof(click_nd_sol) &&
elements/ethernet/ip6ndadvertiser.cc:268:  p->kill();
elements/ethernet/arpprint.hh:19:Prints out ARP packets in a human-readable tcpdump-like format, preceded by
elements/ethernet/arpresponder.cc:123:	q->set_device_anno(p->device_anno());
elements/ethernet/arpresponder.cc:166:    click_ether *e = (click_ether *) p->data();
elements/ethernet/arpresponder.cc:173:    if (p->length() >= sizeof(*e) + sizeof(click_ether_arp)
elements/ethernet/arpresponder.cc:185:	p->kill();
elements/ethernet/storeetheraddress.cc:53:    if (_offset + 6 <= p->length()) {
elements/ethernet/storeetheraddress.cc:54:	if (WritablePacket *q = p->uniqueify()) {
elements/ethernet/ethermirror.cc:34:  if (WritablePacket *q = p->uniqueify()) {
elements/ethernet/etherencap.cc:53:  if (WritablePacket *q = p->push_mac_header(14)) {
elements/ethernet/hostetherfilter.cc:58:    p->kill();
elements/ethernet/hostetherfilter.cc:65:  const click_ether *e = (const click_ether *) (p->data() + _offset);
elements/ethernet/hostetherfilter.cc:71:    p->set_packet_type_anno(Packet::HOST);
elements/ethernet/hostetherfilter.cc:74:    p->set_packet_type_anno(Packet::BROADCAST);
elements/ethernet/hostetherfilter.cc:77:    p->set_packet_type_anno(Packet::MULTICAST);
elements/ethernet/hostetherfilter.cc:80:    p->set_packet_type_anno(Packet::OTHERHOST);
elements/ethernet/checkarpheader.cc:85:  const click_arp *ap = reinterpret_cast<const click_arp *>(p->data() + _offset);
elements/ethernet/checkarpheader.cc:86:  unsigned plen = p->length() - _offset;
elements/ethernet/checkarpheader.cc:93:  hlen = (int) sizeof(click_arp) + 2*ap->ar_hln + 2*ap->ar_pln;
elements/ethernet/checkarpheader.cc:96:  else if (ap->ar_hrd == htons(ARPHRD_ETHER) && ap->ar_hln != 6)
elements/ethernet/checkarpheader.cc:98:  else if ((ap->ar_pro == htons(ETHERTYPE_IP) && ap->ar_pln != 4)
elements/ethernet/checkarpheader.cc:99:	   || (ap->ar_pro == htons(ETHERTYPE_IP6) && ap->ar_pln != 16))
elements/ethernet/checkarpheader.cc:102:  p->set_network_header((const unsigned char *) ap, hlen);
elements/ethernet/ensureether.cc:55:  if (!p->has_network_header() || p->ip_header_offset() < 0)
elements/ethernet/ensureether.cc:58:  if (p->ip_header_offset() == 14) {
elements/ethernet/ensureether.cc:60:    const click_ether *ethh = (const click_ether *)p->data();
elements/ethernet/ensureether.cc:64:  } else if (p->ip_header_offset() == 0 && p->headroom() >= 14) {
elements/ethernet/ensureether.cc:66:    const click_ether *ethh = (const click_ether *)(p->data() - 14);
elements/ethernet/ensureether.cc:69:      return p->nonunique_push(14);
elements/ethernet/ensureether.cc:73:  p->pull(p->ip_header_offset());
elements/ethernet/ensureether.cc:74:  if (WritablePacket *q = p->push(14)) {
elements/ethernet/arpquerier.cc:206:    IPAddress want_ip = p->dst_ip_anno();
elements/ethernet/arpquerier.cc:209:    q->set_timestamp_anno(p->timestamp_anno());
elements/ethernet/arpquerier.cc:220: * May call p->kill().
elements/ethernet/arpquerier.cc:227:	p->kill();
elements/ethernet/arpquerier.cc:235:	assert(!p->shared());
elements/ethernet/arpquerier.cc:236:	q = p->uniqueify();
elements/ethernet/arpquerier.cc:237:    } else if (!(q = p->push_mac_header(sizeof(click_ether)))) {
elements/ethernet/arpquerier.cc:298:    if (p->length() < sizeof(click_ether) + sizeof(click_ether_arp))
elements/ethernet/arpquerier.cc:303:    click_ether *ethh = (click_ether *) p->data();
elements/ethernet/arpquerier.cc:331:	p->kill();
elements/ethernet/arptable.cc:75:	    ae->_head = p->next();
elements/ethernet/arptable.cc:76:	    p->kill();
elements/ethernet/arptable.cc:121:	    ae->_head = p->next();
elements/ethernet/arptable.cc:122:	    p->kill();
elements/ethernet/arptable.cc:135:	    if (!(ae->_head = p->next()))
elements/ethernet/arptable.cc:137:	    p->kill();
elements/ethernet/arptable.cc:204:	for (Packet *p = *head; p; p = p->next())
elements/ethernet/arptable.cc:235:    p->set_next(0);
elements/standard/hub.cc:41:	    q = p->clone();
elements/standard/hub.cc:46:	p->kill();
elements/standard/checkcrc32.cc:37:  int len = p->length();
elements/standard/checkcrc32.cc:41:  crc = update_crc(0xffffffff, (char *) p->data(), len - 4);
elements/standard/checkcrc32.cc:44:  memcpy(&pcrc, p->data() + len - 4, 4);
elements/standard/checkcrc32.cc:48:  p->take(4);
elements/standard/checkcrc32.cc:53:              p->length());
elements/standard/checkcrc32.cc:54:  p->kill();
elements/standard/drr.cc:103:	else if (p->length() <= _deficit[_next]) {
elements/standard/drr.cc:104:	    _deficit[_next] -= p->length();
elements/standard/truncate.cc:53:    if (p->length() > nbytes) {
elements/standard/truncate.cc:54:	nbytes = p->length() - nbytes;
elements/standard/truncate.cc:57:        p->take(nbytes);
elements/standard/linkunqueue.cc:81:	_qhead = p->next();
elements/standard/linkunqueue.cc:82:	p->kill();
elements/standard/linkunqueue.cc:89:    uint32_t length = p->length() + EXTRA_LENGTH_ANNO(p);
elements/standard/linkunqueue.cc:91:    p->set_timestamp_anno(tv + Timestamp::make_usec(delay));
elements/standard/linkunqueue.cc:139:	p->set_next(0);
elements/standard/linkunqueue.cc:147:	_qhead = p->next();
elements/standard/linkunqueue.cc:150:	p->set_next(0);
elements/standard/linkunqueue.cc:151:	//click_chatter("%{timestamp}: RELEASE %{timestamp}", &now, &p->timestamp_anno());
elements/standard/strip.cc:45:    p->pull(_nbytes);
elements/standard/bwratedunqueue.cc:38:	    _rate.update_with(p->length());
elements/standard/dropbroadcasts.cc:24:    p->kill();
elements/standard/dropbroadcasts.cc:30:  if (p->packet_type_anno() == Packet::BROADCAST || p->packet_type_anno() == Packet::MULTICAST) {
elements/standard/fullnotequeue.hh:126:    p->kill();
elements/standard/bandwidthshaper.cc:39:	    _rate.update_with(p->length());
elements/standard/painttee.cc:50:    if (p->anno_u8(_anno) == _color)
elements/standard/painttee.cc:51:	output(1).push(p->clone());
elements/standard/counter.cc:90:    _byte_count += p->length();
elements/standard/counter.cc:92:    _byte_rate.update(p->length());
elements/standard/print.cc:99:    if (bytes < 0 || (int) p->length() < bytes)
elements/standard/print.cc:100:	bytes = p->length();
elements/standard/print.cc:127:	sa << sep << p->timestamp_anno();
elements/standard/print.cc:133:    len = sprintf(sa.reserve(11), "%s%4d", sep, p->length());
elements/standard/print.cc:138:	len = sprintf(sa.reserve(16), " (h%d t%d)", p->headroom(), p->tailroom());
elements/standard/print.cc:147:	    sprintf(buf + pos, "%02x", p->anno_u8(j));
elements/standard/print.cc:154:	const unsigned char *data = p->data();
elements/standard/setannobyte.cc:50:    p->set_anno_u8(_offset, _value);
elements/standard/paintswitch.cc:49:    int output_port = static_cast<int>(p->anno_u8(_anno));
elements/standard/paintswitch.cc:55:	    if (Packet *q = p->clone())
elements/standard/delayunqueue.cc:57:	_p->kill();
elements/standard/delayunqueue.cc:68:	if (!_p->timestamp_anno().sec()) // get timestamp if not set
elements/standard/delayunqueue.cc:69:	    _p->timestamp_anno().set_now();
elements/standard/delayunqueue.cc:70:	_p->timestamp_anno() += _delay;
elements/standard/delayunqueue.cc:75:	if (_p->timestamp_anno() <= now) {
elements/standard/delayunqueue.cc:77:	    _p->timestamp_anno() = now;
elements/standard/delayunqueue.cc:84:	Timestamp expiry = _p->timestamp_anno() - Timer::adjustment();
elements/standard/setpackettype.cc:84:    p->set_packet_type_anno(_ptype);
elements/standard/timedsink.cc:55:    p->kill();
elements/standard/ratedsource.cc:105:	p->set_timestamp_anno(now);
elements/standard/ratedsource.cc:132:	p->set_timestamp_anno(now);
elements/standard/frontdropqueue.hh:14:stores packets in drop-from-front FIFO queue
elements/standard/idle.cc:43:  p->kill();
elements/standard/simplequeue.hh:132:	p->kill();
elements/standard/discard.cc:48:    p->kill();
elements/standard/discard.cc:57:      p->kill();
elements/standard/bandwidthmeter.cc:78:  _rate.update(p->length());
elements/standard/delayshaper.cc:68:	_p->kill();
elements/standard/delayshaper.cc:76:	if (!_p->timestamp_anno().sec()) // get timestamp if not set
elements/standard/delayshaper.cc:77:	    _p->timestamp_anno().set_now();
elements/standard/delayshaper.cc:78:	_p->timestamp_anno() += _delay;
elements/standard/delayshaper.cc:83:	if (_p->timestamp_anno() <= now) {
elements/standard/delayshaper.cc:86:	    p->timestamp_anno() = now;
elements/standard/delayshaper.cc:92:	Timestamp expiry = _p->timestamp_anno() - Timer::adjustment();
elements/standard/classifier.cc:1081:  const unsigned char *packet_data = p->data() - _align_offset;
elements/standard/classifier.cc:1082:  int packet_length = p->length() + _align_offset; // XXX >= MAXINT?
elements/standard/classifier.cc:1114:  const unsigned char *packet_data = p->data() - _align_offset;
elements/standard/classifier.cc:1123:  } else if (p->length() < _safe_length) {
elements/standard/infinitesource.cc:113:	p->timestamp_anno().set_now();
elements/standard/infinitesource.cc:140:    p->timestamp_anno().set_now();
elements/standard/unstrip.cc:45:  return p->push(_nbytes);
elements/standard/suppressor.cc:44:	p->kill();
elements/standard/suppressor.cc:63:    return (sup->suppressed(port) ? "false" : "true");
elements/standard/suppressor.cc:75:	sup->set(port, !active);
elements/standard/suppressor.cc:84:    sup->allow_all();
elements/standard/striptonet.cc:36:    int off = p->network_header_offset();
elements/standard/striptonet.cc:38:	p->pull(off);
elements/standard/striptonet.cc:41:	return p->nonunique_push(-off);
elements/standard/hashswitch.cc:50:  const unsigned char *data = p->data();
elements/standard/hashswitch.cc:52:  if ((int)p->length() < o + l)
elements/standard/staticswitch.cc:49:    p->kill();
elements/standard/strideswitch.cc:44:	p->kill();
elements/standard/checklength.cc:43:  if (p->length() > _max)
elements/standard/checklength.cc:53:  if (p && p->length() > _max) {
elements/standard/storedata.cc:44:    if (p->length() <= _offset)
elements/standard/storedata.cc:46:    else if (WritablePacket *q = p->uniqueify()) {
elements/standard/setcrc32.cc:34:  int len = p->length();
elements/standard/setcrc32.cc:36:  crc = update_crc(crc, (char *) p->data(), len);
elements/standard/setcrc32.cc:38:  WritablePacket *q = p->put(4);
elements/standard/pokehandlers.cc:141:    return cp_unparse_bool(p->_paused);
elements/standard/pokehandlers.cc:148:    p->unpause();
elements/standard/tee.cc:50:    if (Packet *q = p->clone())
elements/standard/tee.cc:87:      if (Packet *q = p->clone())
elements/standard/timedsource.cc:83:	p->timestamp_anno().set_now();
elements/standard/msqueue.hh:48:  struct sk_buff *skb = p->skb();
elements/standard/compblock.cc:49:  // int network = *((unsigned char *)&p->ip_header()->ip_src);
elements/standard/align.cc:53:  int delta = _offset - (reinterpret_cast<uintptr_t>(p->data()) & _mask);
elements/standard/align.cc:58:  return p->shift_data(delta);
elements/standard/settimestamp.cc:58:	p->timestamp_anno().set_now();
elements/standard/settimestamp.cc:60:	p->timestamp_anno() = _tv;
elements/standard/settimestamp.cc:66:	p->timestamp_anno() -= FIRST_TIMESTAMP_ANNO(p);
elements/standard/checkpaint.cc:50:    if (p->anno_u8(_anno) != _color)
elements/standard/checkpaint.cc:60:    if (p && p->anno_u8(_anno) != _color) {
elements/standard/averagecounter.cc:70:	_byte_count += p->length();
elements/standard/bwratedsplitter.cc:35:	_rate.update_with(p->length());
elements/standard/paint.cc:51:    p->set_anno_u8(_anno, _color);
elements/standard/randomerror.cc:161:  unsigned char *data = p->data();
elements/standard/randomerror.cc:162:  unsigned len = p->length();
elements/standard/randomsource.cc:65:    char *d = (char *) p->data();
elements/standard/randomsource.cc:71:    p->timestamp_anno().set_now();
elements/grid/filterbyrange.cc:72:  grid_hdr *gh = (grid_hdr *) (p->data() + sizeof(click_ether));
elements/grid/incseqno.cc:36:  if (p->length() < _offset + 4) {
elements/grid/incseqno.cc:38:		  name().c_str(), p->length(), _offset);
elements/grid/incseqno.cc:42:  WritablePacket *wp = p->uniqueify();
elements/grid/incseqno.cc:43:  uint32_t *up = (uint32_t *) (wp->data() + _offset);
elements/grid/dsrroutetable.hh:59: * not specified, minimum hop-count is used.
elements/grid/dsrroutetable.hh:309:      assert(p->has_network_header());
elements/grid/dsrroutetable.hh:310:      const click_ip *ip = p->ip_header();
elements/grid/dsrroutetable.hh:312:      if (ip->ip_p != IP_PROTO_DSR)
elements/grid/dsrroutetable.hh:315:      const click_dsr *dsr = (const click_dsr *)(p->data() + sizeof(click_ip));
elements/grid/dsrroutetable.hh:325:	if (op->dsr_type == DSR_TYPE_RREP) {
elements/grid/dsrroutetable.hh:327:	  op = (const click_dsr_option *)(rrep->next_option());
elements/grid/dsrroutetable.hh:328:	} else if (op->dsr_type == DSR_TYPE_RREQ) {
elements/grid/dsrroutetable.hh:331:	} else if (op->dsr_type == DSR_TYPE_RERR) {
elements/grid/dsrroutetable.hh:334:	} else if (op->dsr_type == DSR_TYPE_SOURCE_ROUTE) {
elements/grid/dsrroutetable.hh:335:	  int offset = (unsigned char *)op - p->data();
elements/grid/hopcountmetric.cc:2: * hopcountmetric.{cc,hh} -- minimum hop-count metric
elements/grid/gridencap.cc:83:  _gh.total_len = htons(p->length() - sizeof(_eh));
elements/grid/gridencap.cc:84:  _nb.dst_ip = p->dst_ip_anno();
elements/grid/gridencap.cc:86:  memcpy(p->data(), &_eh, sizeof(_eh));
elements/grid/gridencap.cc:87:  memcpy(p->data() + sizeof(_eh), &_gh, sizeof(_gh));
elements/grid/gridencap.cc:88:  memcpy(p->data() + sizeof(_eh) + sizeof(_gh), &_nb, sizeof(_nb));
elements/grid/gridtxerror.cc:61:  p->kill();
elements/grid/dsrarptable.cc:157:  const click_ip *ip = (const click_ip *)(p->data() + sizeof(click_ether));
elements/grid/dsrarptable.cc:174:      IPAddress src_addr(ip->ip_src.s_addr);
elements/grid/dsrarptable.cc:195:    if (dsr_rrep->length() == dsr_len) {
elements/grid/dsrarptable.cc:197:      IPAddress src_addr(ip->ip_src.s_addr);
elements/grid/dsrarptable.cc:200:      dsr_option = (click_dsr_option *)(dsr_rrep->next_option());
elements/grid/dsrarptable.cc:224:      IPAddress src_addr(ip->ip_src.s_addr);
elements/grid/dsrarptable.cc:254:      IPAddress src(ip->ip_src.s_addr);
elements/grid/floodinglocquerier.cc:98:	i.value().p->kill();
elements/grid/floodinglocquerier.cc:156: * May call p->kill().  */
elements/grid/floodinglocquerier.cc:160:  click_ether *eh = (click_ether *) p->data();
elements/grid/floodinglocquerier.cc:170:  p->kill();
elements/grid/floodinglocquerier.cc:194:      WritablePacket *q = p->uniqueify();
elements/grid/floodinglocquerier.cc:214:      ae->p->kill();
elements/grid/floodinglocquerier.cc:246:  if (p->length() < sizeof(click_ether) + sizeof(grid_hdr) + sizeof(grid_nbr_encap))
elements/grid/floodinglocquerier.cc:249:  click_ether *ethh = (click_ether *) p->data();
elements/grid/floodinglocquerier.cc:261:    p->kill();
elements/grid/floodinglocquerier.cc:268:    p->kill();
elements/grid/floodinglocquerier.cc:275:    p->kill();
elements/grid/floodinglocquerier.cc:300:  p->kill();
elements/grid/floodinglocquerier.cc:306:  grid_hdr *gh = (grid_hdr *) (p->data() + sizeof(click_ether));
elements/grid/floodinglocquerier.cc:315:    p->kill();
elements/grid/floodinglocquerier.cc:327:      p->kill();
elements/grid/floodinglocquerier.cc:334:    WritablePacket *wp = p->uniqueify();
elements/grid/floodinglocquerier.cc:335:    click_ether *eh = (click_ether *) wp->data();
elements/grid/floodinglocquerier.cc:350:    grid_hdr *gh = (grid_hdr *) (p->data() + sizeof(click_ether));
elements/grid/gridprobereplyreceiver.cc:64:  click_ether *e = (click_ether *) p->data();
elements/grid/gridprobereplyreceiver.cc:72:    p->kill();
elements/grid/gridprobereplyreceiver.cc:80:  struct timeval rtt = p->timestamp_anno().timeval() - tx_time;
elements/grid/gridprobereplyreceiver.cc:97:  p->kill();
elements/grid/hopcountmetric.hh:15: * Child class of GridGenericMetric that implements the minimum hop-count metric.
elements/grid/linktestreceiver.cc:56:  click_ether *eh = (click_ether *) p->data();
elements/grid/linktestreceiver.cc:79:		&p->timestamp_anno(),
elements/grid/simplelocquerier.cc:68:  WritablePacket *wp = p->uniqueify();
elements/grid/simplelocquerier.cc:69:  grid_nbr_encap *nb = (grid_nbr_encap *) (p->data() + sizeof(grid_hdr) + sizeof(click_ether));
elements/grid/simplelocquerier.cc:75:    wp->kill();
elements/grid/linkstat.cc:72:  ASSERT_4ALIGNED(p->data());
elements/grid/linkstat.cc:73:  p->pull(2);
elements/grid/linkstat.cc:74:  memset(p->data(), 0, p->length());
elements/grid/linkstat.cc:76:  p->set_timestamp_anno(Timestamp::now());
elements/grid/linkstat.cc:79:  click_ether *eh = (click_ether *) p->data();
elements/grid/linkstat.cc:97:  unsigned char *d = p->data() + sizeof(click_ether);
elements/grid/linkstat.cc:115:  link_probe::update_cksum(p->data() + sizeof(click_ether));
elements/grid/linkstat.cc:173:  if (p->length() < min_sz) {
elements/grid/linkstat.cc:175:    p->kill();
elements/grid/linkstat.cc:179:  click_ether *eh = (click_ether *) p->data();
elements/grid/linkstat.cc:183:    p->kill();
elements/grid/linkstat.cc:187:  link_probe lp(p->data() + sizeof(click_ether));
elements/grid/linkstat.cc:188:  if (link_probe::calc_cksum(p->data() + sizeof(click_ether)) != 0) {
elements/grid/linkstat.cc:190:    p->kill();
elements/grid/linkstat.cc:194:  if (p->length() < lp.psz)
elements/grid/linkstat.cc:196:		  name().c_str(), p->length(), lp.psz);
elements/grid/linkstat.cc:202:  unsigned int max_entries = (p->length() - sizeof(*eh) - link_probe::size) / link_entry::size;
elements/grid/linkstat.cc:210:  const unsigned char *d = p->data() + sizeof(click_ether) + link_probe::size;
elements/grid/linkstat.cc:219:  p->kill();
elements/grid/gridprobesender.cc:85:  rp->nonce = htonl(nonce);
elements/grid/gridprobesender.cc:86:  rp->send_time.tv_sec = htonl(q->timestamp_anno().sec());
elements/grid/gridprobesender.cc:87:  rp->send_time.tv_usec = htonl(q->timestamp_anno().usec());
elements/grid/fixsrcloc.cc:66:  WritablePacket *p = xp->uniqueify();
elements/grid/fixsrcloc.cc:67:  grid_hdr *gh = (grid_hdr *) (p->data() + sizeof(click_ether));
elements/grid/gridprobehandler.cc:100:  click_ether *e = (click_ether *) p->data();
elements/grid/gridprobehandler.cc:108:    p->kill();
elements/grid/gridprobehandler.cc:141:  rr->nonce = rp->nonce; /* keep in net byte order */
elements/grid/gridprobehandler.cc:142:  rr->probe_send_time = rp->send_time;
elements/grid/gridprobehandler.cc:188:    p->kill();
elements/grid/gridproxy.cc:107:  /* do ip-to-ip encapsulation */
elements/grid/gridproxy.cc:114:  click_ip *ip = reinterpret_cast<click_ip *>(p->data());
elements/grid/gridproxy.cc:116:  ip->ip_len = htons(p->length());
elements/grid/gridproxy.cc:117:  ip->ip_id = htons(_id.fetch_and_add(1));
elements/grid/gridproxy.cc:119:  p->set_dst_ip_anno(nfo->_gw);
elements/grid/gridproxy.cc:120:  p->set_ip_header(ip, sizeof(click_ip));
elements/grid/gridproxy.cc:121:  p->ip_header()->ip_dst = nfo->_gw.in_addr();
elements/grid/gridproxy.cc:126:    ip->ip_sum = ip_fast_csum((unsigned char *)ip, sizeof(click_ip) >> 2);
elements/grid/gridproxy.cc:128:    ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/grid/gridproxy.cc:130:  ip->ip_sum = ip_fast_csum((unsigned char *)ip, sizeof(click_ip) >> 2);
elements/grid/gridproxy.cc:132:  ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/grid/gridproxy.cc:151:  p_in->set_ip_header(ip, ip->ip_hl << 2);
elements/grid/gridroutetable.hh:12: * Implements a DSDV-like loop-free routing protocol by originating
elements/grid/gridroutetable.hh:27: * the lower hop-count entry prevails.  Entry ttls decrease while the
elements/grid/fixdstloc.cc:64:  grid_hdr *gh = (grid_hdr *) (xp->data() + sizeof(click_ether));
elements/grid/fixdstloc.cc:71:  WritablePacket *p = xp->uniqueify();
elements/grid/fixdstloc.cc:72:  grid_nbr_encap *nb = (grid_nbr_encap *) (p->data() + sizeof(click_ether) + sizeof(grid_hdr));
elements/grid/gridlogger.hh:164:    if (ip->ip_p == IP_PROTO_UDP) {
elements/grid/gridlogger.hh:166:      if (udp->uh_dport == htons(8021)) {
elements/grid/gridlogger.hh:334:    struct click_ether *eh = (click_ether *) (p->data());
elements/grid/gridlogger.hh:347:    struct click_ether *eh = (click_ether *) (p->data());
elements/grid/locqueryresponder.cc:68:  for (smi_t i = resp->_query_seqs.begin(); i.live(); i++)
elements/grid/locqueryresponder.cc:69:    if (jiff - i.value().last_jiffies > resp->_timeout_jiffies)
elements/grid/locqueryresponder.cc:73:    resp->_query_seqs.remove(old_seqs[i]);
elements/grid/locqueryresponder.cc:75:  resp->_expire_timer.schedule_after_msec(EXPIRE_TIMEOUT_MS);
elements/grid/locqueryresponder.cc:82:  click_ether *e = (click_ether *) p->data();
elements/grid/locqueryresponder.cc:89:    p->kill();
elements/grid/locqueryresponder.cc:96:    p->kill();
elements/grid/locqueryresponder.cc:107:    p->kill();
elements/grid/locqueryresponder.cc:121:  p->set_timestamp_anno(Timestamp::now());
elements/grid/locqueryresponder.cc:144:  p->kill();
elements/grid/updateroutes.hh:15: * Implements a DSDV-like loop-free routing protocol by originating
elements/grid/updateroutes.hh:26: * hop-count entry prevails.  Entries increase in age while sitting in
elements/grid/regionpep.cc:153:  fp->fix_seq = htonl(fp->fix_seq);
elements/grid/regionpep.cc:154:  fp->fix_hops = htonl(fp->fix_hops);
elements/grid/regionpep.cc:160:  fp->fix_seq = ntohl(fp->fix_seq);
elements/grid/regionpep.cc:161:  fp->fix_hops = ntohl(fp->fix_hops);
elements/grid/regionpep.cc:168:  memset(p->data(), 0, p->length());
elements/grid/regionpep.cc:170:  pep_rgn_proto *pp = (pep_rgn_proto *) p->data();
elements/grid/regionpep.cc:171:  pp->id = _my_ip.addr();
elements/grid/regionpep.cc:175:    pep_rgn_fix *f = pp->fixes + nf;
elements/grid/regionpep.cc:185:    pep_rgn_fix *f = pp->fixes + nf;
elements/grid/regionpep.cc:200:      pp->fixes[nf] = _entries[i]._fix;
elements/grid/regionpep.cc:201:      externalize(&(pp->fixes[nf]));
elements/grid/regionpep.cc:206:  pp->n_fixes = htonl(nf);
elements/grid/regionpep.cc:246:  if(p->length() != sizeof(pep_rgn_proto)) {
elements/grid/regionpep.cc:247:    click_chatter("EstimateRouterRegion: bad size packet (%d bytes)", p->length());
elements/grid/regionpep.cc:251:  pp = (pep_rgn_proto *) p->data();
elements/grid/regionpep.cc:252:  nf = ntohl(pp->n_fixes);
elements/grid/regionpep.cc:253:  if(nf < 0 || (const u_char*)&pp->fixes[nf] > p->data()+p->length()){
elements/grid/regionpep.cc:260:    pep_rgn_fix f = pp->fixes[i];
elements/grid/regionpep.cc:289:  p->kill();
elements/grid/ackretrysender2.cc:52:    p->kill();
elements/grid/ackretrysender2.cc:57:  // IPAddress src(p->data());
elements/grid/ackretrysender2.cc:58:  IPAddress dst(p->data() + 4);
elements/grid/ackretrysender2.cc:63:    p->kill();
elements/grid/ackretrysender2.cc:73:  p->kill();
elements/grid/ackretrysender2.cc:96:  memcpy(p->data(), _ip.data(), 4);
elements/grid/ackretrysender2.cc:97:  memcpy(p->data() + 4, p->dst_ip_anno().data(), 4);
elements/grid/ackretrysender2.cc:100:    _waiting_packet = p->clone();
elements/grid/ackretrysender2.cc:157:    add_stat(p->timestamp_anno(), _num_tries, false);
elements/grid/ackretrysender2.cc:164:    _waiting_packet = p->clone();
elements/grid/packetlogger.cc:79:  int n = p->_p.size() * bytes_per_entry;
elements/grid/packetlogger.cc:83:  // click_chatter("have %d packets; n is %d", p->_p.size(), n);
elements/grid/packetlogger.cc:85:  while (p->_p.size() &&
elements/grid/packetlogger.cc:88:    d = p->_p[0];
elements/grid/packetlogger.cc:89:    p->_p.pop_front();
elements/grid/printgrid.cc:84:  click_ether *eh = (click_ether *) p->data();
elements/grid/printgrid.cc:98:  grid_hdr *gh = (grid_hdr *) (p->data() + sizeof(click_ether));
elements/grid/printgrid.cc:109:      line << p->timestamp_anno() << ' ';
elements/grid/printgrid.cc:179:    line << " nonce=" << ntohl(rp->nonce);
elements/grid/printgrid.cc:193:    line << " seq_no=" << ntohl(lp->seq_no)
elements/grid/printgrid.cc:194:	 << " period=" << ntohl(lp->period)
elements/grid/printgrid.cc:195:	 << " tau=" << ntohl(lp->tau)
elements/grid/printgrid.cc:196:	 << " num_links=" << ntohl(lp->num_links);
elements/grid/printgrid.cc:221:      line << p->timestamp_anno();
elements/grid/printgrid.cc:224:  if (p->length() < min_sz) {
elements/grid/printgrid.cc:231:    click_ether *eh = (click_ether *) p->data();
elements/grid/printgrid.cc:241:  LinkStat::link_probe lp(p->data() + sizeof(click_ether));
elements/grid/printgrid.cc:242:  if (LinkStat::link_probe::calc_cksum(p->data() + sizeof(click_ether)) != 0) {
elements/grid/printgrid.cc:250:  if (p->length() < lp.psz)
elements/grid/printgrid.cc:253:  unsigned int max_entries = (p->length() - sizeof(click_ether) - LinkStat::link_probe::size) / LinkStat::link_entry::size;
elements/grid/printgrid.cc:261:    const unsigned char *d = p->data() + sizeof(click_ether) + LinkStat::link_probe::size;
elements/grid/printgrid.cc:276:  for (unsigned i = 0; i < ntohl(lp->num_links); i++, le++) {
elements/grid/printgrid.cc:285:      unsigned num_expected = ntohl(lp->tau) / ntohl(le->period);
elements/grid/lookupgeogridroute.cc:155:    struct click_ether *eh = (click_ether *) xp->data();
elements/grid/lookupgeogridroute.cc:158:    struct grid_hdr *gh = (grid_hdr *) (xp->data() + sizeof(click_ether));
elements/grid/lookupgeogridroute.cc:172:      xp->pull(ip_off);
elements/grid/lookupgeogridroute.cc:173:      IPAddress src_ip(xp->data() + 12);
elements/grid/lookupgeogridroute.cc:174:      IPAddress dst_ip(xp->data() + 16);
elements/grid/lookupgeogridroute.cc:175:      unsigned short *sp = (unsigned short *) (xp->data() + 20);
elements/grid/lookupgeogridroute.cc:176:      unsigned short *dp = (unsigned short *) (xp->data() + 22);
elements/grid/lookupgeogridroute.cc:251:  grid_hdr *gh = (grid_hdr *) (p->data() + sizeof(click_ether));
elements/grid/lookupgeogridroute.cc:260:    encap = (grid_nbr_encap *) (p->data() + sizeof(click_ether) + gh->hdr_len);
elements/grid/lookupgeogridroute.cc:261:    encap->hops_travelled++;
elements/grid/lookupgeogridroute.cc:264:    gc = (grid_geocast *) (p->data() + sizeof(click_ether) + gh->hdr_len);
elements/grid/lookupgeogridroute.cc:276:  grid_hdr *gh = (grid_hdr *) (p->data() + sizeof(click_ether));
elements/grid/lookupgeogridroute.cc:285:    encap = (grid_nbr_encap *) (p->data() + sizeof(click_ether) + gh->hdr_len);
elements/grid/lookupgeogridroute.cc:286:    return IPAddress(encap->dst_ip) == _ipaddr;
elements/grid/lookupgeogridroute.cc:289:    gc = (grid_geocast *) (p->data() + sizeof(click_ether) + gh->hdr_len);
elements/grid/lookupgeogridroute.cc:303:  grid_hdr *gh = (grid_hdr *) (p->data() + sizeof(click_ether));
elements/grid/lookupgeogridroute.cc:311:    struct grid_nbr_encap *encap = (grid_nbr_encap *) (p->data() + sizeof(click_ether) + gh->hdr_len);
elements/grid/lookupgeogridroute.cc:312:    return encap->dst_loc_good;
elements/grid/lookupgeogridroute.cc:331:  grid_hdr *gh = (grid_hdr *) (p->data() + sizeof(click_ether));
elements/grid/lookupgeogridroute.cc:339:    struct grid_nbr_encap *encap = (grid_nbr_encap *) (p->data() + sizeof(click_ether) + gh->hdr_len);
elements/grid/lookupgeogridroute.cc:340:    return encap->dst_loc;
elements/grid/lookupgeogridroute.cc:347:    struct grid_geocast *gc = (grid_geocast *) (p->data() + sizeof(click_ether) + gh->hdr_len);
elements/grid/lookupgeogridroute.cc:363: * ``lookup-and-modify-packet'' element that lets me plug in the
elements/grid/checkgridheader.cc:48:    p->kill();
elements/grid/checkgridheader.cc:54:  grid_hdr *gh = (grid_hdr *) (p->data() + sizeof(click_ether));
elements/grid/checkgridheader.cc:56:  if(p->length() < sizeof(click_ether) + sizeof(grid_hdr)) {
elements/grid/checkgridheader.cc:74:     p->kill();
elements/grid/checkgridheader.cc:78:  if (tlen + sizeof(click_ether) > p->length()) {
elements/grid/checkgridheader.cc:83:		  tlen + sizeof(click_ether), p->length());
elements/grid/checkgridheader.cc:92:		  name().c_str(), p->length(), (unsigned long) ntohs(gh->cksum));
elements/grid/setgridchecksum.cc:39:  WritablePacket *p = xp->uniqueify();
elements/grid/setgridchecksum.cc:40:  grid_hdr *gh = (grid_hdr *) (p->data() + sizeof(click_ether));
elements/grid/setgridchecksum.cc:41:  unsigned plen = p->length();
elements/grid/setgridchecksum.cc:60:  p->kill();
elements/grid/pingpong.cc:60:  click_ether *eh = (click_ether *) p->data();
elements/grid/radiosim.cc:112:          output(out).push(p->clone());
elements/grid/radiosim.cc:115:      p->kill();
elements/grid/dsdvroutetable.hh:84: * to compare two routes.  If not specified, minimum hop-count is
elements/grid/linktracker.cc:234:  click_ether *eh = (click_ether *) p->data();
elements/grid/gridgatewayinfo.cc:96:    p->set_dst_ip_anno(gw.dest_ip);
elements/grid/gridgatewayinfo.cc:101:    p->kill();
elements/grid/gridsrforwarder.cc:57:  if (p->length() != 124 - 14) {
elements/grid/gridsrforwarder.cc:59:		  p->length());
elements/grid/gridsrforwarder.cc:60:    p->kill();
elements/grid/gridsrforwarder.cc:64:  click_ip *iph = (click_ip *) p->data();
elements/grid/gridsrforwarder.cc:96:    p->kill();
elements/grid/gridsrforwarder.cc:103:    p->kill();
elements/grid/gridsrforwarder.cc:143:    csum += htons(p->length() - sizeof(click_ip));
elements/grid/dsdvroutetable.cc:272:    errh->warning("No metric elements specified, will default to minimum hop-count");
elements/grid/dsdvroutetable.cc:683:  if (_use_seen && next_hop->metric.val() == _metric_seen) {
elements/grid/dsdvroutetable.cc:691:    r.metric = metric_t(r.metric.val() + next_hop->metric.val());
elements/grid/dsdvroutetable.cc:697:    r.metric = _metric->prepend_metric(r.metric, next_hop->metric);
elements/grid/dsdvroutetable.cc:1499:  ASSERT_4ALIGNED(p->data());
elements/grid/dsdvroutetable.cc:1500:  p->pull(2);
elements/grid/dsdvroutetable.cc:1501:  memset(p->data(), 0, p->length());
elements/grid/dsdvroutetable.cc:1504:  p->set_timestamp_anno(Timestamp::now());
elements/grid/dsdvroutetable.cc:1507:  click_ether *eh = (click_ether *) p->data();
elements/grid/dsdvroutetable.cc:1528:    _log->log_sent_advertisement(_seq_no, p->timestamp_anno());
elements/grid/ackresponder2.cc:37:  IPAddress src(p->data());
elements/grid/ackresponder2.cc:38:  IPAddress dst(p->data() + 4);
elements/grid/ackresponder2.cc:42:    memcpy(xp->data(), _ip.data(), 4);
elements/grid/ackresponder2.cc:43:    memcpy(xp->data() + 4, src.data(), 4);
elements/grid/ackresponder2.cc:46:  p->pull(8);
elements/grid/filterbyhops.cc:65:  grid_nbr_encap *nb = (grid_nbr_encap *) (p->data() + sizeof(click_ether) + sizeof(grid_hdr));
elements/grid/pep.cc:155:  fp->fix_seq = htonl(fp->fix_seq);
elements/grid/pep.cc:156:  fp->fix_hops = htonl(fp->fix_hops);
elements/grid/pep.cc:162:  fp->fix_seq = ntohl(fp->fix_seq);
elements/grid/pep.cc:163:  fp->fix_hops = ntohl(fp->fix_hops);
elements/grid/pep.cc:170:  memset(p->data(), 0, p->length());
elements/grid/pep.cc:172:  pep_proto *pp = (pep_proto *) p->data();
elements/grid/pep.cc:173:  pp->id = _my_ip.addr();
elements/grid/pep.cc:177:    pep_fix *f = pp->fixes + nf;
elements/grid/pep.cc:190:      pp->fixes[nf] = _entries[i]._fix;
elements/grid/pep.cc:191:      pp->fixes[nf].fix_hops += 1;
elements/grid/pep.cc:192:      externalize(&(pp->fixes[nf]));
elements/grid/pep.cc:197:  pp->n_fixes = htonl(nf);
elements/grid/pep.cc:237:  if(p->length() != sizeof(pep_proto)){
elements/grid/pep.cc:238:    click_chatter("PEP: bad size packet (%d bytes)", p->length());
elements/grid/pep.cc:242:  pp = (pep_proto *) p->data();
elements/grid/pep.cc:243:  nf = ntohl(pp->n_fixes);
elements/grid/pep.cc:244:  if(nf < 0 || (const u_char*)&pp->fixes[nf] > p->data()+p->length()){
elements/grid/pep.cc:251:    pep_fix f = pp->fixes[i];
elements/grid/pep.cc:279:  p->kill();
elements/grid/lookuplocalgridroute2.cc:124:  WritablePacket *packet = xp->uniqueify();
elements/grid/lookuplocalgridroute2.cc:144:    encap->hops_travelled++;
elements/grid/hello.cc:91:  ASSERT_4ALIGNED(p->data());
elements/grid/hello.cc:92:  p->pull(2);
elements/grid/hello.cc:93:  memset(p->data(), 0, p->length());
elements/grid/hello.cc:95:  p->set_timestamp_anno(Timestamp::now());
elements/grid/hello.cc:97:  click_ether *eh = (click_ether *) p->data();
elements/grid/updateroutes.cc:536:  ASSERT_4ALIGNED(p->data());
elements/grid/updateroutes.cc:537:  p->pull(2);
elements/grid/updateroutes.cc:538:  memset(p->data(), 0, p->length());
elements/grid/updateroutes.cc:540:  p->set_timestamp_anno(Timestamp::now());
elements/grid/updateroutes.cc:542:  click_ether *eh = (click_ether *) p->data();
elements/grid/packetlogger2.cc:65:  while (p->_p.size()) {
elements/grid/packetlogger2.cc:66:    p->_p.pop_front();
elements/grid/packetlogger2.cc:76:  return String(p->_p.size());
elements/grid/packetlogger2.cc:90:  bytes_per_entry += 2 * p->_nb;
elements/grid/packetlogger2.cc:91:  bytes_per_entry += p->_nb / 4;   // ' ' every 4 bytes of data
elements/grid/packetlogger2.cc:94:  int n = p->_p.size() * bytes_per_entry;
elements/grid/packetlogger2.cc:100:  while (p->_p.size() &&
elements/grid/packetlogger2.cc:102:    const log_entry &d = p->_p.front();
elements/grid/packetlogger2.cc:115:    unsigned num_to_print = p->_nb > d.length ? d.length : p->_nb;
elements/grid/packetlogger2.cc:125:    p->_p.pop_front();
elements/grid/ackresponder.cc:37:  click_ether *e = (click_ether *) p->data();
elements/grid/ackresponder.cc:41:    xp->pull(2);
elements/grid/ackresponder.cc:42:    click_ether *eth = (click_ether *) xp->data();
elements/grid/lookuplocalgridroute.cc:159:	IPAddress dest_ip(encap->dst_ip);
elements/grid/lookuplocalgridroute.cc:189:	  forward_grid_packet(packet, encap->dst_ip);
elements/grid/lookuplocalgridroute.cc:243:      encap->hops_travelled = 0;
elements/grid/lookuplocalgridroute.cc:244:      encap->dst_ip = dst;
elements/grid/lookuplocalgridroute.cc:247:      encap->dst_loc_good = false;
elements/grid/lookuplocalgridroute.cc:293:  WritablePacket *packet = xp->uniqueify();
elements/grid/lookuplocalgridroute.cc:329:    encap->hops_travelled++;
elements/grid/gridroutetable.cc:547:  if (!next_hop->metric_valid) {
elements/grid/gridroutetable.cc:554:    if (next_hop->metric > 1)
elements/grid/gridroutetable.cc:556:		    next_hop->dest_ip.unparse().c_str(), next_hop->metric);
elements/grid/gridroutetable.cc:562:      if (next_hop->metric < 100)
elements/grid/gridroutetable.cc:564:		      &next_hop->dest_ip, &r.dest_ip, next_hop->metric);
elements/grid/gridroutetable.cc:566:    r.metric += next_hop->metric;
elements/grid/gridroutetable.cc:571:    r.metric = (r.metric * next_hop->metric) / 100;
elements/grid/gridroutetable.cc:574:    r.metric = (next_hop->metric < r.metric) ? next_hop->metric : r.metric;
elements/grid/gridroutetable.cc:580:    r.metric = (next_hop->metric > r.metric) ? next_hop->metric : r.metric;
elements/grid/gridroutetable.cc:1475:  ASSERT_4ALIGNED(p->data());
elements/grid/gridroutetable.cc:1476:  p->pull(2);
elements/grid/gridroutetable.cc:1477:  memset(p->data(), 0, p->length());
elements/grid/gridroutetable.cc:1480:  p->set_timestamp_anno(Timestamp::now());
elements/grid/gridroutetable.cc:1483:  click_ether *eh = (click_ether *) p->data();
elements/grid/ackretrysender.cc:52:    p->kill();
elements/grid/ackretrysender.cc:56:  click_ether *e_ack = (click_ether *) p->data();
elements/grid/ackretrysender.cc:59:    p->kill();
elements/grid/ackretrysender.cc:70:    p->kill();
elements/grid/ackretrysender.cc:83:  p->kill();
elements/grid/ackretrysender.cc:103:    _waiting_packet = p->clone();
elements/grid/ackretrysender.cc:157:    _history.push_back(tx_result_t(p->timestamp_anno(), _num_tries, false));
elements/grid/ackretrysender.cc:166:    _waiting_packet = p->clone();
elements/grid/linktester.cc:331:  click_ether *eh = (click_ether *) (p->data());
elements/grid/linktester.cc:347:    memcpy(p->data() + sizeof(click_ether) + sizeof(payload_t),
elements/grid/linktester.cc:358:  click_ether *eh = (click_ether *) (p->data());
elements/grid/linktester.cc:376:    memcpy(p->data() + sizeof(click_ether) + sizeof(payload_t),
elements/grid/lrhello.cc:115:  ASSERT_4ALIGNED(p->data());
elements/grid/lrhello.cc:116:  p->pull(2);
elements/grid/lrhello.cc:117:  memset(p->data(), 0, p->length());
elements/grid/lrhello.cc:119:  p->set_timestamp_anno(Timestamp::now());
elements/grid/lrhello.cc:121:  click_ether *eh = (click_ether *) p->data();
elements/grid/lrhello.cc:126:  grid_hdr *gh = (grid_hdr *) (p->data() + sizeof(click_ether));
elements/grid/lrhello.cc:132:  grid_hello *hlo = (grid_hello *) (p->data() + sizeof(click_ether) + sizeof(grid_hdr));
elements/grid/lrhello.cc:139:  grid_nbr_entry *curr = (grid_nbr_entry *) (p->data() + sizeof(click_ether) +
elements/grid/dsrroutetable.cc:70:    if (frv.p) frv.p->kill();
elements/grid/dsrroutetable.cc:107:      sb[j]._p->kill();
elements/grid/dsrroutetable.cc:247:	val.p->kill();
elements/grid/dsrroutetable.cc:376:	sb[j]._p->kill();
elements/grid/dsrroutetable.cc:398:  IPAddress dst = IPAddress(p->dst_ip_anno());
elements/grid/dsrroutetable.cc:409:    p->kill();
elements/grid/dsrroutetable.cc:453:    IPAddress dst_addr(ip->ip_dst.s_addr);
elements/grid/dsrroutetable.cc:502:      unsigned src = ip->ip_src.s_addr;
elements/grid/dsrroutetable.cc:549:	if (ip->ip_ttl == 1) {
elements/grid/dsrroutetable.cc:653:	      old_frv->p->kill();
elements/grid/dsrroutetable.cc:675:      IPAddress dst_addr(ip->ip_dst.s_addr);
elements/grid/dsrroutetable.cc:773:      unsigned ip_dst = ip->ip_dst.s_addr;
elements/grid/dsrroutetable.cc:827:	int hop_count = dsr_rrep->num_addrs();
elements/grid/dsrroutetable.cc:854:    unsigned src = ip->ip_src.s_addr;
elements/grid/dsrroutetable.cc:945:  ip = (click_ip *)(p->data());
elements/grid/dsrroutetable.cc:949:  click_dsr *dsr = (click_dsr *)(p->data() + sizeof(click_ip));
elements/grid/dsrroutetable.cc:951:  dsr->dsr_next_header = ip->ip_p; // save IP protocol type
elements/grid/dsrroutetable.cc:952:  ip->ip_p = IP_PROTO_DSR; // set new protocol type to DSR
elements/grid/dsrroutetable.cc:956:  DEBUG_CHATTER(" * add_dsr_header: new packet size is %d, old was %d \n", p->length(), old_len);
elements/grid/dsrroutetable.cc:964:  ip->ip_ttl = 255;
elements/grid/dsrroutetable.cc:966:  ip->ip_len = htons(p->length());
elements/grid/dsrroutetable.cc:967:  ip->ip_dst.s_addr = (unsigned)p->dst_ip_anno(); // XXX not sure I understand why we need to reset this
elements/grid/dsrroutetable.cc:968:  ip->ip_sum = 0;
elements/grid/dsrroutetable.cc:969:  ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/grid/dsrroutetable.cc:971:  p->set_ip_header(ip, sizeof(click_ip));
elements/grid/dsrroutetable.cc:974:  click_dsr_source *dsr_source=(click_dsr_source *)(p->data()+sizeof(click_ip)+sizeof(click_dsr));
elements/grid/dsrroutetable.cc:986:  p->set_dst_ip_anno(source_route[hop_count].addr());
elements/grid/dsrroutetable.cc:998:  click_ip *ip = reinterpret_cast<click_ip *>(p->data());
elements/grid/dsrroutetable.cc:999:  click_dsr *dsr = (click_dsr *)(p->data() + sizeof(click_ip));
elements/grid/dsrroutetable.cc:1001:  assert(ip->ip_p == IP_PROTO_DSR);
elements/grid/dsrroutetable.cc:1012:  p->pull(dsr_len);
elements/grid/dsrroutetable.cc:1013:  memcpy(p->data(), &new_ip, sizeof(click_ip));
elements/grid/dsrroutetable.cc:1014:  ip=reinterpret_cast<click_ip *>(p->data());
elements/grid/dsrroutetable.cc:1015:  ip->ip_len=htons(p->length());
elements/grid/dsrroutetable.cc:1016:  ip->ip_sum=0;
elements/grid/dsrroutetable.cc:1017:  ip->ip_sum=click_in_cksum((unsigned char *)ip,sizeof(click_ip));
elements/grid/dsrroutetable.cc:1019:  p->set_ip_header((click_ip*)p->data(),sizeof(click_ip));
elements/grid/dsrroutetable.cc:1035:  unsigned src = ip->ip_src.s_addr;
elements/grid/dsrroutetable.cc:1091:  click_ip *ip = reinterpret_cast<click_ip *>(p->data());
elements/grid/dsrroutetable.cc:1092:  click_dsr *dsr = (click_dsr *)(p->data() + sizeof(click_ip));
elements/grid/dsrroutetable.cc:1093:  click_dsr_rrep *dsr_rrep = (click_dsr_rrep *)( p->data() +
elements/grid/dsrroutetable.cc:1096:  click_dsr_source *dsr_source = (click_dsr_source *)( p->data() +
elements/grid/dsrroutetable.cc:1102:  p->set_ip_header(ip, sizeof(click_ip));
elements/grid/dsrroutetable.cc:1119:  dsr_rrep->dsr_type = DSR_TYPE_RREP;
elements/grid/dsrroutetable.cc:1120:  dsr_rrep->dsr_len = sizeof(DSRHop)*reply_hop_count+1;
elements/grid/dsrroutetable.cc:1121:  dsr_rrep->dsr_flags = 0;
elements/grid/dsrroutetable.cc:1122:  //  dsr_rrep->dsr_id = htons(id);
elements/grid/dsrroutetable.cc:1128:    dsr_rrep->addr[i-1]._ip = reply_route[i]._ip;
elements/grid/dsrroutetable.cc:1129:    dsr_rrep->addr[i-1]._metric = reply_route[i]._metric;
elements/grid/dsrroutetable.cc:1133:  ip->ip_v = 4;
elements/grid/dsrroutetable.cc:1134:  ip->ip_hl = sizeof(click_ip) >> 2;
elements/grid/dsrroutetable.cc:1135:  ip->ip_len = htons(p->length());
elements/grid/dsrroutetable.cc:1136:  //  ip->ip_id = htons(id); // XXXXX
elements/grid/dsrroutetable.cc:1137:  ip->ip_p = IP_PROTO_DSR;
elements/grid/dsrroutetable.cc:1138:  ip->ip_src.s_addr = src.addr();
elements/grid/dsrroutetable.cc:1139:  ip->ip_dst.s_addr = dst.addr();
elements/grid/dsrroutetable.cc:1140:  ip->ip_tos = 0;
elements/grid/dsrroutetable.cc:1141:  ip->ip_off = 0;
elements/grid/dsrroutetable.cc:1142:  ip->ip_ttl = ttl;
elements/grid/dsrroutetable.cc:1143:  ip->ip_sum = 0;
elements/grid/dsrroutetable.cc:1144:  ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/grid/dsrroutetable.cc:1147:  dsr->dsr_next_header = ip->ip_p;
elements/grid/dsrroutetable.cc:1152:  p->set_dst_ip_anno(source_route[1]._ip);
elements/grid/dsrroutetable.cc:1153:  IPAddress dst_anno_address(p->dst_ip_anno());
elements/grid/dsrroutetable.cc:1199:  click_ip *ip = reinterpret_cast<click_ip *>(p->data());
elements/grid/dsrroutetable.cc:1201:  click_dsr *dsr = (click_dsr *)(p->data() + sizeof(click_ip));
elements/grid/dsrroutetable.cc:1203:  click_dsr_rerr *dsr_rerr = (click_dsr_rerr *)(p->data() +
elements/grid/dsrroutetable.cc:1206:  in_addr *dsr_unreach_addr=(in_addr *)(p->data() +
elements/grid/dsrroutetable.cc:1211:  click_dsr_source *dsr_source = (click_dsr_source *)(p->data() +
elements/grid/dsrroutetable.cc:1217:  p->set_ip_header(ip, sizeof(click_ip));
elements/grid/dsrroutetable.cc:1231:  ip->ip_v = 4;
elements/grid/dsrroutetable.cc:1232:  ip->ip_hl = sizeof(click_ip) >> 2;
elements/grid/dsrroutetable.cc:1233:  ip->ip_len = htons(p->length());
elements/grid/dsrroutetable.cc:1238:  ip->ip_id = htons(1);
elements/grid/dsrroutetable.cc:1239:  ip->ip_p = IP_PROTO_DSR;
elements/grid/dsrroutetable.cc:1240:  ip->ip_src.s_addr = bad_src.addr();
elements/grid/dsrroutetable.cc:1241:  ip->ip_dst.s_addr = src.addr();
elements/grid/dsrroutetable.cc:1242:  ip->ip_tos = 0;
elements/grid/dsrroutetable.cc:1243:  ip->ip_off = 0;
elements/grid/dsrroutetable.cc:1244:  ip->ip_ttl = ttl;
elements/grid/dsrroutetable.cc:1245:  ip->ip_sum = 0;
elements/grid/dsrroutetable.cc:1246:  ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/grid/dsrroutetable.cc:1249:  dsr->dsr_next_header = ip->ip_p;
elements/grid/dsrroutetable.cc:1270:  p->set_dst_ip_anno(source_route[1]._ip);
elements/grid/dsrroutetable.cc:1272:  IPAddress dst_anno_address(p->dst_ip_anno());
elements/grid/dsrroutetable.cc:1285:  const click_ip *ip = p->ip_header();
elements/grid/dsrroutetable.cc:1286:  const click_dsr_rrep *dsr_rrep = (const click_dsr_rrep *)(p->data()+
elements/grid/dsrroutetable.cc:1289:  IPAddress dest_ip(ip->ip_dst.s_addr);
elements/grid/dsrroutetable.cc:1291:  assert(dsr_rrep->dsr_type == DSR_TYPE_RREP);
elements/grid/dsrroutetable.cc:1293:  int hop_count = dsr_rrep->num_addrs();
elements/grid/dsrroutetable.cc:1312:    route.push_back(dsr_rrep->addr[i]);
elements/grid/dsrroutetable.cc:1336:  IPAddress src(ip->ip_src.s_addr);
elements/grid/dsrroutetable.cc:1337:  IPAddress dst(ip->ip_dst.s_addr);
elements/grid/dsrroutetable.cc:1359:  click_dsr_rrep *dsr_rrep=(click_dsr_rrep *)(p->data()+
elements/grid/dsrroutetable.cc:1364:  int num_addr = dsr_rrep->num_addrs();
elements/grid/dsrroutetable.cc:1406:  const click_ip *ip = (const click_ip*)(p->data() + sizeof(click_ether));
elements/grid/dsrroutetable.cc:1408:  click_dsr *dsr = (click_dsr *)(p->data() + sizeof(click_ip));
elements/grid/dsrroutetable.cc:1411:  click_dsr_option *dsr_option = (click_dsr_option *)(p->data() +
elements/grid/dsrroutetable.cc:1427:    if (dsr_rrep->length() == dsr_len) {
elements/grid/dsrroutetable.cc:1429:      IPAddress dst_addr(ip->ip_dst.s_addr);
elements/grid/dsrroutetable.cc:1432:      dsr_option = (click_dsr_option *)(dsr_rrep->next_option());
elements/grid/dsrroutetable.cc:1450:      IPAddress dst_addr(ip->ip_dst.s_addr);
elements/grid/dsrroutetable.cc:1479:      IPAddress dst(ip->ip_dst.s_addr);
elements/grid/dsrroutetable.cc:1515:    IPAddress final_dst(ip->ip_dst.s_addr);
elements/grid/dsrroutetable.cc:1535:  click_dsr_source *dsr_source = (click_dsr_source *)(p->data() +
elements/grid/dsrroutetable.cc:1540:    p->kill();
elements/grid/dsrroutetable.cc:1546:  p->set_dst_ip_anno(next_sr_hop(p, offset));
elements/grid/dsrroutetable.cc:1573:  p = p->put(sizeof(DSRHop));
elements/grid/dsrroutetable.cc:1575:  click_ip *ip = reinterpret_cast<click_ip *>(p->data());
elements/grid/dsrroutetable.cc:1576:  click_dsr *dsr = (click_dsr *)(p->data()+
elements/grid/dsrroutetable.cc:1578:  click_dsr_rreq *dsr_rreq = (click_dsr_rreq *)(p->data() +
elements/grid/dsrroutetable.cc:1590:  ip->ip_ttl--;
elements/grid/dsrroutetable.cc:1591:  ip->ip_len = htons(p->length());
elements/grid/dsrroutetable.cc:1592:  ip->ip_sum = 0;
elements/grid/dsrroutetable.cc:1593:  ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/grid/dsrroutetable.cc:1595:  p->set_dst_ip_anno(0xffffffff);
elements/grid/dsrroutetable.cc:1614:  click_ip *ip = reinterpret_cast<click_ip *>(p->data());
elements/grid/dsrroutetable.cc:1615:  click_dsr *dsr = (click_dsr*)(p->data() + sizeof(click_ip));
elements/grid/dsrroutetable.cc:1616:  click_dsr_rreq *dsr_rreq = (click_dsr_rreq*)(p->data() +
elements/grid/dsrroutetable.cc:1620:  ip->ip_v = 4;
elements/grid/dsrroutetable.cc:1621:  ip->ip_hl = sizeof(click_ip) >> 2;
elements/grid/dsrroutetable.cc:1622:  ip->ip_len = htons(p->length());
elements/grid/dsrroutetable.cc:1623:  ip->ip_id = htons(_rreq_id); // XXX eh?  why this?
elements/grid/dsrroutetable.cc:1624:  ip->ip_p = IP_PROTO_DSR;
elements/grid/dsrroutetable.cc:1625:  ip->ip_src.s_addr = me->addr();
elements/grid/dsrroutetable.cc:1627:    ip->ip_dst.s_addr = dst.addr();
elements/grid/dsrroutetable.cc:1629:    ip->ip_dst.s_addr = 0xffffffff;
elements/grid/dsrroutetable.cc:1630:  ip->ip_tos = 0;
elements/grid/dsrroutetable.cc:1631:  ip->ip_off = 0;
elements/grid/dsrroutetable.cc:1632:  ip->ip_ttl = ttl;
elements/grid/dsrroutetable.cc:1633:  ip->ip_sum = 0;
elements/grid/dsrroutetable.cc:1634:  ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/grid/dsrroutetable.cc:1644:  p->set_dst_ip_anno(ip->ip_dst.s_addr);
elements/grid/dsrroutetable.cc:1881:    // default to hop-count, all links have a hop-count of 1
elements/grid/dsrroutetable.cc:1890:    return (a < b); // fallback to minimum hop-count
elements/grid/dsrroutetable.cc:1918:    return r.size(); // fallback to hop-count
elements/local/forceicmp.cc:60:  click_ip *ip = p->ip_header();
elements/local/forceicmp.cc:61:  unsigned plen = p->network_length();
elements/local/forceicmp.cc:65:  if (!p->has_network_header() || plen < sizeof(click_ip))
elements/local/forceicmp.cc:68:  hlen = ip->ip_hl << 2;
elements/local/forceicmp.cc:72:  ilen = ntohs(ip->ip_len);
elements/local/forceicmp.cc:97:  p->kill();
elements/local/chuckcheck.cc:44:    s.saddr = p->ip_header()->ip_src.s_addr;
elements/local/bufconv.cc:55:  p->kill();
elements/local/bufconv.cc:81:  ip->ip_v = 4;
elements/local/bufconv.cc:82:  ip->ip_hl = 5;
elements/local/bufconv.cc:83:  ip->ip_tos = 0x10;
elements/local/bufconv.cc:84:  ip->ip_len = htons(q->length());
elements/local/bufconv.cc:85:  ip->ip_id = htons(0); // what is this used for exactly?
elements/local/bufconv.cc:86:  ip->ip_off = htons(IP_DF);
elements/local/bufconv.cc:87:  ip->ip_ttl = 255;
elements/local/bufconv.cc:88:  ip->ip_p = IP_PROTO_TCP;
elements/local/bufconv.cc:89:  ip->ip_sum = 0;
elements/local/bufconv.cc:91:  tcp->th_off = 5;
elements/local/bufconv.cc:92:  tcp->th_flags = TH_PUSH; // how should we set the PUSH bit?
elements/local/bufconv.cc:93:  tcp->th_win = htons(32120); // when and where should this be set?
elements/local/bufconv.cc:94:  tcp->th_sum = htons(0);
elements/local/bufconv.cc:95:  tcp->th_urp = htons(0);
elements/local/bufconv.cc:115:  q->set_ip_header(ip, ip->ip_hl << 2);
elements/local/bufconv.cc:124:    const click_ip *iph = p->ip_header();
elements/local/bufconv.cc:125:    const click_tcp *tcph = p->tcp_header();
elements/local/bufconv.cc:128:      p->kill();
elements/local/bufconv.cc:134:    p->kill();
elements/local/forceip.cc:38:  click_ip *ip = reinterpret_cast<click_ip *>(p->data());
elements/local/forceip.cc:39:  unsigned plen = p->length();
elements/local/forceip.cc:41:  ip->ip_v = 4;
elements/local/forceip.cc:42:  ip->ip_len = htons(plen);
elements/local/forceip.cc:45:    ip->ip_off = 0;
elements/local/forceip.cc:48:  unsigned hlen = ip->ip_hl << 2;
elements/local/forceip.cc:50:    ip->ip_hl = plen >> 2;
elements/local/forceip.cc:53:  ip->ip_sum = 0;
elements/local/forceip.cc:54:  ip->ip_sum = click_in_cksum((unsigned char *)ip, ip->ip_hl << 2);
elements/local/forceip.cc:56:  p->set_ip_header(ip, hlen);
elements/local/reframe.cc:84:    _qhead = p->next();
elements/local/reframe.cc:85:    p->kill();
elements/local/reframe.cc:100:	     p = p->next()) {
elements/local/reframe.cc:101:	  memcpy(_header->end_data(), p->data(),
elements/local/reframe.cc:102:		 MIN(p->length(), _foff + _flen - _header->length()));
elements/local/reframe.cc:103:	  _header->put(MIN(p->length(), _foff + _flen - _header->length()));
elements/local/reframe.cc:157:      if ((int) p->length() > _need) {
elements/local/reframe.cc:159:	memcpy(p1->end_data(), p->data(), _need);
elements/local/reframe.cc:162:	p->pull(_need);
elements/local/reframe.cc:167:	memcpy(p1->end_data(), p->data(), p->length());
elements/local/reframe.cc:168:	p1->put(p->length());
elements/local/reframe.cc:169:	_have -= p->length();
elements/local/reframe.cc:170:	_need -= p->length();
elements/local/reframe.cc:172:	_qhead = p->next();
elements/local/reframe.cc:175:	p->kill();
elements/local/reframe.cc:202:  p->set_next(0);
elements/local/reframe.cc:203:  _have += p->length();
elements/local/rogueDetect.cc:151:		if(!strcmp(chksta.mac->unparse().c_str(), lkup->mac->unparse().c_str())) {
elements/local/rogueDetect.cc:345:	struct click_wifi *w = (struct click_wifi *) p->data();
elements/local/rogueDetect.cc:347:	//struct click_wifi_extra *cehp = (struct click_wifi_extra *) p->data();
elements/local/rogueDetect.cc:348:	//struct ieee80211_radiotap_header *radio = (struct ieee80211_radiotap_header *) p->data();
elements/local/rogueDetect.cc:392:	if ((ceha->flags & WIFI_EXTRA_RX_ERR)/* || (cehp->flags & WIFI_EXTRA_RX_ERR)*/) {
elements/local/rogueDetect.cc:398:	if (p->length() >= sizeof(click_wifi)) {
elements/local/rogueDetect.cc:523:	p->kill();
elements/local/tcpbuffer.cc:59:    p->kill();
elements/local/tcpbuffer.cc:71:    p->kill();
elements/local/tcpreflector.cc:37:  WritablePacket *p = xp->uniqueify();
elements/local/tcpreflector.cc:39:  unsigned plen = p->length();
elements/local/tcpreflector.cc:50:  ip = (click_ip *) p->data();
elements/local/tcpreflector.cc:51:  hlen = ip->ip_hl << 2;
elements/local/tcpreflector.cc:59:  src = ip->ip_src;
elements/local/tcpreflector.cc:60:  dst = ip->ip_dst;
elements/local/tcpreflector.cc:89:  ip->ip_src = dst;
elements/local/tcpreflector.cc:90:  ip->ip_dst = src;
elements/local/tcpreflector.cc:91:  ip->ip_ttl = 250;
elements/local/tcpreflector.cc:92:  p->set_dst_ip_anno(IPAddress(ip->ip_dst));
elements/local/tcpreflector.cc:100:  ip->ip_sum = 0;
elements/local/tcpreflector.cc:101:  ip->ip_len = htons(plen - 20);
elements/local/tcpreflector.cc:107:  ip->ip_len = htons(plen);
elements/local/tcpreflector.cc:109:  ip->ip_sum = 0;
elements/local/tcpreflector.cc:110:  ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/local/tcpreflector.cc:116:    p->kill();
elements/local/webgen.cc:243:  unsigned plen = p->length ();
elements/local/webgen.cc:248:  click_ip *ip = (click_ip *) p->data();
elements/local/webgen.cc:249:  unsigned iplen = ntohs(ip->ip_len);
elements/local/webgen.cc:250:  unsigned hlen = ip->ip_hl << 2;
elements/local/webgen.cc:252:    p->kill();
elements/local/webgen.cc:260:  CB *cb = find_cb(ip->ip_dst.s_addr, th->th_dport, th->th_sport);
elements/local/webgen.cc:266:		ip->ip_dst, th->th_dport,
elements/local/webgen.cc:267:		ip->ip_src, th->th_sport,
elements/local/webgen.cc:312:    p->kill ();
elements/local/webgen.cc:331:      xp->shared () ||
elements/local/webgen.cc:332:      xp->headroom () < headroom ||
elements/local/webgen.cc:333:      xp->length () + xp->tailroom() < plen) {
elements/local/webgen.cc:335:      xp->kill ();
elements/local/webgen.cc:338:    p = xp->uniqueify ();
elements/local/webgen.cc:339:    if (p->length () < plen)
elements/local/webgen.cc:340:      p = p->put (plen - p->length ());
elements/local/webgen.cc:341:    else if (p->length () > plen)
elements/local/webgen.cc:342:      p->take (p->length () - plen);
elements/local/webgen.cc:374:      xp->kill ();
elements/local/webgen.cc:416:  unsigned plen = p->length ();
elements/local/webgen.cc:418:  click_ip *ip = (click_ip *) p->data ();
elements/local/webgen.cc:419:  ip->ip_v = 4;
elements/local/webgen.cc:420:  ip->ip_hl = sizeof (click_ip) >> 2;
elements/local/webgen.cc:421:  ip->ip_id = htons (_id.fetch_and_add (1));
elements/local/webgen.cc:422:  ip->ip_p = 6;
elements/local/webgen.cc:423:  ip->ip_src = src;
elements/local/webgen.cc:424:  ip->ip_dst = dst;
elements/local/webgen.cc:425:  ip->ip_tos = 0;
elements/local/webgen.cc:426:  ip->ip_off = 0;
elements/local/webgen.cc:427:  ip->ip_ttl = 250;
elements/local/webgen.cc:428:  p->set_dst_ip_anno (IPAddress (ip->ip_dst));
elements/local/webgen.cc:429:  p->set_ip_header (ip, sizeof (click_ip));
elements/local/webgen.cc:449:  ip->ip_sum = 0;
elements/local/webgen.cc:450:  ip->ip_len = htons (plen - 20);
elements/local/webgen.cc:456:  ip->ip_len = htons (plen);
elements/local/webgen.cc:458:  ip->ip_sum = 0;
elements/local/webgen.cc:459:  ip->ip_sum = click_in_cksum ((unsigned char *) ip, sizeof (click_ip));
elements/local/print80211.cc:219:    sa << p->timestamp_anno() << ": ";
elements/local/print80211.cc:222:  snprintf(sbuf, sizeof(sbuf), "%4d | ", p->length());
elements/local/print80211.cc:226:  ieee80211_frame *frame = (ieee80211_frame *) p->data();
elements/local/print80211.cc:244:  case IEEE80211_FC0_TYPE_DATA: print_data(sa, _verbose, p->data(), p->length()); break;
elements/local/print80211.cc:245:  case IEEE80211_FC0_TYPE_MGT: print_mgmt(sa, _verbose, p->data(), p->length()); break;
elements/local/print80211.cc:246:  case IEEE80211_FC0_TYPE_CTL: print_ctl(sa, _verbose, p->data(), p->length()); break;
elements/local/basic.cc:88:		if(!strcmp(chksta.mac->unparse().c_str(), lkup->mac->unparse().c_str())) {
elements/local/basic.cc:199:	struct click_wifi *w = (struct click_wifi *) p->data();
elements/local/tcpconn.cc:90:    p->kill();
elements/local/tcpconn.cc:109:  const click_tcp *tcph = p->tcp_header();
elements/local/tcpconn.cc:134:  if (WritablePacket *q = p->uniqueify()) {
elements/local/tcpconn.cc:196:  ip->ip_v = 4;
elements/local/tcpconn.cc:197:  ip->ip_hl = 5;
elements/local/tcpconn.cc:198:  ip->ip_tos = 0x10;
elements/local/tcpconn.cc:199:  ip->ip_len = htons(q->length());
elements/local/tcpconn.cc:200:  ip->ip_id = htons(0); // what is this used for exactly?
elements/local/tcpconn.cc:201:  ip->ip_off = htons(IP_DF);
elements/local/tcpconn.cc:202:  ip->ip_ttl = 255;
elements/local/tcpconn.cc:203:  ip->ip_p = IP_PROTO_TCP;
elements/local/tcpconn.cc:204:  ip->ip_sum = 0;
elements/local/tcpconn.cc:207:  memmove((void *) &(ip->ip_src), (void *) &sa, 4);
elements/local/tcpconn.cc:208:  memmove((void *) &(ip->ip_dst), (void *) &da, 4);
elements/local/tcpconn.cc:210:  tcp->th_sport = _flow.sport();
elements/local/tcpconn.cc:211:  tcp->th_dport = _flow.dport();
elements/local/tcpconn.cc:212:  tcp->th_seq = htonl(_seq_nxt);
elements/local/tcpconn.cc:213:  tcp->th_ack = 0;
elements/local/tcpconn.cc:214:  tcp->th_off = 5;
elements/local/tcpconn.cc:215:  tcp->th_flags = TH_SYN;
elements/local/tcpconn.cc:216:  tcp->th_win = htons(32120); // when and where should this be set?
elements/local/tcpconn.cc:217:  tcp->th_sum = htons(0);
elements/local/tcpconn.cc:218:  tcp->th_urp = htons(0);
elements/local/tcpconn.cc:220:  q->set_ip_header(ip, ip->ip_hl << 2);
elements/local/copytcpseq.cc:74:  const click_tcp *tcph = p->tcp_header();
elements/local/copytcpseq.cc:88:  if (WritablePacket *q = p->uniqueify()) {
elements/local/tcpdemux.cc:46:  const click_ip *iph = p->ip_header();
elements/local/tcpdemux.cc:47:  const click_tcp *tcph = p->tcp_header();
elements/local/tcpdemux.cc:88:    p->kill();
elements/local/copyflowid.cc:83:  if (WritablePacket *q = p->uniqueify()) {
elements/local/forcetcp.cc:53:  click_ip *ip = p->ip_header();
elements/local/forcetcp.cc:54:  unsigned plen = p->network_length();
elements/local/forcetcp.cc:59:  if (!p->has_network_header() || plen < sizeof(click_ip))
elements/local/forcetcp.cc:62:  hlen = ip->ip_hl << 2;
elements/local/forcetcp.cc:66:  ilen = ntohs(ip->ip_len);
elements/local/forcetcp.cc:109:  oisum = ip->ip_sum;
elements/local/forcetcp.cc:110:  ip->ip_sum = 0;
elements/local/forcetcp.cc:111:  ip->ip_len = htons(ilen - hlen);
elements/local/forcetcp.cc:117:  ip->ip_sum = oisum;
elements/local/forcetcp.cc:118:  ip->ip_len = htons(ilen);
elements/local/forcetcp.cc:124:  p->kill();
elements/local/printairo.cc:110:  struct an_rxframe *frame = (struct an_rxframe *) p->data();
elements/local/printairo.cc:112:  if (p->length() < sizeof(*frame)) {
elements/local/printairo.cc:148:	sa << p->timestamp_anno() << ": ";
elements/local/printairo.cc:154:	       sa.c_str(), p->length(), (int) frame->an_rx_signal_strength,
elements/local/printairo.cc:215:  p->kill();
elements/local/tcpbuffer.hh:129:        p->kill();
elements/local/tcpbuffer.hh:219:  const click_ip *iph = p->ip_header();
elements/local/tcpbuffer.hh:221:    reinterpret_cast<const click_tcp *>(p->transport_header());
elements/local/tcpbuffer.hh:231:    reinterpret_cast<const click_tcp *>(p->transport_header());
elements/local/forceudp.cc:55:  click_ip *ip = p->ip_header();
elements/local/forceudp.cc:56:  unsigned plen = p->network_length();
elements/local/forceudp.cc:61:  if (!p->has_network_header() || plen < sizeof(click_ip))
elements/local/forceudp.cc:64:  hlen = ip->ip_hl << 2;
elements/local/forceudp.cc:68:  ilen = ntohs(ip->ip_len);
elements/local/forceudp.cc:85:  oisum = ip->ip_sum;
elements/local/forceudp.cc:86:  ip->ip_sum = 0;
elements/local/forceudp.cc:87:  ip->ip_len = htons(ilen - hlen);
elements/local/forceudp.cc:93:  ip->ip_sum = oisum;
elements/local/forceudp.cc:94:  ip->ip_len = htons(ilen);
elements/local/forceudp.cc:100:  p->kill();
elements/local/duppath.cc:51:  unsigned d = ntohl(p->ip_header()->ip_src.s_addr);
elements/local/duppath.cc:58:      p->kill();
elements/local/tcpack.cc:85:    p->kill();
elements/local/tcpack.cc:101:      p->kill();
elements/local/tcpack.cc:111:  const click_tcp *tcph = p->tcp_header();
elements/local/tcpack.cc:145:  const click_tcp *tcph = p->tcp_header();
elements/local/tcpack.cc:155:  click_tcp *tcph_new = p->uniqueify()->tcp_header();
elements/local/tcpack.cc:183:  ip->ip_v = 4;
elements/local/tcpack.cc:184:  ip->ip_hl = 5;
elements/local/tcpack.cc:185:  ip->ip_tos = 0x10;
elements/local/tcpack.cc:186:  ip->ip_len = htons(q->length());
elements/local/tcpack.cc:187:  ip->ip_id = htons(0); // what is this used for exactly?
elements/local/tcpack.cc:188:  ip->ip_off = htons(IP_DF);
elements/local/tcpack.cc:189:  ip->ip_ttl = 255;
elements/local/tcpack.cc:190:  ip->ip_p = IP_PROTO_TCP;
elements/local/tcpack.cc:191:  ip->ip_sum = 0;
elements/local/tcpack.cc:193:  tcp->th_ack = htonl(_ack_nxt);
elements/local/tcpack.cc:194:  tcp->th_off = 5;
elements/local/tcpack.cc:195:  tcp->th_flags = TH_ACK;
elements/local/tcpack.cc:196:  tcp->th_win = htons(32120); // when and where should this be set?
elements/local/tcpack.cc:197:  tcp->th_sum = htons(0);
elements/local/tcpack.cc:198:  tcp->th_urp = htons(0);
elements/local/tcpack.cc:200:  q->set_ip_header(ip, ip->ip_hl << 2);
elements/local/toytcp.cc:99:  click_tcp *th = (click_tcp *) p->data();
elements/local/toytcp.cc:102:  if(p->length() < sizeof(*th))
elements/local/toytcp.cc:134:    p->kill();
elements/local/toytcp.cc:157:     xp->shared() ||
elements/local/toytcp.cc:158:     xp->headroom() < headroom ||
elements/local/toytcp.cc:159:     xp->length() + xp->tailroom() < plen){
elements/local/toytcp.cc:162:                    xp->headroom(), xp->length(), xp->tailroom());
elements/local/toytcp.cc:163:      xp->kill();
elements/local/toytcp.cc:167:    p = xp->uniqueify();
elements/local/toytcp.cc:168:    if (p->length() > plen)
elements/local/toytcp.cc:169:	p->take(p->length() - plen);
elements/local/toytcp.cc:170:    else if (p->length() < plen)
elements/local/toytcp.cc:171:	if (!(p = p->put(plen - p->length())))
elements/local/toytcp.cc:175:  click_tcp *th = (click_tcp *) p->data();
elements/aqm/pi.cc:227:	p->kill();
elements/aqm/red.cc:265:	p->kill();
elements/ip/ipreassembler.cc:86:    if (p->has_network_header()) {
elements/ip/ipreassembler.cc:87:	const click_ip *iph = p->ip_header();
elements/ip/ipreassembler.cc:142:    const click_ip *iph = p->ip_header();
elements/ip/ipreassembler.cc:181:    const click_ip *iph = p->ip_header();
elements/ip/ipreassembler.cc:202:    memcpy(q->transport_header() + p_off, p->transport_header(), PACKET_DLEN(p));
elements/ip/ipreassembler.cc:226:    assert(p->has_network_header());
elements/ip/ipreassembler.cc:227:    const click_ip *iph = p->ip_header();
elements/ip/ipreassembler.cc:232:    int now = p->timestamp_anno().sec();
elements/ip/ipreassembler.cc:234:	p->timestamp_anno().set_now();
elements/ip/ipreassembler.cc:235:	now = p->timestamp_anno().sec();
elements/ip/ipreassembler.cc:249:	p->kill();
elements/ip/ipreassembler.cc:252:    p->take(PACKET_DLEN(p) - (p_lastoff - p_off));
elements/ip/ipreassembler.cc:265:	p->kill();
elements/ip/ipreassembler.cc:274:	    p->kill();
elements/ip/ipreassembler.cc:291:	    p->kill();
elements/ip/ipreassembler.cc:323:    memcpy(q->transport_header() + p_off, p->transport_header(), p_lastoff - p_off);
elements/ip/ipreassembler.cc:334:	memcpy(q->ip_header(), p->ip_header(), hl);
elements/ip/ipreassembler.cc:337:	q->set_device_anno(p->device_anno());
elements/ip/ipreassembler.cc:352:    p->kill();
elements/ip/ipinputcombo.cc:73:  p->pull(14);
elements/ip/ipinputcombo.cc:76:  const click_ip *ip = reinterpret_cast<const click_ip *>(p->data());
elements/ip/ipinputcombo.cc:79:  if(p->length() < sizeof(click_ip))
elements/ip/ipinputcombo.cc:82:  if(ip->ip_v != 4)
elements/ip/ipinputcombo.cc:85:  hlen = ip->ip_hl << 2;
elements/ip/ipinputcombo.cc:89:  len = ntohs(ip->ip_len);
elements/ip/ipinputcombo.cc:90:  if (len > p->length() || len < hlen)
elements/ip/ipinputcombo.cc:95:    if (ip_fast_csum((unsigned char *)ip, ip->ip_hl) != 0)
elements/ip/ipinputcombo.cc:102:  if (ip_fast_csum((unsigned char *)ip, ip->ip_hl) != 0)
elements/ip/ipinputcombo.cc:114:  if (find(_bad_src.begin(), _bad_src.end(), IPAddress(ip->ip_src)) < _bad_src.end()
elements/ip/ipinputcombo.cc:115:      && find(_good_dst.begin(), _good_dst.end(), IPAddress(ip->ip_dst)) == _good_dst.end())
elements/ip/ipinputcombo.cc:123:  p->set_ip_header(ip, hlen);
elements/ip/ipinputcombo.cc:126:  if (p->length() > len)
elements/ip/ipinputcombo.cc:127:    p->take(p->length() - len);
elements/ip/ipinputcombo.cc:130:  p->set_dst_ip_anno(ip->ip_dst);
elements/ip/ipinputcombo.cc:137:  p->kill();
elements/ip/sortediplookup.cc:155:    IPAddress a = p->dst_ip_anno();
elements/ip/sortediplookup.cc:173:	p->kill();
elements/ip/sortediplookup.cc:179:	p->set_dst_ip_anno(e.gw);
elements/ip/setipdscp.cc:53:  assert(p->has_network_header());
elements/ip/setipdscp.cc:54:  click_ip *ip = p->ip_header();
elements/ip/setipdscp.cc:57:  ip->ip_tos = (ip->ip_tos & 0x3) | _dscp;
elements/ip/setipdscp.cc:62:  uint32_t sum = (~ip->ip_sum & 0xFFFF) + (~old_hw & 0xFFFF) + new_hw;
elements/ip/setipdscp.cc:64:  ip->ip_sum = ~(sum + (sum >> 16));
elements/ip/iprw.cc:89:    in_map->initialize(ip_p, inf, outf, foutput, 0, out_map);
elements/ip/iprw.cc:90:    out_map->initialize(ip_p, outf.reverse(), inf.reverse(), routput, F_REVERSE, in_map);
elements/ip/iprw.cc:96:    assert(p->has_network_header());
elements/ip/iprw.cc:97:    click_ip *iph = p->ip_header();
elements/ip/iprw.cc:103:	p->set_dst_ip_anno(_mapto.daddr());
elements/ip/iprw.cc:118:	click_tcp *tcph = p->tcp_header();
elements/ip/iprw.cc:133:	click_udp *udph = p->udp_header();
elements/ip/iprw.cc:513:	is.u.pattern.p->use();
elements/ip/iprw.cc:571:		p->mapping_freed(m);
elements/ip/rfc2507c.cc:43:  WritablePacket *q = Packet::make(p->length() + 1);
elements/ip/rfc2507c.cc:45:  memcpy(q->data() + 1, p->data(), p->length());
elements/ip/rfc2507c.cc:57:  WritablePacket *q = Packet::make(p->length() + 2);
elements/ip/rfc2507c.cc:60:  memcpy(q->data() + 2, p->data(), p->length());
elements/ip/rfc2507c.cc:109:  const click_ip *ipp = p->ip_header();
elements/ip/rfc2507c.cc:110:  const click_tcp *tcpp = p->tcp_header();
elements/ip/rfc2507c.cc:114:  if(ipp->ip_v != ctx->_ip.ip_v ||
elements/ip/rfc2507c.cc:115:     ipp->ip_hl != ctx->_ip.ip_hl ||
elements/ip/rfc2507c.cc:116:     ipp->ip_tos != ctx->_ip.ip_tos ||
elements/ip/rfc2507c.cc:117:     (ipp->ip_off & htons(IP_DF)) != (ctx->_ip.ip_off & htons(IP_DF)) ||
elements/ip/rfc2507c.cc:118:     ipp->ip_ttl != ctx->_ip.ip_ttl ||
elements/ip/rfc2507c.cc:119:     tcpp->th_off != ctx->_tcp.th_off){
elements/ip/rfc2507c.cc:124:  x = encode16(ctx->_tcp.th_urp, tcpp->th_urp, fbuf, flen);
elements/ip/rfc2507c.cc:132:  x = encode16(ctx->_tcp.th_win, tcpp->th_win, fbuf, flen);
elements/ip/rfc2507c.cc:140:  x = encode32(ctx->_tcp.th_ack, tcpp->th_ack, fbuf, flen);
elements/ip/rfc2507c.cc:148:  x = encode32(ctx->_tcp.th_seq, tcpp->th_seq, fbuf, flen);
elements/ip/rfc2507c.cc:156:  if(ntohs(ipp->ip_id) != ntohs(ctx->_ip.ip_id) + 1){
elements/ip/rfc2507c.cc:157:    x = encode16(ctx->_ip.ip_id, ipp->ip_id, fbuf, flen);
elements/ip/rfc2507c.cc:166:  if(tcpp->th_flags & TH_PUSH)
elements/ip/rfc2507c.cc:169:  WritablePacket *q = Packet::make(p->length() - sizeof(click_ip)
elements/ip/rfc2507c.cc:174:  memcpy(q->data() + 3, &tcpp->th_sum, 2);
elements/ip/rfc2507c.cc:177:         p->data() + sizeof(click_ip) + sizeof(struct click_tcp),
elements/ip/rfc2507c.cc:178:         p->length() - sizeof(click_ip) - sizeof(struct click_tcp));
elements/ip/rfc2507c.cc:210:  assert(p->has_network_header() && p->network_header_offset() == 0);
elements/ip/rfc2507c.cc:211:  const click_ip *ipp = p->ip_header();
elements/ip/rfc2507c.cc:212:  const click_tcp *tcpp = p->tcp_header();
elements/ip/rfc2507c.cc:216:  if(ipp->ip_hl != 5 ||
elements/ip/rfc2507c.cc:217:     ipp->ip_v != 4 ||
elements/ip/rfc2507c.cc:218:     (ipp->ip_off & htons(IP_OFFMASK | IP_MF)) != 0 ||
elements/ip/rfc2507c.cc:219:     ipp->ip_p != IPPROTO_TCP ||
elements/ip/rfc2507c.cc:220:     (tcpp->th_flags & (TH_FIN|TH_SYN|TH_RST|TH_ACK)) != TH_ACK){
elements/ip/rfc2507c.cc:255:  p->kill();
elements/ip/checkipheader.cc:189:	p->kill();
elements/ip/checkipheader.cc:197:  const click_ip *ip = reinterpret_cast<const click_ip *>(p->data() + _offset);
elements/ip/checkipheader.cc:198:  unsigned plen = p->length() - _offset;
elements/ip/checkipheader.cc:205:  if (ip->ip_v != 4)
elements/ip/checkipheader.cc:208:  hlen = ip->ip_hl << 2;
elements/ip/checkipheader.cc:212:  len = ntohs(ip->ip_len);
elements/ip/checkipheader.cc:220:      val = ip_fast_csum((unsigned char *)ip, ip->ip_hl);
elements/ip/checkipheader.cc:224:    val = ip_fast_csum((unsigned char *)ip, ip->ip_hl);
elements/ip/checkipheader.cc:237:  if (find(_bad_src.begin(), _bad_src.end(), IPAddress(ip->ip_src)) < _bad_src.end()
elements/ip/checkipheader.cc:238:      && find(_good_dst.begin(), _good_dst.end(), IPAddress(ip->ip_dst)) == _good_dst.end())
elements/ip/checkipheader.cc:246:  p->set_ip_header(ip, hlen);
elements/ip/checkipheader.cc:250:    p->take(plen - len);
elements/ip/checkipheader.cc:256:  p->set_dst_ip_anno(ip->ip_dst);
elements/ip/ipaddrrewriter.cc:32:    assert(p->has_network_header());
elements/ip/ipaddrrewriter.cc:33:    click_ip *iph = p->ip_header();
elements/ip/ipaddrrewriter.cc:41:	    p->set_dst_ip_anno(_mapto.daddr());
elements/ip/ipaddrrewriter.cc:115:	    _input_specs[i].u.pattern.p->unuse();
elements/ip/ipaddrrewriter.cc:122:    if (!p->allow_nat())
elements/ip/ipaddrrewriter.cc:124:    else if (p->daddr())
elements/ip/ipaddrrewriter.cc:168:    click_ip *iph = p->ip_header();
elements/ip/ipaddrrewriter.cc:205:	    p->kill();
elements/ip/ipaddrrewriter.cc:243:	    s += rw->_input_specs[i].u.pattern.p->unparse() + "\n";
elements/ip/ipnameinfo.hh:26:domain, echo, finger, ftp, ftp-data, https, imap3, imaps, irc, netbios-dgm,
elements/ip/ipnameinfo.hh:28:snmp-trap, ssh, sunrpc, telnet, tftp, www.
elements/ip/ipnameinfo.hh:32:sourcequench, timeexceeded, timestamp, timestamp-reply, unreachable.
elements/ip/getipaddress.cc:45:  p->set_dst_ip_anno(IPAddress(p->data() + _offset));
elements/ip/lookupiproutelinux.cc:169:  IPAddress a = p->dst_ip_anno();
elements/ip/lookupiproutelinux.cc:179:      p->set_dst_ip_anno(gw);
elements/ip/ipclassifier.hh:172:Valid IP port names: 'echo', 'discard', 'daytime', 'chargen', 'ftp-data',
elements/ip/ipclassifier.hh:175:'netbios-ns', 'netbios-dgm', 'netbios-ssn', 'snmp', 'snmp-trap', 'irc',
elements/ip/ipclassifier.hh:184:'parameterproblem', 'timestamp', 'timestamp-reply', 'inforeq',
elements/ip/ipaddrpairrewriter.cc:32:    assert(p->has_network_header());
elements/ip/ipaddrpairrewriter.cc:33:    click_ip *iph = p->ip_header();
elements/ip/ipaddrpairrewriter.cc:39:	p->set_dst_ip_anno(_mapto.daddr());
elements/ip/ipaddrpairrewriter.cc:109:	    _input_specs[i].u.pattern.p->unuse();
elements/ip/ipaddrpairrewriter.cc:116:    if (!p->allow_nat())
elements/ip/ipaddrpairrewriter.cc:160:    click_ip *iph = p->ip_header();
elements/ip/ipaddrpairrewriter.cc:192:	    p->kill();
elements/ip/ipaddrpairrewriter.cc:230:	    s += rw->_input_specs[i].u.pattern.p->unparse() + "\n";
elements/ip/ipprint.cc:159:    const click_ip *iph = p->ip_header();
elements/ip/ipprint.cc:160:    const click_tcp *tcph = p->tcp_header();
elements/ip/ipprint.cc:191:       << '(' << seqlen << ',' << p->length() << ',' << ip_len << ')';
elements/ip/ipprint.cc:208:    const click_ip *iph = p->ip_header();
elements/ip/ipprint.cc:209:    const click_udp *udph = p->udp_header();
elements/ip/ipprint.cc:244:    const click_ip *iph = p->ip_header();
elements/ip/ipprint.cc:245:    const click_icmp *icmph = p->icmp_header();
elements/ip/ipprint.cc:325:    if (!_active || !p->has_network_header())
elements/ip/ipprint.cc:333:	sa << p->timestamp_anno() << ": ";
elements/ip/ipprint.cc:341:    if (p->network_length() < (int) sizeof(click_ip))
elements/ip/ipprint.cc:344:	const click_ip *iph = p->ip_header();
elements/ip/ipprint.cc:347:	int transport_length = p->transport_length();
elements/ip/ipprint.cc:367:	    sa << IPAddress(iph->ip_src) << " > " << IPAddress(iph->ip_dst) << ": ip-proto-" << (int)iph->ip_p;
elements/ip/ipprint.cc:380:		    data = p->transport_header() + (p->tcp_header()->th_off << 2);
elements/ip/ipprint.cc:382:		    data = p->transport_header() + sizeof(click_udp);
elements/ip/ipprint.cc:384:		    data = p->transport_header();
elements/ip/ipprint.cc:386:		data = p->data();
elements/ip/ipprint.cc:389:	    if (data >= p->end_data())
elements/ip/ipprint.cc:391:	    else if (bytes < 0 || (int) (p->end_data() - data) < bytes)
elements/ip/ipprint.cc:392:		bytes = p->end_data() - data;
elements/ip/rangeiplookup.cc:72:    int port = lookup_route(p->dst_ip_anno(), gw);
elements/ip/rangeiplookup.cc:77:    int port1 = _helper.lookup_route(p->dst_ip_anno(), gw1);
elements/ip/rangeiplookup.cc:84:            p->set_dst_ip_anno(gw);
elements/ip/rangeiplookup.cc:87:        p->kill();
elements/ip/ipnameinfo.cc:66:    { "timestamp-reply", ICMP_TSTAMPREPLY },
elements/ip/ipnameinfo.cc:119:    { "ftp-data", 20 },
elements/ip/ipnameinfo.cc:135:    { "snmp-trap", 162 },
elements/ip/ipnameinfo.cc:188:	    uint32_t proto = p->p_proto;
elements/ip/ipnameinfo.cc:189:	    _db->define(p->p_name, &proto, 4);
elements/ip/ipnameinfo.cc:190:	    for (const char **a = (const char **) p->p_aliases; a && *a; a++)
elements/ip/ipfragmenter.cc:103:    click_ip *ip = p->ip_header();
elements/ip/ipfragmenter.cc:107:    if (ip->ip_off & htons(IP_DF)) {
elements/ip/ipfragmenter.cc:108:	ip->ip_id = click_random();
elements/ip/ipfragmenter.cc:109:	ip->ip_off &= ~htons(IP_DF);
elements/ip/ipfragmenter.cc:111:    bool had_mf = (ip->ip_off & htons(IP_MF)) != 0;
elements/ip/ipfragmenter.cc:112:    ip->ip_len = htons(hlen + first_dlen);
elements/ip/ipfragmenter.cc:113:    ip->ip_off |= htons(IP_MF);
elements/ip/ipfragmenter.cc:114:    ip->ip_sum = 0;
elements/ip/ipfragmenter.cc:115:    ip->ip_sum = click_in_cksum((const unsigned char *)ip, hlen);
elements/ip/ipfragmenter.cc:116:    Packet *first_fragment = p->clone();
elements/ip/ipfragmenter.cc:117:    first_fragment->take(p->length() - p->network_header_offset() - hlen - first_dlen);
elements/ip/ipfragmenter.cc:137:	    memcpy(q->transport_header(), p->transport_header() + off, out_dlen);
elements/ip/ipfragmenter.cc:139:	    qip->ip_hl = out_hlen >> 2;
elements/ip/ipfragmenter.cc:140:	    qip->ip_off = htons(ntohs(ip->ip_off) + (off >> 3));
elements/ip/ipfragmenter.cc:142:		qip->ip_off &= ~htons(IP_MF);
elements/ip/ipfragmenter.cc:143:	    qip->ip_len = htons(out_hlen + out_dlen);
elements/ip/ipfragmenter.cc:144:	    qip->ip_sum = 0;
elements/ip/ipfragmenter.cc:145:	    qip->ip_sum = click_in_cksum((const unsigned char *)qip, out_hlen);
elements/ip/ipfragmenter.cc:156:    p->kill();
elements/ip/ipfragmenter.cc:162:    if (p->network_length() <= (int) _mtu)
elements/ip/setipchecksum.cc:39:	if (!p->has_network_header())
elements/ip/setipchecksum.cc:41:	plen = p->network_length();
elements/ip/setipchecksum.cc:44:	ip = p->ip_header();
elements/ip/setipchecksum.cc:45:	hlen = ip->ip_hl << 2;
elements/ip/setipchecksum.cc:49:	ip->ip_sum = 0;
elements/ip/setipchecksum.cc:50:	ip->ip_sum = click_in_cksum((unsigned char *)ip, hlen);
elements/ip/setipchecksum.cc:55:	p->kill();
elements/ip/ripsend.cc:62:  memset(p->data(), '\0', p->length());
elements/ip/ripsend.cc:65:  click_ip *ipp = reinterpret_cast<click_ip *>(p->data());
elements/ip/ripsend.cc:66:  ipp->ip_len = htons(p->length() - sizeof(*ipp));
elements/ip/ripsend.cc:67:  ipp->ip_p = IPPROTO_UDP;
elements/ip/ripsend.cc:68:  ipp->ip_src = _src.in_addr();
elements/ip/ripsend.cc:69:  ipp->ip_dst = _dst.in_addr();
elements/ip/ripsend.cc:82:  udpp->uh_sport = htons(520);
elements/ip/ripsend.cc:83:  udpp->uh_dport = htons(520);
elements/ip/ripsend.cc:84:  udpp->uh_ulen = htons(p->length() - sizeof(*ipp));
elements/ip/ripsend.cc:85:  udpp->uh_sum = click_in_cksum(p->data(), p->length());
elements/ip/ripsend.cc:88:  ipp->ip_len = htons(p->length());
elements/ip/ripsend.cc:89:  ipp->ip_hl = sizeof(click_ip) >> 2;
elements/ip/ripsend.cc:90:  ipp->ip_v = 4;
elements/ip/ripsend.cc:91:  ipp->ip_ttl = 200;
elements/ip/ripsend.cc:92:  ipp->ip_sum = click_in_cksum((unsigned char *) ipp, sizeof(*ipp));
elements/ip/ripsend.cc:94:  p->set_ip_header(ipp, sizeof(click_ip));
elements/ip/ipprint.hh:20:Prints out IP packets in a human-readable tcpdump-like format, preceded by
elements/ip/decipttl.cc:36:    WritablePacket *q = p->uniqueify();
elements/ip/decipttl.cc:42:    if (unlikely(ip->ip_ttl <= 1)) {
elements/ip/decipttl.cc:48:	--ip->ip_ttl;
elements/ip/decipttl.cc:57:	unsigned long sum = (~ntohs(ip->ip_sum) & 0xFFFF) + 0xFEFF;
elements/ip/decipttl.cc:58:	ip->ip_sum = ~htons(sum + (sum >> 16));
elements/ip/storeipaddress.cc:58:    IPAddress ipa = (_use_address ? _address : p->dst_ip_anno());
elements/ip/storeipaddress.cc:59:    if ((ipa || _use_address) && _offset + 4 <= p->length()) {
elements/ip/storeipaddress.cc:60:	if (WritablePacket *q = p->uniqueify()) {
elements/ip/storeipaddress.cc:66:    } else if (_offset >= (unsigned) -16 && p->has_network_header()
elements/ip/storeipaddress.cc:67:	       && p->ip_header_length() >= sizeof(click_ip)) {
elements/ip/storeipaddress.cc:70:	if (WritablePacket *q = p->uniqueify()) {
elements/ip/directiplookup.cc:518:    int port = lookup_route(p->dst_ip_anno(), gw);
elements/ip/directiplookup.cc:522:            p->set_dst_ip_anno(gw);
elements/ip/directiplookup.cc:525:        p->kill();
elements/ip/lookupiproutemp.cc:100:  IPAddress a = p->dst_ip_anno();
elements/ip/lookupiproutemp.cc:113:	p->set_dst_ip_anno(e->_last_gw_1);
elements/ip/lookupiproutemp.cc:119:	p->set_dst_ip_anno(e->_last_gw_2);
elements/ip/lookupiproutemp.cc:133:      p->set_dst_ip_anno(gw);
elements/ip/lookupiproutemp.cc:137:    p->kill();
elements/ip/ipoutputcombo.cc:64:  assert(p->has_network_header());
elements/ip/ipoutputcombo.cc:65:  click_ip *ip = p->ip_header();
elements/ip/ipoutputcombo.cc:66:  unsigned hlen = (ip->ip_hl << 2);
elements/ip/ipoutputcombo.cc:69:    uint8_t *woa = p->network_header();
elements/ip/ipoutputcombo.cc:70:    int hlen = p->network_header_length();
elements/ip/ipoutputcombo.cc:174:    ip->ip_src = _my_ip;
elements/ip/ipoutputcombo.cc:180:    ip->ip_sum = 0;
elements/ip/ipoutputcombo.cc:181:    ip->ip_sum = click_in_cksum(p->data(), hlen);
elements/ip/ipoutputcombo.cc:185:  if (ip->ip_ttl <= 1) {
elements/ip/ipoutputcombo.cc:189:    ip->ip_ttl--;
elements/ip/ipoutputcombo.cc:192:    unsigned long sum = (~ntohs(ip->ip_sum) & 0xFFFF) + 0xFEFF;
elements/ip/ipoutputcombo.cc:193:    ip->ip_sum = ~htons(sum + (sum >> 16));
elements/ip/ipoutputcombo.cc:197:  if (p->length() > _mtu) {
elements/ip/markipheader.cc:44:  const click_ip *ip = reinterpret_cast<const click_ip *>(p->data() + _offset);
elements/ip/markipheader.cc:45:  p->set_ip_header(ip, ip->ip_hl << 2);
elements/ip/iproutetable.cc:153:    int port = lookup_route(p->dst_ip_anno(), gw);
elements/ip/iproutetable.cc:157:	    p->set_dst_ip_anno(gw);
elements/ip/iproutetable.cc:162:	    click_chatter("IPRouteTable: no route for %s", p->dst_ip_anno().unparse().c_str());
elements/ip/iproutetable.cc:163:	p->kill();
elements/ip/rfc2507d.cc:71:  if(p->length() < 2)
elements/ip/rfc2507d.cc:74:  if (p->data()[0] == PT_OTHER) {
elements/ip/rfc2507d.cc:75:    q = Packet::make(p->length() - 1);
elements/ip/rfc2507d.cc:76:    memcpy(q->data(), p->data() + 1, p->length() - 1);
elements/ip/rfc2507d.cc:77:  } else if (p->data()[0] == PT_FULL_HEADER) {
elements/ip/rfc2507d.cc:79:    int cid = p->data()[1] & 0xff;
elements/ip/rfc2507d.cc:83:    memcpy(&(ctx->_ip), p->data() + 2, sizeof(click_ip));
elements/ip/rfc2507d.cc:84:    memcpy(&(ctx->_tcp), p->data() + 2 + sizeof(click_ip),
elements/ip/rfc2507d.cc:86:    q = Packet::make(p->length() - 2);
elements/ip/rfc2507d.cc:87:    memcpy(q->data(), p->data() + 2, p->length() - 2);
elements/ip/rfc2507d.cc:88:  } else if (p->data()[0] == PT_COMPRESSED_TCP) {
elements/ip/rfc2507d.cc:89:    int cid = p->data()[1] & 0xff;
elements/ip/rfc2507d.cc:94:    int flags = p->data()[2];
elements/ip/rfc2507d.cc:95:    memcpy(&(ctx->_tcp.th_sum), p->data() + 3, 2);
elements/ip/rfc2507d.cc:96:    const u_char *in = p->data() + 5;
elements/ip/rfc2507d.cc:128:    int len = p->length() - (in - p->data());
elements/ip/rfc2507d.cc:142:           p->length() - (in - p->data()));
elements/ip/rfc2507d.cc:163:      int hlen = ipp->ip_hl << 2;
elements/ip/rfc2507d.cc:169:      int len = ntohs(ipp->ip_len);
elements/ip/rfc2507d.cc:172:      ipp->ip_sum = htons(len - sizeof(click_ip));
elements/ip/rfc2507d.cc:182:  p->kill();
elements/ip/truncateippayload.cc:57:    const click_ip *iph = p->ip_header();
elements/ip/truncateippayload.cc:60:    if (!p->has_network_header()) {
elements/ip/truncateippayload.cc:61:	if (p->length() <= nbytes)
elements/ip/truncateippayload.cc:63:	nbytes = p->length() - nbytes;
elements/ip/truncateippayload.cc:70:	if ((_nbytes & 1) && p->network_length() >= 10)
elements/ip/truncateippayload.cc:73:		if (p->transport_length() >= 12
elements/ip/truncateippayload.cc:74:		    && p->tcp_header()->th_off >= (sizeof(click_tcp) >> 2))
elements/ip/truncateippayload.cc:75:		    nbytes += p->tcp_header()->th_off << 2;
elements/ip/truncateippayload.cc:83:		if (p->transport_length() >= 8)
elements/ip/truncateippayload.cc:84:		    nbytes += click_icmp_hl(p->icmp_header()->icmp_type);
elements/ip/truncateippayload.cc:89:    if (p->network_length() <= (int) nbytes)
elements/ip/truncateippayload.cc:91:    nbytes = p->network_length() - nbytes;
elements/ip/truncateippayload.cc:96:    p->take(nbytes);
elements/ip/ipgwoptions.cc:54:  const uint8_t *oa = p->network_header();
elements/ip/ipgwoptions.cc:55:  int hlen = p->network_header_length();
elements/ip/ipgwoptions.cc:82:      if (!(wp = p->uniqueify()))
elements/ip/ipgwoptions.cc:84:      oa = wp->network_header(); // may have changed due to packet copy
elements/ip/ipgwoptions.cc:86:    uint8_t *woa = wp->network_header();
elements/ip/ipgwoptions.cc:159:    click_ip *iph = wp->ip_header();
elements/ip/ipgwoptions.cc:161:    iph->ip_sum = click_in_cksum(p->network_header(), hlen);
elements/ip/ipgwoptions.cc:176:  assert(p->has_network_header());
elements/ip/ipgwoptions.cc:177:  const click_ip *ip = p->ip_header();
elements/ip/ipgwoptions.cc:178:  unsigned hlen = ip->ip_hl << 2;
elements/ip/lineariplookup.cc:216:    IPAddress a = p->dst_ip_anno();
elements/ip/lineariplookup.cc:236:	p->kill();
elements/ip/lineariplookup.cc:242:	p->set_dst_ip_anno(e.gw);
elements/ip/siphmapper.cc:89:      p->use();
elements/ip/siphmapper.cc:128:  const click_ip *iph = p->ip_header();
elements/ip/markipce.cc:43:  const click_ip *iph = p->ip_header();
elements/ip/markipce.cc:45:  if (!p->has_network_header() || (iph->ip_tos & IP_ECNMASK) == IP_ECN_NOT_ECT) {
elements/ip/markipce.cc:46:    p->kill();
elements/ip/markipce.cc:51:    WritablePacket *q = p->uniqueify();
elements/ip/ipfilter.cc:1208:  const unsigned char *neth_data = p->network_header();
elements/ip/ipfilter.cc:1209:  const unsigned char *transph_data = p->transport_header();
elements/ip/ipfilter.cc:1210:  int packet_length = p->length() + TRANSP_FAKE_OFFSET - p->transport_header_offset();
elements/ip/ipfilter.cc:1273:  const unsigned char *neth_data = p->network_header();
elements/ip/ipfilter.cc:1274:  const unsigned char *transph_data = p->transport_header();
elements/ip/ipfilter.cc:1281:  } else if (p->length() + TRANSP_FAKE_OFFSET - p->transport_header_offset() < _safe_length) {
elements/ip/setrandipaddress.cc:78:  p->set_dst_ip_anno(ipa);
elements/ip/setipaddress.cc:43:  p->set_dst_ip_anno(_ip);
elements/ip/ipratemon.hh:329:  const click_ip *ip = p->ip_header();
elements/ip/ipratemon.hh:330:  int val = _count_packets ? 1 : ntohs(ip->ip_len);
elements/ip/ipratemon.hh:333:    update(ip->ip_src.s_addr, val, p, true, update_ewma);
elements/ip/ipratemon.hh:335:    update(ip->ip_dst.s_addr, val, p, false, update_ewma);
elements/ip/rripmapper.cc:57:      p->use();
elements/ip/fixipsrc.cc:52:  click_ip *ip = p->ip_header();
elements/ip/fixipsrc.cc:56:                ip->ip_src.s_addr,
elements/ip/fixipsrc.cc:59:  ip->ip_src = _my_ip;
elements/ip/fixipsrc.cc:60:  int hlen = ip->ip_hl << 2;
elements/ip/fixipsrc.cc:61:  ip->ip_sum = 0;
elements/ip/fixipsrc.cc:62:  ip->ip_sum = click_in_cksum((unsigned char *)ip, hlen);
elements/ip/fixipsrc.cc:69:  if (FIX_IP_SRC_ANNO(p) && p->has_network_header())
elements/ip/unstripipheader.cc:34:    assert(p->network_header());
elements/ip/unstripipheader.cc:35:    ptrdiff_t offset = p->network_header() - p->data();
elements/ip/unstripipheader.cc:37:	p = p->push(-offset);	// should never create a new packet
elements/ip/iprwpatterns.cc:41:      return rwp->configure(conf, errh);
elements/ip/iprwpatterns.cc:57:      p->use();
elements/ip/iprwpatterns.cc:78:      int x = rwp->_name_map.get(name);
elements/ip/iprwpatterns.cc:80:	return rwp->_patterns[x];
elements/ip/ipencap.cc:128:    click_update_in_cksum(&ip->ip_sum, 0, ((uint16_t *) ip)[off/2]);
elements/ip/ipencap.cc:132:    click_update_in_cksum(&ip->ip_sum, 0, u[off]*256 + u[off+1]);
elements/ip/ipencap.cc:134:    click_update_in_cksum(&ip->ip_sum, 0, u[off] + u[off+1]*256);
elements/ip/ipencap.cc:145:  click_ip *ip = reinterpret_cast<click_ip *>(p->data());
elements/ip/ipencap.cc:147:  if (ip->ip_len) {		// use_dst_anno
elements/ip/ipencap.cc:148:      ip->ip_dst = p->dst_ip_anno();
elements/ip/ipencap.cc:152:      p->set_dst_ip_anno(IPAddress(ip->ip_dst));
elements/ip/ipencap.cc:153:  ip->ip_len = htons(p->length());
elements/ip/ipencap.cc:154:  ip->ip_id = htons(_id.fetch_and_add(1));
elements/ip/ipencap.cc:158:  p->set_ip_header(ip, sizeof(click_ip));
elements/ip/stripipheader.cc:34:    p->pull(p->transport_header_offset());
elements/ip/ipmirror.cc:39:  click_ip *iph = p->ip_header();
elements/ip/ipmirror.cc:45:  if ((iph->ip_p == IP_PROTO_TCP || iph->ip_p == IP_PROTO_UDP) && IP_FIRSTFRAG(iph) && (int)p->length() >= p->transport_header_offset() + 8) {
elements/ip/ipmirror.cc:46:    click_udp *udph = p->udp_header();
elements/ip/ipmirror.cc:51:      click_tcp *tcph = p->tcp_header();
elements/tcpudp/statelesstcpresp.cc:38:    if (endo > p->end_data())
elements/tcpudp/statelesstcpresp.cc:39:	endo = p->end_data();
elements/tcpudp/statelesstcpresp.cc:61:    const click_ip *iph = p->ip_header();
elements/tcpudp/statelesstcpresp.cc:62:    if (!p->has_network_header()
elements/tcpudp/statelesstcpresp.cc:64:	|| p->transport_length() < sizeof(click_tcp)) {
elements/tcpudp/statelesstcpresp.cc:69:    const click_tcp *tcph = p->tcp_header();
elements/tcpudp/statelesstcpresp.cc:74:	p->kill();
elements/tcpudp/statelesstcpresp.cc:83:	p->kill();
elements/tcpudp/statelesstcpresp.cc:107:    nip->ip_v = 4;
elements/tcpudp/statelesstcpresp.cc:108:    nip->ip_hl = sizeof(click_ip) >> 2;
elements/tcpudp/statelesstcpresp.cc:109:    nip->ip_tos = 0;
elements/tcpudp/statelesstcpresp.cc:110:    nip->ip_id = htons(_id);
elements/tcpudp/statelesstcpresp.cc:112:    nip->ip_off = 0;
elements/tcpudp/statelesstcpresp.cc:113:    nip->ip_ttl = 200;
elements/tcpudp/statelesstcpresp.cc:114:    nip->ip_p = IP_PROTO_TCP;
elements/tcpudp/statelesstcpresp.cc:115:    nip->ip_sum = 0;
elements/tcpudp/statelesstcpresp.cc:116:    nip->ip_src = ip->ip_dst;
elements/tcpudp/statelesstcpresp.cc:117:    nip->ip_dst = ip->ip_src;
elements/tcpudp/statelesstcpresp.cc:120:    ntcp->th_sport = tcp->th_dport;
elements/tcpudp/statelesstcpresp.cc:121:    ntcp->th_dport = tcp->th_sport;
elements/tcpudp/statelesstcpresp.cc:122:    ntcp->th_seq = ntohl(ackno);
elements/tcpudp/statelesstcpresp.cc:123:    ntcp->th_ack = tcp->th_seq;
elements/tcpudp/statelesstcpresp.cc:124:    ntcp->th_flags2 = 0;
elements/tcpudp/statelesstcpresp.cc:125:    ntcp->th_off = (ntcp_hl >> 2);
elements/tcpudp/statelesstcpresp.cc:126:    ntcp->th_flags = (tcph->th_flags & TH_SYN ? TH_SYN | TH_ACK : TH_ACK);
elements/tcpudp/statelesstcpresp.cc:128:	ntcp->th_flags |= TH_FIN;
elements/tcpudp/statelesstcpresp.cc:129:    ntcp->th_win = 0xFFFF;
elements/tcpudp/statelesstcpresp.cc:130:    ntcp->th_sum = 0;
elements/tcpudp/statelesstcpresp.cc:131:    ntcp->th_urp = 0;
elements/tcpudp/statelesstcpresp.cc:148:    nip->ip_len = htons(len);
elements/tcpudp/statelesstcpresp.cc:149:    nip->ip_sum = click_in_cksum(nip, nip->ip_hl << 2);
elements/tcpudp/statelesstcpresp.cc:151:    ntcp->th_sum = click_in_cksum_pseudohdr(sum1, nip, len);
elements/tcpudp/statelesstcpresp.cc:153:    p->kill();
elements/tcpudp/setudpchecksum.cc:44:    click_ip *iph = p->ip_header();
elements/tcpudp/setudpchecksum.cc:45:    click_udp *udph = p->udp_header();
elements/tcpudp/setudpchecksum.cc:48:	|| p->transport_length() < (int) sizeof(click_udp)
elements/tcpudp/setudpchecksum.cc:50:	    p->transport_length() < len)) {
elements/tcpudp/udpipencap.cc:84:  click_ip *ip = reinterpret_cast<click_ip *>(p->data());
elements/tcpudp/udpipencap.cc:88:  ip->ip_v = 4;
elements/tcpudp/udpipencap.cc:89:  ip->ip_hl = sizeof(click_ip) >> 2;
elements/tcpudp/udpipencap.cc:90:  ip->ip_len = htons(p->length());
elements/tcpudp/udpipencap.cc:91:  ip->ip_id = htons(_id.fetch_and_add(1));
elements/tcpudp/udpipencap.cc:92:  ip->ip_p = IP_PROTO_UDP;
elements/tcpudp/udpipencap.cc:93:  ip->ip_src = _saddr;
elements/tcpudp/udpipencap.cc:95:      ip->ip_dst = p->dst_ip_anno();
elements/tcpudp/udpipencap.cc:97:      ip->ip_dst = _daddr;
elements/tcpudp/udpipencap.cc:98:      p->set_dst_ip_anno(IPAddress(_daddr));
elements/tcpudp/udpipencap.cc:100:  ip->ip_tos = 0;
elements/tcpudp/udpipencap.cc:101:  ip->ip_off = 0;
elements/tcpudp/udpipencap.cc:102:  ip->ip_ttl = 250;
elements/tcpudp/udpipencap.cc:104:  ip->ip_sum = 0;
elements/tcpudp/udpipencap.cc:107:    ip->ip_sum = ip_fast_csum((unsigned char *)ip, sizeof(click_ip) >> 2);
elements/tcpudp/udpipencap.cc:109:    ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/tcpudp/udpipencap.cc:111:  ip->ip_sum = ip_fast_csum((unsigned char *)ip, sizeof(click_ip) >> 2);
elements/tcpudp/udpipencap.cc:113:  ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/tcpudp/udpipencap.cc:116:  p->set_ip_header(ip, sizeof(click_ip));
elements/tcpudp/udpipencap.cc:119:  udp->uh_sport = _sport;
elements/tcpudp/udpipencap.cc:120:  udp->uh_dport = _dport;
elements/tcpudp/udpipencap.cc:121:  uint16_t len = p->length() - sizeof(click_ip);
elements/tcpudp/udpipencap.cc:122:  udp->uh_ulen = htons(len);
elements/tcpudp/udpipencap.cc:123:  udp->uh_sum = 0;
elements/tcpudp/udpipencap.cc:126:    udp->uh_sum = click_in_cksum_pseudohdr(csum, ip, len);
elements/tcpudp/tcpipsend.cc:85:  ip->ip_v = 4;
elements/tcpudp/tcpipsend.cc:86:  ip->ip_hl = 5;
elements/tcpudp/tcpipsend.cc:87:  ip->ip_tos = 0;
elements/tcpudp/tcpipsend.cc:88:  ip->ip_len = htons(q->length());
elements/tcpudp/tcpipsend.cc:89:  ip->ip_id = htons(0);
elements/tcpudp/tcpipsend.cc:90:  ip->ip_off = htons(IP_DF);
elements/tcpudp/tcpipsend.cc:91:  ip->ip_ttl = 255;
elements/tcpudp/tcpipsend.cc:92:  ip->ip_p = IP_PROTO_TCP;
elements/tcpudp/tcpipsend.cc:93:  ip->ip_sum = 0;
elements/tcpudp/tcpipsend.cc:94:  memcpy((void *) &(ip->ip_src), (void *) &saddr, sizeof(saddr));
elements/tcpudp/tcpipsend.cc:95:  memcpy((void *) &(ip->ip_dst), (void *) &daddr, sizeof(daddr));
elements/tcpudp/tcpipsend.cc:96:  ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/tcpudp/tcpipsend.cc:101:  memcpy((void *) &(tcp->th_sport), (void *) &sport, sizeof(sport));
elements/tcpudp/tcpipsend.cc:102:  memcpy((void *) &(tcp->th_dport), (void *) &dport, sizeof(dport));
elements/tcpudp/tcpipsend.cc:103:  tcp->th_seq = htonl(seqn);
elements/tcpudp/tcpipsend.cc:104:  tcp->th_ack = htonl(ackn);
elements/tcpudp/tcpipsend.cc:105:  tcp->th_off = 5;
elements/tcpudp/tcpipsend.cc:106:  tcp->th_flags = bits;
elements/tcpudp/tcpipsend.cc:107:  tcp->th_win = htons(32120);
elements/tcpudp/tcpipsend.cc:108:  tcp->th_sum = htons(0);
elements/tcpudp/tcpipsend.cc:109:  tcp->th_urp = htons(0);
elements/tcpudp/tcpipsend.cc:113:  tcp->th_sum = click_in_cksum_pseudohdr(csum, ip, sizeof(click_tcp));
elements/tcpudp/snooptcp.cc:196:  _s_cache[entry].packet = p->clone();
elements/tcpudp/snooptcp.cc:269:    p->kill();
elements/tcpudp/snooptcp.cc:278:    p->kill();
elements/tcpudp/snooptcp.cc:283:    p->kill();
elements/tcpudp/snooptcp.cc:292:      p->kill();
elements/tcpudp/snooptcp.cc:360:  const click_ip *iph = p->ip_header();
elements/tcpudp/snooptcp.cc:361:  if (p->length() < 40 || iph->ip_p != IPPROTO_TCP) {
elements/tcpudp/snooptcp.cc:367:  const click_tcp *tcph = p->tcp_header();
elements/tcpudp/snooptcp.cc:369:  int datalen = p->length() - header_len;
elements/tcpudp/snooptcp.cc:476:	if (_cache[i].packet->length() <= p->length()) {
elements/tcpudp/snooptcp.cc:479:	  _cache[i].packet = p->clone();
elements/tcpudp/snooptcp.cc:506:  p->use();
elements/tcpudp/snooptcp.cc:601:      snp->output(2).push(_cache[entry].packet);
elements/tcpudp/settcpchecksum.cc:50:  click_ip *iph = p->ip_header();
elements/tcpudp/settcpchecksum.cc:51:  click_tcp *tcph = p->tcp_header();
elements/tcpudp/settcpchecksum.cc:55:  if (!p->has_transport_header() || plen < sizeof(click_tcp)
elements/tcpudp/settcpchecksum.cc:56:      || plen > (unsigned)p->transport_length())
elements/tcpudp/settcpchecksum.cc:75:  p->kill();
elements/tcpudp/iprewriter.cc:125:      _input_specs[i].u.pattern.p->unuse();
elements/tcpudp/iprewriter.cc:132:  if (!p->allow_napt())
elements/tcpudp/iprewriter.cc:277:  click_ip *iph = p->ip_header();
elements/tcpudp/iprewriter.cc:289:      p->kill();
elements/tcpudp/iprewriter.cc:348:      p->kill();
elements/tcpudp/iprewriter.cc:356:    click_tcp *tcph = p->tcp_header();
elements/tcpudp/iprewriter.cc:399:  for (Map::iterator iter = map->begin(); iter.live(); iter++) {
elements/tcpudp/iprewriter.cc:449:      s += rw->_input_specs[i].u.pattern.p->unparse() + "\n";
elements/tcpudp/checktcpheader.cc:80:    p->kill();
elements/tcpudp/checktcpheader.cc:88:  const click_ip *iph = p->ip_header();
elements/tcpudp/checktcpheader.cc:89:  const click_tcp *tcph = p->tcp_header();
elements/tcpudp/checktcpheader.cc:92:  if (!p->has_network_header() || iph->ip_p != IP_PROTO_TCP)
elements/tcpudp/checktcpheader.cc:99:      || p->length() < len + iph_len + p->network_header_offset())
elements/tcpudp/checkudpheader.cc:79:    p->kill();
elements/tcpudp/checkudpheader.cc:87:  const click_ip *iph = p->ip_header();
elements/tcpudp/checkudpheader.cc:88:  const click_udp *udph = p->udp_header();
elements/tcpudp/checkudpheader.cc:91:  if (!p->has_network_header() || iph->ip_p != IP_PROTO_UDP)
elements/tcpudp/checkudpheader.cc:97:      || p->length() < len + iph_len + p->network_header_offset())
elements/tcpudp/tcprewriter.cc:112:    assert(p->has_network_header());
elements/tcpudp/tcprewriter.cc:113:    click_ip *iph = p->ip_header();
elements/tcpudp/tcprewriter.cc:119:	p->set_dst_ip_anno(_mapto.daddr());
elements/tcpudp/tcprewriter.cc:132:    click_tcp *tcph = p->tcp_header();
elements/tcpudp/tcprewriter.cc:158:	csum_delta += reverse()->apply_sack(tcph, p->transport_length());
elements/tcpudp/tcprewriter.cc:266:      _input_specs[i].u.pattern.p->unuse();
elements/tcpudp/tcprewriter.cc:273:  if (!p->allow_napt())
elements/tcpudp/tcprewriter.cc:356:  click_ip *iph = p->ip_header();
elements/tcpudp/tcprewriter.cc:357:  click_tcp *tcph = p->tcp_header();
elements/tcpudp/tcprewriter.cc:365:      p->kill();
elements/tcpudp/tcprewriter.cc:398:      p->kill();
elements/tcpudp/tcprewriter.cc:433:	    s += rw->_input_specs[i].u.pattern.p->unparse() + "\n";
elements/tcpudp/dynudpipencap.cc:77:  click_ip *ip = reinterpret_cast<click_ip *>(p->data());
elements/tcpudp/dynudpipencap.cc:81:  ip->ip_v = 4;
elements/tcpudp/dynudpipencap.cc:82:  ip->ip_hl = sizeof(click_ip) >> 2;
elements/tcpudp/dynudpipencap.cc:83:  ip->ip_len = htons(p->length());
elements/tcpudp/dynudpipencap.cc:84:  ip->ip_id = htons(_id.fetch_and_add(1));
elements/tcpudp/dynudpipencap.cc:85:  ip->ip_p = IP_PROTO_UDP;
elements/tcpudp/dynudpipencap.cc:86:  ip->ip_src = _saddr;
elements/tcpudp/dynudpipencap.cc:87:  ip->ip_dst = _daddr;
elements/tcpudp/dynudpipencap.cc:88:  ip->ip_tos = 0;
elements/tcpudp/dynudpipencap.cc:89:  ip->ip_off = 0;
elements/tcpudp/dynudpipencap.cc:90:  ip->ip_ttl = 250;
elements/tcpudp/dynudpipencap.cc:92:  ip->ip_sum = 0;
elements/tcpudp/dynudpipencap.cc:95:    ip->ip_sum = ip_fast_csum((unsigned char *)ip, sizeof(click_ip) >> 2);
elements/tcpudp/dynudpipencap.cc:98:  ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/tcpudp/dynudpipencap.cc:103:  p->set_dst_ip_anno(IPAddress(_daddr));
elements/tcpudp/dynudpipencap.cc:104:  p->set_ip_header(ip, sizeof(click_ip));
elements/tcpudp/dynudpipencap.cc:107:  udp->uh_sport = htons(_sport);
elements/tcpudp/dynudpipencap.cc:108:  udp->uh_dport = htons(_dport);
elements/tcpudp/dynudpipencap.cc:109:  unsigned short len = p->length() - sizeof(click_ip);
elements/tcpudp/dynudpipencap.cc:110:  udp->uh_ulen = htons(len);
elements/tcpudp/dynudpipencap.cc:111:  udp->uh_sum = 0;
elements/tcpudp/dynudpipencap.cc:114:    udp->uh_sum = click_in_cksum_pseudohdr(csum, ip, len);
elements/icmp/checkicmpheader.cc:81:    p->kill();
elements/icmp/checkicmpheader.cc:89:  const click_ip *iph = p->ip_header();
elements/icmp/checkicmpheader.cc:91:  const click_icmp *icmph = p->icmp_header();
elements/icmp/checkicmpheader.cc:93:  if (!p->has_network_header() || iph->ip_p != IP_PROTO_ICMP)
elements/icmp/checkicmpheader.cc:96:  icmp_len = p->length() - p->transport_header_offset();
elements/icmp/icmpsendpings.cc:121:    nip->ip_v = 4;
elements/icmp/icmpsendpings.cc:122:    nip->ip_hl = sizeof(click_ip) >> 2;
elements/icmp/icmpsendpings.cc:123:    nip->ip_len = htons(q->length());
elements/icmp/icmpsendpings.cc:125:    nip->ip_id = htons(ip_id);
elements/icmp/icmpsendpings.cc:126:    nip->ip_p = IP_PROTO_ICMP; /* icmp */
elements/icmp/icmpsendpings.cc:127:    nip->ip_ttl = 200;
elements/icmp/icmpsendpings.cc:128:    nip->ip_src = _src;
elements/icmp/icmpsendpings.cc:129:    nip->ip_dst = _dst;
elements/icmp/icmpsendpings.cc:130:    nip->ip_sum = click_in_cksum((unsigned char *)nip, sizeof(click_ip));
elements/icmp/icmpsendpings.cc:133:    icp->icmp_type = ICMP_ECHO;
elements/icmp/icmpsendpings.cc:134:    icp->icmp_code = 0;
elements/icmp/icmpsendpings.cc:135:    icp->icmp_identifier = _icmp_id;
elements/icmp/icmpsendpings.cc:137:    icp->icmp_sequence = ip_id;
elements/icmp/icmpsendpings.cc:139:    icp->icmp_sequence = htons(ip_id);
elements/icmp/icmpsendpings.cc:142:    icp->icmp_cksum = click_in_cksum((const unsigned char *)icp, sizeof(click_icmp_sequenced) + _data.length());
elements/icmp/icmpsendpings.cc:149:	_receiver->send_timestamp[icp->icmp_sequence] = q->timestamp_anno();
elements/icmp/icmpsendpings.cc:177:    const click_ip *iph = p->ip_header();
elements/icmp/icmpsendpings.cc:178:    const click_icmp_echo *icmph = reinterpret_cast<const click_icmp_echo *>(p->icmp_header());
elements/icmp/icmpsendpings.cc:179:    if (p->has_network_header() && iph->ip_p == IP_PROTO_ICMP
elements/icmp/icmpsendpings.cc:180:	&& p->transport_length() >= (int)sizeof(click_icmp_echo)
elements/icmp/icmpsendpings.cc:194:	    if (p->timestamp_anno()) {
elements/icmp/icmpsendpings.cc:195:		Timestamp diff = p->timestamp_anno() - *send_ts;
elements/icmp/icmpsendpings.cc:218:    p->kill();
elements/icmp/icmppingrewriter.cc:154:  in_map->initialize(inf, outf, false, out_map);
elements/icmp/icmppingrewriter.cc:155:  out_map->initialize(outf.reverse(), inf.reverse(), true, in_map);
elements/icmp/icmppingrewriter.cc:161:  assert(p->has_network_header());
elements/icmp/icmppingrewriter.cc:162:  click_ip *iph = p->ip_header();
elements/icmp/icmppingrewriter.cc:168:    p->set_dst_ip_anno(_mapto.daddr());
elements/icmp/icmppingrewriter.cc:175:  click_icmp_echo *icmph = reinterpret_cast<click_icmp_echo *>(p->icmp_header());
elements/icmp/icmppingrewriter.cc:191:    icmph->icmp_cksum = click_in_cksum((const unsigned char *)icmph, p->length() - p->transport_header_offset());
elements/icmp/icmppingrewriter.cc:266:  click_ip *iph = p->ip_header();
elements/icmp/icmppingrewriter.cc:269:  click_icmp_echo *icmph = reinterpret_cast<click_icmp_echo *>(p->icmp_header());
elements/icmp/icmppingrewriter.cc:278:    p->kill();
elements/icmp/icmppingrewriter.cc:283:  Mapping *m = map->get(flow);
elements/icmp/icmppingrewriter.cc:294:      p->kill();
elements/icmp/icmprewriter.cc:77:    click_ip *iph = p->ip_header();
elements/icmp/icmprewriter.cc:78:    click_icmp *icmph = p->icmp_header();
elements/icmp/icmprewriter.cc:83:	&& reinterpret_cast<uint8_t *>(embedded_udph + 1) <= p->end_data()
elements/icmp/icmprewriter.cc:87:	     && reinterpret_cast<uint8_t *>(embedded_udph) + 18 <= p->end_data())
elements/icmp/icmprewriter.cc:98:	    p->set_dst_ip_anno(new_flow.saddr());
elements/icmp/icmprewriter.cc:131:    click_ip *iph = p->ip_header();
elements/icmp/icmprewriter.cc:132:    click_icmp *icmph = p->icmp_header();
elements/icmp/icmprewriter.cc:144:	    p->set_dst_ip_anno(new_flow.saddr());
elements/icmp/icmprewriter.cc:172:  else if (p->ip_header()->ip_p != IP_PROTO_ICMP) {
elements/icmp/icmprewriter.cc:173:    p->kill();
elements/icmp/icmprewriter.cc:177:  click_icmp *icmph = p->icmp_header();
elements/icmp/icmprewriter.cc:188:     if (p->transport_length() < (int)(sizeof(click_icmp) + hlen + 8)
elements/icmp/icmprewriter.cc:235:    p->kill();
elements/icmp/icmppingencap.cc:68:    if (WritablePacket *q = p->push(sizeof(click_ip) + sizeof(struct click_icmp_echo))) {
elements/icmp/icmppingencap.cc:70:	ip->ip_v = 4;
elements/icmp/icmppingencap.cc:71:	ip->ip_hl = sizeof(click_ip) >> 2;
elements/icmp/icmppingencap.cc:72:	ip->ip_tos = 0;
elements/icmp/icmppingencap.cc:73:	ip->ip_len = htons(q->length());
elements/icmp/icmppingencap.cc:74:	ip->ip_id = htons(_ip_id);
elements/icmp/icmppingencap.cc:75:	ip->ip_off = 0;
elements/icmp/icmppingencap.cc:76:	ip->ip_ttl = 255;
elements/icmp/icmppingencap.cc:77:	ip->ip_p = IP_PROTO_ICMP; /* icmp */
elements/icmp/icmppingencap.cc:78:	ip->ip_sum = 0;
elements/icmp/icmppingencap.cc:79:	ip->ip_src = _src;
elements/icmp/icmppingencap.cc:80:	ip->ip_dst = _dst;
elements/icmp/icmppingencap.cc:83:	icmp->icmp_type = ICMP_ECHO;
elements/icmp/icmppingencap.cc:84:	icmp->icmp_code = 0;
elements/icmp/icmppingencap.cc:85:	icmp->icmp_cksum = 0;
elements/icmp/icmppingencap.cc:87:	icmp->icmp_identifier = _icmp_id;
elements/icmp/icmppingencap.cc:88:	icmp->icmp_sequence = _ip_id;
elements/icmp/icmppingencap.cc:90:	icmp->icmp_identifier = htons(_icmp_id);
elements/icmp/icmppingencap.cc:91:	icmp->icmp_sequence = htons(_ip_id);
elements/icmp/icmppingencap.cc:96:	    ip->ip_sum = ip_fast_csum((unsigned char *)ip, sizeof(click_ip) >> 2);
elements/icmp/icmppingencap.cc:98:	    ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/icmp/icmppingencap.cc:100:	ip->ip_sum = ip_fast_csum((unsigned char *)ip, sizeof(click_ip) >> 2);
elements/icmp/icmppingencap.cc:102:	ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/icmp/icmppingencap.cc:104:	icmp->icmp_cksum = click_in_cksum((const unsigned char *)icmp, q->length() - sizeof(click_ip));
elements/icmp/icmperror.cc:164:  const click_ip *ipp = p->ip_header();
elements/icmp/icmperror.cc:171:  if (!p->has_network_header())
elements/icmp/icmperror.cc:174:  hlen = ipp->ip_hl << 2;
elements/icmp/icmperror.cc:179:  if(ipp->ip_p == IP_PROTO_ICMP) {
elements/icmp/icmperror.cc:180:    const click_icmp *icmph = p->icmp_header();
elements/icmp/icmperror.cc:181:    if(hlen + 4 > p->length() || is_error_type(icmph->icmp_type))
elements/icmp/icmperror.cc:186:  if(!unicast(ipp->ip_dst))
elements/icmp/icmperror.cc:190:  if (p->packet_type_anno() == Packet::BROADCAST || p->packet_type_anno() == Packet::MULTICAST)
elements/icmp/icmperror.cc:194:  if(!valid_source(ipp->ip_src))
elements/icmp/icmperror.cc:222:  nip->ip_v = 4;
elements/icmp/icmperror.cc:223:  nip->ip_tos = 0;		// XXX should be same as incoming datagram?
elements/icmp/icmperror.cc:224:  nip->ip_id = htons(id++);
elements/icmp/icmperror.cc:225:  nip->ip_off = 0;
elements/icmp/icmperror.cc:226:  nip->ip_ttl = 200;
elements/icmp/icmperror.cc:227:  nip->ip_p = IP_PROTO_ICMP;
elements/icmp/icmperror.cc:228:  nip->ip_sum = 0;
elements/icmp/icmperror.cc:229:  nip->ip_src = _src_ip.in_addr();
elements/icmp/icmperror.cc:230:  nip->ip_dst = ipp->ip_src;
elements/icmp/icmperror.cc:243:    nip->ip_hl = (sizeof(click_ip) + olen + 3) >> 2;
elements/icmp/icmperror.cc:245:    nip->ip_hl = sizeof(click_ip) >> 2;
elements/icmp/icmperror.cc:246:  q->set_ip_header(nip, nip->ip_hl << 2);
elements/icmp/icmperror.cc:250:  icp->icmp_type = _type;
elements/icmp/icmperror.cc:251:  icp->icmp_code = _code;
elements/icmp/icmperror.cc:252:  icp->icmp_cksum = 0;
elements/icmp/icmperror.cc:253:  icp->padding = 0;
elements/icmp/icmperror.cc:260:    ((click_icmp_redirect *) icp)->icmp_gateway = p->dst_ip_anno();
elements/icmp/icmperror.cc:266:  if ((int)xlen > p->network_length()) {
elements/icmp/icmperror.cc:267:    q->take(xlen - p->network_length());
elements/icmp/icmperror.cc:268:    xlen = p->network_length();
elements/icmp/icmperror.cc:270:  memcpy((uint8_t *)(icp + 1), p->network_header(), xlen);
elements/icmp/icmperror.cc:271:  icp->icmp_cksum = click_in_cksum((unsigned char *)icp, sizeof(click_icmp) + xlen);
elements/icmp/icmperror.cc:274:  nip->ip_len = htons(q->length());
elements/icmp/icmperror.cc:275:  nip->ip_sum = click_in_cksum((unsigned char *)nip, nip->ip_hl << 2);
elements/icmp/icmperror.cc:278:  q->set_dst_ip_anno(IPAddress(nip->ip_dst));
elements/icmp/icmperror.cc:283:  p->kill();
elements/linuxmodule/polldevice.cc:277:	p->timestamp_anno().set_now();
elements/linuxmodule/fastudpflows.cc:85:  udp->uh_sport = (click_random() >> 2) % 0xFFFF;
elements/linuxmodule/fastudpflows.cc:86:  udp->uh_dport = (click_random() >> 2) % 0xFFFF;
elements/linuxmodule/fastudpflows.cc:87:  udp->uh_sum = 0;
elements/linuxmodule/fastudpflows.cc:91:    udp->uh_sum = csum_tcpudp_magic(_sipaddr.s_addr, _dipaddr.s_addr,
elements/linuxmodule/fastudpflows.cc:94:    udp->uh_sum = 0;
elements/linuxmodule/fastudpflows.cc:131:    ip->ip_v = 4;
elements/linuxmodule/fastudpflows.cc:132:    ip->ip_hl = sizeof(click_ip) >> 2;
elements/linuxmodule/fastudpflows.cc:133:    ip->ip_len = htons(_len-14);
elements/linuxmodule/fastudpflows.cc:134:    ip->ip_id = 0;
elements/linuxmodule/fastudpflows.cc:135:    ip->ip_p = IP_PROTO_UDP;
elements/linuxmodule/fastudpflows.cc:136:    ip->ip_src = _sipaddr;
elements/linuxmodule/fastudpflows.cc:137:    ip->ip_dst = _dipaddr;
elements/linuxmodule/fastudpflows.cc:138:    ip->ip_tos = 0;
elements/linuxmodule/fastudpflows.cc:139:    ip->ip_off = 0;
elements/linuxmodule/fastudpflows.cc:140:    ip->ip_ttl = 250;
elements/linuxmodule/fastudpflows.cc:141:    ip->ip_sum = 0;
elements/linuxmodule/fastudpflows.cc:142:    ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/linuxmodule/fastudpflows.cc:147:    udp->uh_sport = (click_random() >> 2) % 0xFFFF;
elements/linuxmodule/fastudpflows.cc:148:    udp->uh_dport = (click_random() >> 2) % 0xFFFF;
elements/linuxmodule/fastudpflows.cc:149:    udp->uh_sum = 0;
elements/linuxmodule/fastudpflows.cc:151:    udp->uh_ulen = htons(len);
elements/linuxmodule/fastudpflows.cc:154:      udp->uh_sum = csum_tcpudp_magic(_sipaddr.s_addr, _dipaddr.s_addr,
elements/linuxmodule/fastudpflows.cc:157:      udp->uh_sum = 0;
elements/linuxmodule/todevice.cc:284:		p->kill();
elements/linuxmodule/todevice.cc:409:    struct sk_buff *skb1 = p->skb();
elements/linuxmodule/todevice.cc:416:    int need_tail = 60 - p->length();
elements/linuxmodule/fromhost.cc:286:	p->kill();
elements/linuxmodule/fromhost.cc:384:	    p->set_timestamp_anno(Timestamp::now());
elements/linuxmodule/fromhost.cc:386:		p->clear_annotations(false);
elements/linuxmodule/fromhost.cc:388:	    fl->_stats.tx_bytes += p->length();
elements/linuxmodule/fromhost.cc:415:	if (_dev->type == ARPHRD_NONE && p->length() >= 1) {
elements/linuxmodule/fromhost.cc:416:	    const click_ip *iph = (const click_ip *) p->data();
elements/linuxmodule/fromhost.cc:420:		    && reinterpret_cast<const uint8_t *>(iph) + (iph->ip_hl << 2) <= p->end_data()) {
elements/linuxmodule/fromhost.cc:421:		    p->set_ip_header(iph, iph->ip_hl << 2);
elements/linuxmodule/fromhost.cc:422:		    p->set_dst_ip_anno(iph->ip_dst);
elements/linuxmodule/fromhost.cc:426:		if (reinterpret_cast<const uint8_t *>(iph) + sizeof(click_ip6) <= p->end_data())
elements/linuxmodule/fromhost.cc:427:		    p->set_ip6_header(reinterpret_cast<const click_ip6 *>(iph));
elements/linuxmodule/tohost.cc:137:    p->clear_annotations(false);
elements/linuxmodule/tohost.cc:139:    struct sk_buff *skb = p->skb();
elements/linuxmodule/tohost.cc:149:	p->kill();
elements/linuxmodule/fastudpsrc.cc:86:  udp->uh_sport = htons(_sport+_incr);
elements/linuxmodule/fastudpsrc.cc:87:  udp->uh_dport = htons(_dport+_incr);
elements/linuxmodule/fastudpsrc.cc:88:  udp->uh_sum = 0;
elements/linuxmodule/fastudpsrc.cc:92:    udp->uh_sum = csum_tcpudp_magic(_sipaddr.s_addr, _dipaddr.s_addr,
elements/linuxmodule/fastudpsrc.cc:95:    udp->uh_sum = 0;
elements/linuxmodule/fastudpsrc.cc:109:  ip->ip_v = 4;
elements/linuxmodule/fastudpsrc.cc:110:  ip->ip_hl = sizeof(click_ip) >> 2;
elements/linuxmodule/fastudpsrc.cc:111:  ip->ip_len = htons(_len-14);
elements/linuxmodule/fastudpsrc.cc:112:  ip->ip_id = 0;
elements/linuxmodule/fastudpsrc.cc:113:  ip->ip_p = IP_PROTO_UDP;
elements/linuxmodule/fastudpsrc.cc:114:  ip->ip_src = _sipaddr;
elements/linuxmodule/fastudpsrc.cc:115:  ip->ip_dst = _dipaddr;
elements/linuxmodule/fastudpsrc.cc:116:  ip->ip_tos = 0;
elements/linuxmodule/fastudpsrc.cc:117:  ip->ip_off = 0;
elements/linuxmodule/fastudpsrc.cc:118:  ip->ip_ttl = 250;
elements/linuxmodule/fastudpsrc.cc:119:  ip->ip_sum = 0;
elements/linuxmodule/fastudpsrc.cc:120:  ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/linuxmodule/fastudpsrc.cc:125:  udp->uh_sport = htons(_sport);
elements/linuxmodule/fastudpsrc.cc:126:  udp->uh_dport = htons(_dport);
elements/linuxmodule/fastudpsrc.cc:127:  udp->uh_sum = 0;
elements/linuxmodule/fastudpsrc.cc:129:  udp->uh_ulen = htons(len);
elements/linuxmodule/fastudpsrc.cc:132:    udp->uh_sum = csum_tcpudp_magic(_sipaddr.s_addr, _dipaddr.s_addr,
elements/linuxmodule/fastudpsrc.cc:135:    udp->uh_sum = 0;
elements/linuxmodule/fromuserdevice.cc:117:    filp->private_data = elem[num];
elements/linuxmodule/fromuserdevice.cc:124:    FromUserDevice *elem = (FromUserDevice*)filp->private_data;
elements/linuxmodule/fromuserdevice.cc:139:    FromUserDevice *elem = (FromUserDevice*)filp->private_data;
elements/linuxmodule/fromuserdevice.cc:168:    err = copy_from_user((char*)p->data(), buf, count);
elements/linuxmodule/fromuserdevice.cc:171:        p->kill();
elements/linuxmodule/fromuserdevice.cc:185:            p->kill();
elements/linuxmodule/fromuserdevice.cc:215:    //click_chatter("%x %x %d %d", ip->ip_src.s_addr, ip->ip_dst.s_addr,
elements/linuxmodule/fromuserdevice.cc:216:    //              ip->ip_v, ip->ip_hl);
elements/linuxmodule/fromuserdevice.cc:271:    FromUserDevice *elem = (FromUserDevice*)filp->private_data;
elements/linuxmodule/fromuserdevice.cc:341:	    p->kill();
elements/linuxmodule/fasttcpflows.cc:90:  tcp->th_sport = sport;
elements/linuxmodule/fasttcpflows.cc:91:  tcp->th_dport = dport;
elements/linuxmodule/fasttcpflows.cc:92:  tcp->th_sum = 0;
elements/linuxmodule/fasttcpflows.cc:95:  tcp->th_sum = csum_tcpudp_magic
elements/linuxmodule/fasttcpflows.cc:100:  tcp->th_sport = sport;
elements/linuxmodule/fasttcpflows.cc:101:  tcp->th_dport = dport;
elements/linuxmodule/fasttcpflows.cc:102:  tcp->th_sum = 0;
elements/linuxmodule/fasttcpflows.cc:105:  tcp->th_sum = csum_tcpudp_magic
elements/linuxmodule/fasttcpflows.cc:110:  tcp->th_sport = sport;
elements/linuxmodule/fasttcpflows.cc:111:  tcp->th_dport = dport;
elements/linuxmodule/fasttcpflows.cc:112:  tcp->th_sum = 0;
elements/linuxmodule/fasttcpflows.cc:115:  tcp->th_sum = csum_tcpudp_magic
elements/linuxmodule/fasttcpflows.cc:174:    ip->ip_v = 4;
elements/linuxmodule/fasttcpflows.cc:175:    ip->ip_hl = sizeof(click_ip) >> 2;
elements/linuxmodule/fasttcpflows.cc:176:    ip->ip_len = htons(_len-14);
elements/linuxmodule/fasttcpflows.cc:177:    ip->ip_id = 0;
elements/linuxmodule/fasttcpflows.cc:178:    ip->ip_p = IP_PROTO_TCP;
elements/linuxmodule/fasttcpflows.cc:179:    ip->ip_src = _sipaddr;
elements/linuxmodule/fasttcpflows.cc:180:    ip->ip_dst = _dipaddr;
elements/linuxmodule/fasttcpflows.cc:181:    ip->ip_tos = 0;
elements/linuxmodule/fasttcpflows.cc:182:    ip->ip_off = 0;
elements/linuxmodule/fasttcpflows.cc:183:    ip->ip_ttl = 250;
elements/linuxmodule/fasttcpflows.cc:184:    ip->ip_sum = 0;
elements/linuxmodule/fasttcpflows.cc:185:    ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/linuxmodule/fasttcpflows.cc:189:    tcp->th_sport = sport;
elements/linuxmodule/fasttcpflows.cc:190:    tcp->th_dport = dport;
elements/linuxmodule/fasttcpflows.cc:191:    tcp->th_seq = click_random();
elements/linuxmodule/fasttcpflows.cc:192:    tcp->th_ack = click_random();
elements/linuxmodule/fasttcpflows.cc:193:    tcp->th_off = sizeof(click_tcp) >> 2;
elements/linuxmodule/fasttcpflows.cc:194:    tcp->th_flags = TH_SYN;
elements/linuxmodule/fasttcpflows.cc:195:    tcp->th_win = 65535;
elements/linuxmodule/fasttcpflows.cc:196:    tcp->th_urp = 0;
elements/linuxmodule/fasttcpflows.cc:197:    tcp->th_sum = 0;
elements/linuxmodule/fasttcpflows.cc:200:    tcp->th_sum = csum_tcpudp_magic(_sipaddr.s_addr, _dipaddr.s_addr,
elements/linuxmodule/fasttcpflows.cc:209:    ip->ip_v = 4;
elements/linuxmodule/fasttcpflows.cc:210:    ip->ip_hl = sizeof(click_ip) >> 2;
elements/linuxmodule/fasttcpflows.cc:211:    ip->ip_len = htons(_len-14);
elements/linuxmodule/fasttcpflows.cc:212:    ip->ip_id = 0;
elements/linuxmodule/fasttcpflows.cc:213:    ip->ip_p = IP_PROTO_TCP;
elements/linuxmodule/fasttcpflows.cc:214:    ip->ip_src = _sipaddr;
elements/linuxmodule/fasttcpflows.cc:215:    ip->ip_dst = _dipaddr;
elements/linuxmodule/fasttcpflows.cc:216:    ip->ip_tos = 0;
elements/linuxmodule/fasttcpflows.cc:217:    ip->ip_off = 0;
elements/linuxmodule/fasttcpflows.cc:218:    ip->ip_ttl = 250;
elements/linuxmodule/fasttcpflows.cc:219:    ip->ip_sum = 0;
elements/linuxmodule/fasttcpflows.cc:220:    ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/linuxmodule/fasttcpflows.cc:224:    tcp->th_sport = sport;
elements/linuxmodule/fasttcpflows.cc:225:    tcp->th_dport = dport;
elements/linuxmodule/fasttcpflows.cc:226:    tcp->th_seq = click_random();
elements/linuxmodule/fasttcpflows.cc:227:    tcp->th_ack = click_random();
elements/linuxmodule/fasttcpflows.cc:228:    tcp->th_off = sizeof(click_tcp) >> 2;
elements/linuxmodule/fasttcpflows.cc:229:    tcp->th_flags = TH_PUSH | TH_ACK;
elements/linuxmodule/fasttcpflows.cc:230:    tcp->th_win = 65535;
elements/linuxmodule/fasttcpflows.cc:231:    tcp->th_urp = 0;
elements/linuxmodule/fasttcpflows.cc:232:    tcp->th_sum = 0;
elements/linuxmodule/fasttcpflows.cc:235:    tcp->th_sum = csum_tcpudp_magic(_sipaddr.s_addr, _dipaddr.s_addr,
elements/linuxmodule/fasttcpflows.cc:244:    ip->ip_v = 4;
elements/linuxmodule/fasttcpflows.cc:245:    ip->ip_hl = sizeof(click_ip) >> 2;
elements/linuxmodule/fasttcpflows.cc:246:    ip->ip_len = htons(_len-14);
elements/linuxmodule/fasttcpflows.cc:247:    ip->ip_id = 0;
elements/linuxmodule/fasttcpflows.cc:248:    ip->ip_p = IP_PROTO_TCP;
elements/linuxmodule/fasttcpflows.cc:249:    ip->ip_src = _sipaddr;
elements/linuxmodule/fasttcpflows.cc:250:    ip->ip_dst = _dipaddr;
elements/linuxmodule/fasttcpflows.cc:251:    ip->ip_tos = 0;
elements/linuxmodule/fasttcpflows.cc:252:    ip->ip_off = 0;
elements/linuxmodule/fasttcpflows.cc:253:    ip->ip_ttl = 250;
elements/linuxmodule/fasttcpflows.cc:254:    ip->ip_sum = 0;
elements/linuxmodule/fasttcpflows.cc:255:    ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/linuxmodule/fasttcpflows.cc:259:    tcp->th_sport = sport;
elements/linuxmodule/fasttcpflows.cc:260:    tcp->th_dport = dport;
elements/linuxmodule/fasttcpflows.cc:261:    tcp->th_seq = click_random();
elements/linuxmodule/fasttcpflows.cc:262:    tcp->th_ack = click_random();
elements/linuxmodule/fasttcpflows.cc:263:    tcp->th_off = sizeof(click_tcp) >> 2;
elements/linuxmodule/fasttcpflows.cc:264:    tcp->th_flags = TH_FIN;
elements/linuxmodule/fasttcpflows.cc:265:    tcp->th_win = 65535;
elements/linuxmodule/fasttcpflows.cc:266:    tcp->th_urp = 0;
elements/linuxmodule/fasttcpflows.cc:267:    tcp->th_sum = 0;
elements/linuxmodule/fasttcpflows.cc:270:    tcp->th_sum = csum_tcpudp_magic(_sipaddr.s_addr, _dipaddr.s_addr,
elements/linuxmodule/touserdevice.cc:103:#define GETELEM(filp)		((ToUserDevice *) ((uintptr_t) filp->private_data & ~(uintptr_t) 1))
elements/linuxmodule/touserdevice.cc:115:    filp->private_data = (void *) elem[num];
elements/linuxmodule/touserdevice.cc:138:	return ((uintptr_t) filp->private_data) & 1;
elements/linuxmodule/touserdevice.cc:142:	filp->private_data = (void *) ((uintptr_t) elem | (int) address);
elements/linuxmodule/touserdevice.cc:151:    int multi = ((uintptr_t) filp->private_data) & 1;
elements/linuxmodule/touserdevice.cc:184:	if (nfetched > 0 && nread + sizeof(int) + p->length() > len)
elements/linuxmodule/touserdevice.cc:195:	    int len = p->length();
elements/linuxmodule/touserdevice.cc:199:		p->kill();
elements/linuxmodule/touserdevice.cc:205:	ssize_t to_copy = p->length();
elements/linuxmodule/touserdevice.cc:208:	if (copy_to_user(buff + nread, p->data(), to_copy)) {
elements/linuxmodule/touserdevice.cc:211:	    p->kill();
elements/linuxmodule/touserdevice.cc:220:	p->kill();
elements/linuxmodule/touserdevice.cc:349:	p->kill();
elements/linuxmodule/fastudpsrcip6.cc:86:  udp->uh_sport = htons(_sport+_incr);
elements/linuxmodule/fastudpsrcip6.cc:87:  udp->uh_dport = htons(_dport+_incr);
elements/linuxmodule/fastudpsrcip6.cc:88:  udp->uh_sum = 0;
elements/linuxmodule/fastudpsrcip6.cc:93:    //udp->uh_sum = csum_tcpudp_magic(_sip6addr.s_addr, _dip6addr.s_addr,
elements/linuxmodule/fastudpsrcip6.cc:95:    udp->uh_sum = htons(in6_fast_cksum(&ip6->ip6_src, &ip6->ip6_dst, ip6->ip6_plen, ip6->ip6_nxt, udp->uh_sum, (unsigned char *)udp, ip6->ip6_plen));
elements/linuxmodule/fastudpsrcip6.cc:97:    udp->uh_sum = 0;
elements/linuxmodule/fastudpsrcip6.cc:122:  udp->uh_sport = htons(_sport);
elements/linuxmodule/fastudpsrcip6.cc:123:  udp->uh_dport = htons(_dport);
elements/linuxmodule/fastudpsrcip6.cc:124:  udp->uh_sum = 0;
elements/linuxmodule/fastudpsrcip6.cc:126:  udp->uh_ulen = htons(len);
elements/linuxmodule/fastudpsrcip6.cc:130:    //udp->uh_sum = csum_tcpudp_magic(_sipaddr.s_addr, _dipaddr.s_addr,
elements/linuxmodule/fastudpsrcip6.cc:132:    udp->uh_sum = htons(in6_fast_cksum(&ip6->ip6_src, &ip6->ip6_dst, ip6->ip6_plen, ip6->ip6_nxt, udp->uh_sum, (unsigned char *)udp, ip6->ip6_plen));
elements/linuxmodule/fastudpsrcip6.cc:135:    udp->uh_sum = 0;
elements/linuxmodule/cpuqueue.cc:70:	p->kill();
elements/exopc/xokwriter.cc:60:  assert(p->length() >= 14);
elements/exopc/xokwriter.cc:63:  int r = ae_eth_send(p->data(), p->length(), cardno);
elements/exopc/xokwriter.cc:68:  p->kill();
elements/etherswitch/debugbridge.cc:45:    reinterpret_cast<const BridgeMessage::wire *>(p->data());
elements/etherswitch/etherswitch.cc:54:      Packet *pp = (sent < n - 2 ? p->clone() : p);
elements/etherswitch/etherswitch.cc:64:    click_ether* e = (click_ether*) p->data();
elements/etherswitch/etherswitch.cc:69:	_table.set(EtherAddress(e->ether_shost), AddrInfo(source, p->timestamp_anno()));
elements/etherswitch/etherswitch.cc:76:		if (p->timestamp_anno() < dst_info.value().stamp + Timestamp(_timeout, 0))
elements/etherswitch/etherswitch.cc:87:    p->kill();
elements/etherswitch/spantree.cc:197:    _input_sup->suppress(i);
elements/etherswitch/spantree.cc:198:    _output_sup->suppress(i);
elements/etherswitch/spantree.cc:201:    _input_sup->allow(i);
elements/etherswitch/spantree.cc:202:    _output_sup->suppress(i);
elements/etherswitch/spantree.cc:205:    _input_sup->allow(i);
elements/etherswitch/spantree.cc:206:    _output_sup->allow(i);
elements/etherswitch/spantree.cc:217:    reinterpret_cast<const BridgeMessage::wire*>(p->data());
elements/etherswitch/spantree.cc:230:  p->kill();
elements/etherswitch/spantree.cc:268:  BridgeMessage::wire* msg = reinterpret_cast<BridgeMessage::wire*>(p->data());
elements/etherswitch/listenetherswitch.cc:38:    const click_ether* e = (const click_ether*) p->data();
elements/etherswitch/listenetherswitch.cc:43:	_table.set(EtherAddress(e->ether_shost), AddrInfo(source, p->timestamp_anno()));
elements/etherswitch/listenetherswitch.cc:50:		if (p->timestamp_anno() < dst_info.value().stamp + Timestamp(_timeout, 0))
elements/etherswitch/listenetherswitch.cc:63:	output(noutputs() - 1).push(p->clone());
elements/wifi/station/associationrequester.cc:92:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/station/associationrequester.cc:106:  uint8_t *ptr = (uint8_t *)  p->data() + sizeof(click_wifi);
elements/wifi/station/associationrequester.cc:173:  p->take(max_len - actual_length);
elements/wifi/station/associationrequester.cc:181:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/station/associationrequester.cc:185:  ptr = (uint8_t *) p->data() + sizeof(struct click_wifi);
elements/wifi/station/associationrequester.cc:270:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/station/associationrequester.cc:271:  uint8_t *ptr = (uint8_t *) p->data() + sizeof(struct click_wifi);
elements/wifi/station/associationrequester.cc:300:  if (p->length() < sizeof(struct click_wifi)) {
elements/wifi/station/associationrequester.cc:303:		  p->length(),
elements/wifi/station/associationrequester.cc:306:    p->kill();
elements/wifi/station/associationrequester.cc:311:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/station/associationrequester.cc:321:    p->kill();
elements/wifi/station/associationrequester.cc:327:    p->kill();
elements/wifi/station/associationrequester.cc:333:    p->kill();
elements/wifi/station/associationrequester.cc:340:  p->kill();
elements/wifi/station/beaconscanner.cc:76:  if (p->length() < sizeof(struct click_wifi)) {
elements/wifi/station/beaconscanner.cc:79:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/station/beaconscanner.cc:96:  ptr = (uint8_t *) p->data() + sizeof(struct click_wifi);
elements/wifi/station/beaconscanner.cc:108:  uint8_t *end  = (uint8_t *) p->data() + p->length();
elements/wifi/station/beaconscanner.cc:169:    ap->_ssid = "";
elements/wifi/station/beaconscanner.cc:174:  ap->_eth = bssid;
elements/wifi/station/beaconscanner.cc:177:    ap->_ssid = ssid;
elements/wifi/station/beaconscanner.cc:179:  ap->_channel = (ds_l) ? ds_l[2] : -1;
elements/wifi/station/beaconscanner.cc:180:  ap->_rssi = ceh->rssi;
elements/wifi/station/beaconscanner.cc:182:  ap->_capability = capability;
elements/wifi/station/beaconscanner.cc:183:  ap->_beacon_int = beacon_int;
elements/wifi/station/beaconscanner.cc:184:  ap->_basic_rates.clear();
elements/wifi/station/beaconscanner.cc:185:  ap->_rates.clear();
elements/wifi/station/beaconscanner.cc:187:  ap->_last_rx.set_now();
elements/wifi/station/beaconscanner.cc:193:	ap->_basic_rates.push_back((int)(rate & WIFI_RATE_VAL));
elements/wifi/station/beaconscanner.cc:195:	ap->_rates.push_back((int)(rate & WIFI_RATE_VAL));
elements/wifi/station/beaconscanner.cc:207:	ap->_basic_rates.push_back((int)(rate & WIFI_RATE_VAL));
elements/wifi/station/beaconscanner.cc:209:	ap->_rates.push_back((int)(rate & WIFI_RATE_VAL));
elements/wifi/station/beacontracker.cc:68:  if (p->length() < sizeof(struct click_wifi)) {
elements/wifi/station/beacontracker.cc:71:		  p->length(),
elements/wifi/station/beacontracker.cc:74:    p->kill();
elements/wifi/station/beacontracker.cc:78:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/station/beacontracker.cc:88:    p->kill();
elements/wifi/station/beacontracker.cc:96:    p->kill();
elements/wifi/station/beacontracker.cc:104:    p->kill();
elements/wifi/station/beacontracker.cc:110:  ptr = (uint8_t *) p->data() + sizeof(struct click_wifi);
elements/wifi/station/beacontracker.cc:123:  b.rx = p->timestamp_anno();
elements/wifi/station/proberequester.cc:79:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/station/proberequester.cc:92:  uint8_t *ptr = (uint8_t *) p->data() + sizeof(struct click_wifi);
elements/wifi/station/proberequester.cc:145:  p->take(max_len - actual_length);
elements/wifi/station/openauthrequester.cc:66:  if (p->length() < sizeof(struct click_wifi)) {
elements/wifi/station/openauthrequester.cc:69:		  p->length(),
elements/wifi/station/openauthrequester.cc:72:    p->kill();
elements/wifi/station/openauthrequester.cc:76:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/station/openauthrequester.cc:86:    p->kill();
elements/wifi/station/openauthrequester.cc:93:    p->kill();
elements/wifi/station/openauthrequester.cc:99:  ptr = (uint8_t *) p->data() + sizeof(struct click_wifi);
elements/wifi/station/openauthrequester.cc:119:    p->kill();
elements/wifi/station/openauthrequester.cc:132:  p->kill();
elements/wifi/station/openauthrequester.cc:151:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/station/openauthrequester.cc:166:  ptr = (uint8_t *) p->data() + sizeof(struct click_wifi);
elements/wifi/prism2decap.cc:53:  u_int32_t *ptr = (u_int32_t *) p->data();
elements/wifi/prism2decap.cc:56:    wlan_ng_prism2_header *ph = (wlan_ng_prism2_header *) p->data();
elements/wifi/prism2decap.cc:66:    p->pull(sizeof(wlan_ng_prism2_header));
elements/wifi/radiotapdecap.cc:122:	struct ieee80211_radiotap_header *th = (struct ieee80211_radiotap_header *) p->data();
elements/wifi/radiotapdecap.cc:124:	if (rt_check_header(th, p->length())) {
elements/wifi/radiotapdecap.cc:137:			     p->take(4);
elements/wifi/radiotapdecap.cc:174:		p->pull(th->it_len);
elements/wifi/radiotapdecap.cc:175:		p->set_mac_header(p->data());  // reset mac-header pointer
elements/wifi/extraencap.cc:52:  WritablePacket *p_out = p->uniqueify();
elements/wifi/extraencap.cc:54:    p->kill();
elements/wifi/printtxfeedback.cc:60:  uint8_t *dst_ptr = (uint8_t *) p->data() + _offset;
elements/wifi/printtxfeedback.cc:71:  sa << " " << p->timestamp_anno();
elements/wifi/wifidefrag.hh:64:	p->kill();
elements/wifi/radiotapencap.cc:76:  WritablePacket *p_out = p->uniqueify();
elements/wifi/radiotapencap.cc:78:    p->kill();
elements/wifi/wififragment.cc:57:  click_wifi *w = (click_wifi *) p->data();
elements/wifi/wififragment.cc:60:      p->length() <= sizeof(click_wifi) + _max_length) {
elements/wifi/wififragment.cc:69:  int num_frags = (p->length() - sizeof(click_wifi))  / _max_length;
elements/wifi/wififragment.cc:70:  int last_len = (p->length() - sizeof(click_wifi))  % _max_length;
elements/wifi/wififragment.cc:91:    memcpy((void *) p_out->data(), p->data(), sizeof(click_wifi));
elements/wifi/wififragment.cc:94:	   p->data() + sizeof(click_wifi) + frag*_max_length,
elements/wifi/wififragment.cc:105:  p->kill();
elements/wifi/wifidecap.cc:56:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/wifidecap.cc:67:  if (p->length() < wifi_header_size + sizeof(struct click_llc)) {
elements/wifi/wifidecap.cc:68:    p->kill();
elements/wifi/wifidecap.cc:73:    p->kill();
elements/wifi/wifidecap.cc:105:      p->kill();
elements/wifi/wifidecap.cc:113:  WritablePacket *p_out = p->uniqueify();
elements/wifi/wepencap.cc:92:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/wepencap.cc:105:  if (!(p = p->push(WIFI_WEP_HEADERSIZE)))
elements/wifi/wepencap.cc:107:  memmove((void *) p->data(), p->data() + WIFI_WEP_HEADERSIZE, sizeof(click_wifi));
elements/wifi/wepencap.cc:108:  u_int8_t *ivp = p->data() + sizeof(click_wifi);
elements/wifi/wepencap.cc:126:  memcpy(rc4key, p->data() + sizeof(click_wifi), WIFI_WEP_IVLEN);
elements/wifi/wepencap.cc:132:		   (p->data() + sizeof(click_wifi) + WIFI_WEP_HEADERSIZE),
elements/wifi/wepencap.cc:133:		   p->length() - (sizeof(click_wifi) + WIFI_WEP_HEADERSIZE));
elements/wifi/wepencap.cc:137:		 p->data() + sizeof(click_wifi) + WIFI_WEP_HEADERSIZE,
elements/wifi/wepencap.cc:138:		 p->data() + sizeof(click_wifi) + WIFI_WEP_HEADERSIZE,
elements/wifi/wepencap.cc:139:		 p->length() - (sizeof(click_wifi) + WIFI_WEP_HEADERSIZE),
elements/wifi/wepencap.cc:143:  p = p->put(WIFI_WEP_CRCLEN);
elements/wifi/wepencap.cc:144:  icv = p->end_data() - WIFI_WEP_CRCLEN;
elements/wifi/printwifi.cc:55:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/printwifi.cc:70:  uint8_t *end  = (uint8_t *) p->data() + p->length();
elements/wifi/printwifi.cc:307:  struct click_wifi *wh = (struct click_wifi *) p->data();
elements/wifi/printwifi.cc:324:    sa << p->timestamp_anno() << ": ";
elements/wifi/printwifi.cc:327:  len = sprintf(sa.reserve(9), "%4d | ", p->length());
elements/wifi/printwifi.cc:371:  uint8_t *ptr = (uint8_t *) p->data() + sizeof(click_wifi);
elements/wifi/printwifi.cc:500:  if (p->length() >= 16) {
elements/wifi/printwifi.cc:503:  if (p->length() > 22) {
elements/wifi/printwifi.cc:508:  if (p->length() >= sizeof(click_wifi)) {
elements/wifi/athdescencap.cc:55:  WritablePacket *p_out = p->push(ATHDESC_HEADER_SIZE);
elements/wifi/prism2encap.cc:53:  WritablePacket *p_out = p->uniqueify();
elements/wifi/prism2encap.cc:55:    p->kill();
elements/wifi/fromhandler.cc:102:    p->set_timestamp_anno(t);
elements/wifi/fromhandler.cc:103:    memset(p->data(), 0, p->length());
elements/wifi/fromhandler.cc:105:	p->data()[x/2] = (char_to_hex(s[x]) << 4) | char_to_hex(s[x + 1]);
elements/wifi/filtertx.cc:26:    struct click_wifi_extra *cehp = (struct click_wifi_extra *) p->data();
elements/wifi/filtertx.cc:30:      (cehp->magic == WIFI_EXTRA_MAGIC && cehp->flags & WIFI_EXTRA_TX)) {
elements/wifi/filtertx.cc:34:      p->kill();
elements/wifi/filterfailures.cc:27:    struct click_wifi_extra *cehp = (struct click_wifi_extra *) p->data();
elements/wifi/filterfailures.cc:31:      (cehp->magic == WIFI_EXTRA_MAGIC && cehp->flags & WIFI_EXTRA_TX_FAIL)) {
elements/wifi/filterfailures.cc:35:      p->kill();
elements/wifi/original.radiotapdecap.cc:122:	struct ieee80211_radiotap_header *th = (struct ieee80211_radiotap_header *) p->data();
elements/wifi/original.radiotapdecap.cc:124:	if (rt_check_header(th, p->length())) {
elements/wifi/original.radiotapdecap.cc:156:				p->take(4);
elements/wifi/original.radiotapdecap.cc:163:		p->pull(th->it_len);
elements/wifi/filterphyerr.cc:43:    struct click_wifi_extra *cehp = (struct click_wifi_extra *) p->data();
elements/wifi/filterphyerr.cc:47:      (cehp->magic == WIFI_EXTRA_MAGIC && cehp->flags & WIFI_EXTRA_RX_ERR)) {
elements/wifi/filterphyerr.cc:51:      p->kill();
elements/wifi/wepdecap.cc:93:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/wepdecap.cc:105:  u_int8_t *icp = p->data() + sizeof(click_wifi);
elements/wifi/wepdecap.cc:119:  u_int8_t *payload = p->data() + sizeof(click_wifi) + WIFI_WEP_HEADERSIZE;
elements/wifi/wepdecap.cc:120:  int payload_len = p->length() - (sizeof(click_wifi) + WIFI_WEP_HEADERSIZE + WIFI_WEP_CRCLEN);
elements/wifi/wepdecap.cc:142:  memmove((void *)(p->data() + WIFI_WEP_HEADERSIZE), p->data(), sizeof(click_wifi));
elements/wifi/wepdecap.cc:143:  p->pull(WIFI_WEP_HEADERSIZE);
elements/wifi/wepdecap.cc:145:  p->take(WIFI_WEP_CRCLEN);
elements/wifi/wepdecap.cc:147:  w = (struct click_wifi *) p->data();
elements/wifi/wifiencap.cc:67:  if (p->length() < sizeof(struct click_ether)) {
elements/wifi/wifiencap.cc:70:		  p->length(),
elements/wifi/wifiencap.cc:73:    p->kill();
elements/wifi/wifiencap.cc:78:  click_ether *eh = (click_ether *) p->data();
elements/wifi/wifiencap.cc:81:  memcpy(&ethtype, p->data() + 12, 2);
elements/wifi/wifiencap.cc:83:  p_out = p->uniqueify();
elements/wifi/wifidefrag.cc:54:  click_wifi *w = (click_wifi *) p->data();
elements/wifi/wifidefrag.cc:95:    p->kill();
elements/wifi/wifidefrag.cc:120:    uint32_t len = nfo->p->length();
elements/wifi/wifidefrag.cc:122:    p->pull(sizeof(click_wifi));
elements/wifi/wifidefrag.cc:123:    if ((nfo->p = nfo->p->put(p->length())))
elements/wifi/wifidefrag.cc:124:	memcpy((void *) (nfo->p->data() + len), p->data(), p->length());
elements/wifi/wifidefrag.cc:125:    p->kill();
elements/wifi/wifidefrag.cc:141:  w = (click_wifi *) p->data();
elements/wifi/ap/beaconsource.cc:117:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/ap/beaconsource.cc:137:  ptr = (uint8_t *) p->data() + sizeof(struct click_wifi);
elements/wifi/ap/beaconsource.cc:217:  p->take(max_len - actual_length);
elements/wifi/ap/beaconsource.cc:231:  if (p->length() < sizeof(struct click_wifi)) {
elements/wifi/ap/beaconsource.cc:234:		  p->length(),
elements/wifi/ap/beaconsource.cc:237:    p->kill();
elements/wifi/ap/beaconsource.cc:241:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/ap/beaconsource.cc:251:    p->kill();
elements/wifi/ap/beaconsource.cc:258:    p->kill();
elements/wifi/ap/beaconsource.cc:264:  ptr = (uint8_t *) p->data() + sizeof(struct click_wifi);
elements/wifi/ap/beaconsource.cc:266:  uint8_t *end  = (uint8_t *) p->data() + p->length();
elements/wifi/ap/beaconsource.cc:306:    p->kill();
elements/wifi/ap/beaconsource.cc:335:  p->kill();
elements/wifi/ap/openauthresponder.cc:69:  if (p->length() < sizeof(struct click_wifi)) {
elements/wifi/ap/openauthresponder.cc:72:		  p->length(),
elements/wifi/ap/openauthresponder.cc:75:    p->kill();
elements/wifi/ap/openauthresponder.cc:79:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/ap/openauthresponder.cc:89:    p->kill();
elements/wifi/ap/openauthresponder.cc:96:    p->kill();
elements/wifi/ap/openauthresponder.cc:102:  ptr = (uint8_t *) p->data() + sizeof(struct click_wifi);
elements/wifi/ap/openauthresponder.cc:122:    p->kill();
elements/wifi/ap/openauthresponder.cc:131:    p->kill();
elements/wifi/ap/openauthresponder.cc:144:  p->kill();
elements/wifi/ap/openauthresponder.cc:162:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/ap/openauthresponder.cc:177:  ptr = (uint8_t *) p->data() + sizeof(struct click_wifi);
elements/wifi/ap/associationresponder.cc:72:  if (p->length() < sizeof(struct click_wifi)) {
elements/wifi/ap/associationresponder.cc:75:		  p->length(),
elements/wifi/ap/associationresponder.cc:78:    p->kill();
elements/wifi/ap/associationresponder.cc:82:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/ap/associationresponder.cc:91:    p->kill();
elements/wifi/ap/associationresponder.cc:98:    p->kill();
elements/wifi/ap/associationresponder.cc:104:  ptr = (uint8_t *) p->data() + sizeof(struct click_wifi);
elements/wifi/ap/associationresponder.cc:114:  uint8_t *end  = (uint8_t *) p->data() + p->length();
elements/wifi/ap/associationresponder.cc:175:    p->kill();
elements/wifi/ap/associationresponder.cc:235:  p->kill();
elements/wifi/ap/associationresponder.cc:264:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/ap/associationresponder.cc:277:  uint8_t *ptr = (uint8_t *) p->data() + sizeof(struct click_wifi);
elements/wifi/ap/associationresponder.cc:327:  p->take(max_len - actual_length);
elements/wifi/ap/associationresponder.cc:347:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/ap/associationresponder.cc:363:  ptr = (uint8_t *) p->data() + sizeof(struct click_wifi);
elements/wifi/ap/proberesponder.cc:80:  if (p->length() < sizeof(struct click_wifi)) {
elements/wifi/ap/proberesponder.cc:83:		  p->length(),
elements/wifi/ap/proberesponder.cc:86:    p->kill();
elements/wifi/ap/proberesponder.cc:90:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/ap/proberesponder.cc:100:    p->kill();
elements/wifi/ap/proberesponder.cc:107:    p->kill();
elements/wifi/ap/proberesponder.cc:113:  ptr = (uint8_t *) p->data() + sizeof(struct click_wifi);
elements/wifi/ap/proberesponder.cc:115:  uint8_t *end  = (uint8_t *) p->data() + p->length();
elements/wifi/ap/proberesponder.cc:155:    p->kill();
elements/wifi/ap/proberesponder.cc:184:  p->kill();
elements/wifi/ap/proberesponder.cc:207:  struct click_wifi *w = (struct click_wifi *) p->data();
elements/wifi/ap/proberesponder.cc:222:  ptr = (uint8_t *) p->data() + sizeof(struct click_wifi);
elements/wifi/bk2.radiotapdecap.cc:122:	struct ieee80211_radiotap_header *th = (struct ieee80211_radiotap_header *) p->data();
elements/wifi/bk2.radiotapdecap.cc:124:	if (rt_check_header(th, p->length())) {
elements/wifi/bk2.radiotapdecap.cc:134:			     p->take(4);
elements/wifi/bk2.radiotapdecap.cc:170:		p->pull(th->it_len);
elements/wifi/bk2.radiotapdecap.cc:171:		p->set_mac_header(p->data());  // reset mac-header pointer
elements/wifi/wifiseq.cc:76:  if (p && p->length() > _offset + _bytes) {
elements/wifi/wifiseq.cc:79:    char *data = (char *)(p->data() + _offset);
elements/wifi/athdescdecap.cc:54:	WritablePacket *q = p->uniqueify();
elements/wifi/extradecap.cc:52:  click_wifi_extra *ceh = (click_wifi_extra *) p->data();
elements/wifi/extradecap.cc:55:      memcpy(WIFI_EXTRA_ANNO(p), p->data(), sizeof(click_wifi_extra));
elements/wifi/extradecap.cc:56:      p->pull(sizeof(click_wifi_extra));
elements/ns/fromsimdevice.cc:119:    if (!(p->data()[0] & 1))
elements/ns/fromsimdevice.cc:123:    if (memcmp(bcast_addr, p->data(), 6) == 0)
elements/ns/fromsimdevice.cc:124:      p->set_packet_type_anno(Packet::BROADCAST);
elements/ns/fromsimdevice.cc:126:      p->set_packet_type_anno(Packet::MULTICAST);
elements/ns/fromsimdevice.cc:140:  p->set_sim_packetinfo(pinfo);
elements/ns/tosimdevice.cc:112:  retval = myrouter->sim_write(_fd,_encap_type,p->data(),p->length(),
elements/ns/tosimdevice.cc:113:				 p->get_sim_packetinfo());
elements/ns/tosimdevice.cc:114:  p->kill();
elements/ns/tosimdevice.cc:120:  assert(p->length() >= 14);
elements/ip6/lookupip6route.cc:143:    p->kill();
elements/ip6/checkip6header.cc:91:    p->kill();
elements/ip6/checkip6header.cc:97:  const click_ip6 *ip = reinterpret_cast <const click_ip6 *>( p->data());
elements/ip6/checkip6header.cc:101:  if(p->length() < sizeof(click_ip6))
elements/ip6/checkip6header.cc:105:  if(ip->ip6_v != 6)
elements/ip6/checkip6header.cc:109:   if(ntohs(ip->ip6_plen) > (p->length()-40))
elements/ip6/checkip6header.cc:117:   src=ip->ip6_src;
elements/ip6/checkip6header.cc:130:  p->set_ip6_header(ip);
elements/ip6/checkip6header.cc:133:  if(ntohs(ip->ip6_plen) < (p->length()-40))
elements/ip6/checkip6header.cc:134:    p->take(p->length() - 40 - ip->ip6_plen);
elements/ip6/markip6header.cc:44:  const click_ip6 *ip6 = reinterpret_cast<const click_ip6 *>(p->data() + _offset);
elements/ip6/markip6header.cc:45:  p->set_ip6_header(ip6, 10 << 2);
elements/ip6/ip6encap.cc:84:    click_ip6 *ip6 = reinterpret_cast<click_ip6 *>(p->data());
elements/ip6/ip6encap.cc:92:    ip6->ip6_plen = htons(p->length() - sizeof(click_ip6));
elements/ip6/ip6encap.cc:93:    p->set_ip6_header(ip6, sizeof(click_ip6));
elements/ip6/protocoltranslator64.cc:77:  ip->ip_v = 4;
elements/ip6/protocoltranslator64.cc:78:  ip->ip_hl =5;
elements/ip6/protocoltranslator64.cc:79:  ip->ip_tos =0;
elements/ip6/protocoltranslator64.cc:80:  ip->ip_len = htons(sizeof(*ip) + ntohs(ip6->ip6_plen));
elements/ip6/protocoltranslator64.cc:82:  ip->ip_id = htons(0);
elements/ip6/protocoltranslator64.cc:84:  //ip->ip_id[0]=ip6->ip_flow[1];
elements/ip6/protocoltranslator64.cc:85:  //ip->ip_id[1]=ip6->ip_flow[2];
elements/ip6/protocoltranslator64.cc:89:  ip->ip_off = htons(IP_DF);
elements/ip6/protocoltranslator64.cc:93:  ip->ip_ttl = ip6->ip6_hlim;
elements/ip6/protocoltranslator64.cc:97:  ip->ip_src = src.in_addr();
elements/ip6/protocoltranslator64.cc:98:  ip->ip_dst = dst.in_addr();
elements/ip6/protocoltranslator64.cc:109:      ip->ip_p = ip6->ip6_nxt;
elements/ip6/protocoltranslator64.cc:112:      ip->ip_sum = 0;
elements/ip6/protocoltranslator64.cc:113:      tcp->th_sum = 0;
elements/ip6/protocoltranslator64.cc:117:      tcp->th_sum = click_in_cksum_pseudohdr(csum, ip, tlen);
elements/ip6/protocoltranslator64.cc:118:      ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/ip6/protocoltranslator64.cc:124:      ip->ip_p = ip6->ip6_nxt;
elements/ip6/protocoltranslator64.cc:127:      ip->ip_sum=0;
elements/ip6/protocoltranslator64.cc:128:      udp->uh_sum = 0;
elements/ip6/protocoltranslator64.cc:132:      udp->uh_sum = click_in_cksum_pseudohdr(csum, ip, tlen);
elements/ip6/protocoltranslator64.cc:133:      ip->ip_sum = click_in_cksum((unsigned char *)ip, sizeof(click_ip));
elements/ip6/protocoltranslator64.cc:139:      ip->ip_p = 1;
elements/ip6/protocoltranslator64.cc:178:	icmp->icmp_type = ICMP_ECHO;                 // icmp_type =8
elements/ip6/protocoltranslator64.cc:181:	icmp->icmp_type = ICMP_ECHOREPLY;              // icmp_type = 0
elements/ip6/protocoltranslator64.cc:184:      icmp->icmp_identifier = (icmp6->icmp6_identifier);
elements/ip6/protocoltranslator64.cc:185:      icmp->icmp_sequence = (icmp6->icmp6_sequence);
elements/ip6/protocoltranslator64.cc:187:      icmp->icmp_cksum = click_in_cksum((unsigned char *)icmp, icmp_length);
elements/ip6/protocoltranslator64.cc:201:      icmp->icmp_type = ICMP_UNREACH;             // icmp_type =3
elements/ip6/protocoltranslator64.cc:204:      case 0: icmp->icmp_code =0;  break;
elements/ip6/protocoltranslator64.cc:205:      case 1: icmp->icmp_code =10; break;
elements/ip6/protocoltranslator64.cc:206:      case 2: icmp->icmp_code =5;  break;
elements/ip6/protocoltranslator64.cc:207:      case 3: icmp->icmp_code =1;  break;
elements/ip6/protocoltranslator64.cc:208:      case 4: icmp->icmp_code =3;  break;
elements/ip6/protocoltranslator64.cc:212:      icmp->icmp_cksum = click_in_cksum((unsigned char *)icmp, icmp_length);
elements/ip6/protocoltranslator64.cc:225:      icmp->icmp_type = ICMP_UNREACH; //icmp_type = 3
elements/ip6/protocoltranslator64.cc:226:      icmp->icmp_code = 4;
elements/ip6/protocoltranslator64.cc:228:      icmp->icmp_cksum = click_in_cksum((unsigned char *)icmp, icmp_length);
elements/ip6/protocoltranslator64.cc:240:      icmp->icmp_type =ICMP_TIMXCEED;            //icmp_type = 11
elements/ip6/protocoltranslator64.cc:241:      icmp->icmp_code = icmp6_code;
elements/ip6/protocoltranslator64.cc:243:      icmp->icmp_cksum = click_in_cksum((unsigned char *)icmp, icmp_length);
elements/ip6/protocoltranslator64.cc:258:	  icmp->icmp_type = ICMP_PARAMPROB;         // icmp_type = 12
elements/ip6/protocoltranslator64.cc:259:	  icmp->icmp_code = 0;
elements/ip6/protocoltranslator64.cc:261:	    icmp->icmp_pointer = -1;
elements/ip6/protocoltranslator64.cc:266:	      case 0 : icmp->icmp_pointer = 0;  break;
elements/ip6/protocoltranslator64.cc:267:	      case 4 : icmp->icmp_pointer = 2;  break;
elements/ip6/protocoltranslator64.cc:268:	      case 7 : icmp->icmp_pointer = 8;  break;
elements/ip6/protocoltranslator64.cc:269:	      case 6 : icmp->icmp_pointer = 9;  break;
elements/ip6/protocoltranslator64.cc:270:	      case 8 : icmp->icmp_pointer = 12; break;
elements/ip6/protocoltranslator64.cc:271:	      case 24: icmp->icmp_pointer = -1; break;
elements/ip6/protocoltranslator64.cc:277:	  icmp->icmp_cksum = click_in_cksum((unsigned char *)icmp, icmp_length);
elements/ip6/protocoltranslator64.cc:288:	  icmp->icmp_type = ICMP_UNREACH; // icmp_type = 3
elements/ip6/protocoltranslator64.cc:289:	  icmp->icmp_code = 2;
elements/ip6/protocoltranslator64.cc:291:	  icmp->icmp_cksum = click_in_cksum((unsigned char *)icmp, icmp_length);
elements/ip6/protocoltranslator64.cc:315:  click_ip6 *ip6 = (click_ip6 *) p->data();
elements/ip6/protocoltranslator64.cc:342:	   ip->ip_len = htons(q3->length());
elements/ip6/protocoltranslator64.cc:343:	   ip->ip_sum=0;
elements/ip6/protocoltranslator64.cc:344:	   ip->ip_sum = click_in_cksum((unsigned char *)ip, q3->length());
elements/ip6/protocoltranslator64.cc:346:	   p->kill();
elements/ip6/protocoltranslator64.cc:353:	   p->kill();
elements/ip6/protocoltranslator64.cc:360:      p->kill();
elements/ip6/addresstranslator.cc:541:  click_ip6 *ip6 = (click_ip6 *)p->data();
elements/ip6/addresstranslator.cc:542:  unsigned char *start = (unsigned char *)p->data();
elements/ip6/addresstranslator.cc:550:  WritablePacket *q= Packet::make(p->length());
elements/ip6/addresstranslator.cc:561:  memcpy(start_new, start, p->length());
elements/ip6/addresstranslator.cc:597:	  p->kill();
elements/ip6/addresstranslator.cc:603:	  p->kill();
elements/ip6/addresstranslator.cc:621:	  p->kill();
elements/ip6/addresstranslator.cc:627:	  p->kill();
elements/ip6/addresstranslator.cc:644:	  p->kill();
elements/ip6/addresstranslator.cc:650:	  p->kill();
elements/ip6/addresstranslator.cc:657:      p->kill();
elements/ip6/addresstranslator.cc:665:click_ip6 *ip6 = (click_ip6 *)p->data();
elements/ip6/addresstranslator.cc:666:  unsigned char *start = (unsigned char *)p->data();
elements/ip6/addresstranslator.cc:675:  WritablePacket *q= Packet::make(p->length());
elements/ip6/addresstranslator.cc:686:  memcpy(start_new, start, p->length());
elements/ip6/addresstranslator.cc:723:	  p->kill();
elements/ip6/addresstranslator.cc:729:	  p->kill();
elements/ip6/addresstranslator.cc:748:	  p->kill();
elements/ip6/addresstranslator.cc:754:	  p->kill();
elements/ip6/addresstranslator.cc:772:	  p->kill();
elements/ip6/addresstranslator.cc:778:	  p->kill();
elements/ip6/addresstranslator.cc:785:      p->kill();
elements/ip6/setip6dscp.cc:54:  assert(p->has_network_header());
elements/ip6/setip6dscp.cc:55:  click_ip6 *ip6 = p->ip6_header();
elements/ip6/getip6address.cc:47:  IP6Address dst=IP6Address((unsigned char *)(p->data()+ _offset));
elements/ip6/icmp6error.cc:137:  const click_ip6 *ipp = p->ip6_header();
elements/ip6/icmp6error.cc:143:  if (!p->has_network_header())
elements/ip6/icmp6error.cc:150:  if(ipp->ip6_nxt == IP_PROTO_ICMP6) {
elements/ip6/icmp6error.cc:152:    if( is_error_type(icp->icmp6_type))
elements/ip6/icmp6error.cc:157:  if(unicast(IP6Address(ipp->ip6_dst)) == 0)
elements/ip6/icmp6error.cc:161:  if (p->packet_type_anno() == Packet::BROADCAST || p->packet_type_anno() == Packet::MULTICAST)
elements/ip6/icmp6error.cc:167:  xlen = p->length();
elements/ip6/icmp6error.cc:181:  nip->ip6_flow = 0;
elements/ip6/icmp6error.cc:182:  nip->ip6_v = 6;
elements/ip6/icmp6error.cc:183:  nip->ip6_plen = htons(q->length()-40);
elements/ip6/icmp6error.cc:184:  nip->ip6_nxt = IP_PROTO_ICMP6;  /* next header */
elements/ip6/icmp6error.cc:185:  nip->ip6_hlim = 0xff; //what hop limit shoud I set?
elements/ip6/icmp6error.cc:186:  nip->ip6_src = _src_ip;
elements/ip6/icmp6error.cc:187:  nip->ip6_dst = ipp->ip6_src;
elements/ip6/icmp6error.cc:191:  icp->icmp6_type = _type;
elements/ip6/icmp6error.cc:192:  icp->icmp6_code = _code;
elements/ip6/icmp6error.cc:210:    icpr->icmp6_dst = ipp->ip6_dst;
elements/ip6/icmp6error.cc:211:    memcpy((void *)(icpr + 1), p->data(), xlen);
elements/ip6/icmp6error.cc:213:    memcpy((void *)(icp + 1), p->data(), xlen);
elements/ip6/icmp6error.cc:215:  icp->icmp6_cksum = htons(in6_fast_cksum(&nip->ip6_src, &nip->ip6_dst, nip->ip6_plen, nip->ip6_nxt, 0, (unsigned char *)icp, nip->ip6_plen));
elements/ip6/icmp6error.cc:217:  SET_DST_IP6_ANNO(q, IP6Address(nip->ip6_dst));
elements/ip6/icmp6error.cc:222:  p->kill();
elements/ip6/protocoltranslator46.cc:61:  WritablePacket *q = Packet::make(sizeof(click_ip6)-sizeof(click_ip)+ntohs(ip->ip_len));
elements/ip6/protocoltranslator46.cc:76:  ip6->ip6_plen = htons(ntohs(ip->ip_len)-sizeof(click_ip));
elements/ip6/protocoltranslator46.cc:77:  ip6->ip6_hlim = ip->ip_ttl + 0x40-0xff;
elements/ip6/protocoltranslator46.cc:82:  if (ip->ip_p == 6) //TCP
elements/ip6/protocoltranslator46.cc:84:      ip6->ip6_nxt = ip->ip_p;
elements/ip6/protocoltranslator46.cc:85:      tcp->th_sum = htons(in6_fast_cksum(&ip6->ip6_src, &ip6->ip6_dst, ip6->ip6_plen, ip6->ip6_nxt, tcp->th_sum, a, ip6->ip6_plen));
elements/ip6/protocoltranslator46.cc:88:  else if (ip->ip_p == 17) //UDP
elements/ip6/protocoltranslator46.cc:90:      ip6->ip6_nxt = ip->ip_p;
elements/ip6/protocoltranslator46.cc:91:      udp->uh_sum = htons(in6_fast_cksum(&ip6->ip6_src, &ip6->ip6_dst, ip6->ip6_plen, ip6->ip6_nxt, udp->uh_sum, a, ip6->ip6_plen));
elements/ip6/protocoltranslator46.cc:94:  else if (ip->ip_p == 1)
elements/ip6/protocoltranslator46.cc:144:    icmp6->icmp6_identifier = icmp->icmp_identifier;
elements/ip6/protocoltranslator46.cc:145:    icmp6->icmp6_sequence = icmp->icmp_sequence;
elements/ip6/protocoltranslator46.cc:147:    icmp->icmp_cksum  = 0;
elements/ip6/protocoltranslator46.cc:169:	icmp->icmp_cksum  = 0;
elements/ip6/protocoltranslator46.cc:186:	icmp->icmp_cksum  = 0;
elements/ip6/protocoltranslator46.cc:228:	icmp->icmp_cksum  = 0;
elements/ip6/protocoltranslator46.cc:248:    icmp->icmp_cksum  = 0;
elements/ip6/protocoltranslator46.cc:273:    icmp->icmp_cksum  = 0;
elements/ip6/protocoltranslator46.cc:297:  click_ip *ip = (click_ip *)p->data();
elements/ip6/protocoltranslator46.cc:299:  IP6Address ip6a_src = IP6Address(IPAddress(ip->ip_src));
elements/ip6/protocoltranslator46.cc:300:  IP6Address ip6a_dst = IP6Address(IPAddress(ip->ip_dst));
elements/ip6/protocoltranslator46.cc:306:  if (ip->ip_p == 1)
elements/ip6/protocoltranslator46.cc:321:      p->kill();
elements/ip6/protocoltranslator46.cc:328:      p->kill();
elements/ip6/ip6mirror.cc:39:  click_ip6 *iph = p->ip6_header();
elements/ip6/ip6mirror.cc:45:  if ((iph->ip6_nxt == IP_PROTO_TCP || iph->ip6_nxt == IP_PROTO_UDP) &&  p->length() >= (uint32_t)(p->transport_header_offset() + 8)) {
elements/ip6/ip6mirror.cc:46:    click_udp *udph = reinterpret_cast<click_udp *>(p->transport_header());
elements/ip6/ip6print.cc:47:    const click_ip6 *iph = (click_ip6*) p->ip_header();
elements/ip6/ip6print.cc:58:    const unsigned char *data = p->data();
elements/ip6/ip6print.cc:67:	    for (unsigned i = 0; i < _bytes && i < p->length(); i++) {
elements/ip6/ip6fragmenter.cc:93:  if (p->length() <= _mtu)
elements/ip6/ip6fragmenter.cc:104:	p->kill();
elements/ip6/ip6fragmenter.cc:135:  // click_chatter("IP6Fragmenter::push, packet length is %x \n", p->length());
elements/ip6/ip6fragmenter.cc:136:  if (p->length() <= _mtu)
elements/ip6/decip6hlim.cc:40:    p->kill();
elements/ip6/decip6hlim.cc:54:     click_ip6 *ip = p->ip6_header();
elements/ip6/decip6hlim.cc:55:     ip->ip6_hlim--;
elements/test/queueyanktest.cc:71:	    if (p->data()[0] == *ss)
elements/test/heaptest.cc:41:	x->second = x - vp->begin();
elements/test/clptest.cc:169:    StringAccum *sa = (StringAccum *) clp->user_data;
elements/test/clptest.cc:184:    clp->user_data = &sa;
elements/test/clptest.cc:255:    CHECK(Clp_Next(clp) == 1 && clp->have_val && clp->val.i == 1);
elements/test/clptest.cc:256:    CHECK(Clp_Next(clp) == 1 && clp->have_val && clp->val.i == 2);
elements/test/clptest.cc:259:    CHECK(Clp_Next(clp) == 1 && clp->have_val && clp->val.i == 4);
elements/test/clptest.cc:260:    CHECK(Clp_Next(clp) == 1 && clp->have_val && clp->val.i == 5);
elements/test/clptest.cc:263:    CHECK(Clp_Next(clp) == 2 && clp->have_val);
elements/test/clptest.cc:264:    CHECK(1 && clp->have_val && clp->val.i == 1);
elements/test/clptest.cc:265:    CHECK(Clp_Next(clp) == 2 && !clp->have_val);
elements/test/clptest.cc:266:    CHECK(Clp_Next(clp) == Clp_NotOption && String(clp->vstr) == "2");
elements/test/clptest.cc:267:    CHECK(Clp_Next(clp) == 2 && clp->have_val && clp->val.i == 3);
elements/test/clptest.cc:268:    CHECK(Clp_Next(clp) == 2 && !clp->have_val);
elements/test/clptest.cc:269:    CHECK(Clp_Next(clp) == Clp_NotOption && String(clp->vstr) == "4");
elements/test/clptest.cc:272:    CHECK(Clp_Next(clp) == 3 && clp->negated);
elements/test/clptest.cc:282:    CHECK(Clp_Next(clp) == 1 && !clp->negated && clp->have_val && clp->val.i == 1);
elements/test/clptest.cc:283:    CHECK(Clp_Next(clp) == 1 && clp->negated && !clp->have_val);
elements/test/clptest.cc:286:    CHECK(Clp_Next(clp) == 1 && clp->negated && !clp->have_val);
elements/test/clptest.cc:287:    CHECK(Clp_Next(clp) == 1 && clp->negated && !clp->have_val);
elements/test/clptest.cc:288:    CHECK(Clp_Next(clp) == 2 && !clp->negated && clp->have_val && clp->val.i == 2);
elements/test/clptest.cc:299:    CHECK(Clp_Next(clp) == 1 && clp->have_val && clp->vstr == String("--ar"));
elements/test/clptest.cc:300:    CHECK(Clp_Next(clp) == 1 && clp->have_val && clp->vstr == String("ar"));
elements/test/clptest.cc:304:    CHECK(Clp_Next(clp) == 1 && clp->have_val && clp->vstr == String("--ar"));
elements/test/clptest.cc:305:    CHECK(Clp_Next(clp) == 1 && clp->have_val && clp->vstr == String("ar"));
elements/test/clptest.cc:317:    CHECK(Clp_Next(clp) == 1 && clp->have_val && clp->val.i == 1);
elements/test/clptest.cc:318:    CHECK(Clp_Next(clp) == 1 && clp->have_val && clp->val.i == 2);
elements/test/clptest.cc:319:    CHECK(Clp_Next(clp) == 1 && clp->have_val && clp->val.i == 3);
elements/test/clptest.cc:320:    CHECK(Clp_Next(clp) == 1 && clp->have_val && clp->val.i == 3);
elements/test/clptest.cc:323:    CHECK(Clp_Next(clp) == 1 && clp->have_val && clp->val.i == 4);
elements/test/queuethreadtest.cc:45:	WritablePacket *q = p->uniqueify();
elements/test/queuethreadtest.cc:108:	    CHECK(p->length() == 4);
elements/test/queuethreadtest.cc:109:	    CHECK(* reinterpret_cast<const uint32_t *>(p->data()) == _next);
elements/test/queuethreadtest.cc:110:	    p->kill();
elements/test/comparepackets.cc:72:    if (p->length() != q->length())
elements/test/comparepackets.cc:74:    if (memcmp(p->data(), q->data(), p->length()) != 0)
elements/test/comparepackets.cc:76:    if (p->timestamp_anno() != q->timestamp_anno() && _timestamp)
elements/test/comparepackets.cc:79:    if (p->has_network_header() && q->has_network_header()) {
elements/test/comparepackets.cc:80:	if (p->network_header_offset() != q->network_header_offset())
elements/test/comparepackets.cc:82:	if (p->network_header_length() != q->network_header_length())
elements/test/comparepackets.cc:84:    } else if (p->has_network_header() != q->has_network_header())
elements/test/comparepackets.cc:139:	return String(cp->_ndiff);
elements/test/comparepackets.cc:143:	      sa << cp->_diff_details[i] << '\t' << reason_texts[i] << '\n';
elements/test/comparepackets.cc:147:	return cp_unparse_bool(cp->_ndiff == 0);
elements/test/checkpacket.cc:85:	if (p->length() != _length)
elements/test/checkpacket.cc:86:	    errh->error("%s: bad length %d (wanted %d)", declaration().c_str(), p->length(), _length);
elements/test/checkpacket.cc:88:	if (p->length() <= _length)
elements/test/checkpacket.cc:89:	    errh->error("%s: bad length %d (wanted > %d)", declaration().c_str(), p->length(), _length);
elements/test/checkpacket.cc:91:	if (p->length() >= _length)
elements/test/checkpacket.cc:92:	    errh->error("%s: bad length %d (wanted < %d)", declaration().c_str(), p->length(), _length);
elements/test/checkpacket.cc:97:	if (p->length() < _data.length() + _data_offset)
elements/test/checkpacket.cc:98:	    errh->error("%s: data too short (%d bytes, wanted %d)", declaration().c_str(), p->length(), _data.length() + _data_offset);
elements/test/checkpacket.cc:99:	else if (_data_op == '=' && p->length() > _data.length() + _data_offset)
elements/test/checkpacket.cc:100:	    errh->error("%s: data too long (%d bytes, wanted %d)", declaration().c_str(), p->length(), _data.length() + _data_offset);
elements/test/checkpacket.cc:101:	else if (memcmp(p->data() + _data_offset, _data.data(), _data.length()) != 0)
elements/test/checkpacket.cc:107:	int alignment = reinterpret_cast<uintptr_t>(p->data()) & (_alignment_chunk - 1);
elements/test/packettest.cc:43:    CHECK(p->headroom() >= 10);
elements/test/packettest.cc:44:    CHECK(p->tailroom() >= 30);
elements/test/packettest.cc:45:    CHECK(p->length() == 20);
elements/test/packettest.cc:46:    CHECK(p->buffer_length() >= 60);
elements/test/packettest.cc:47:    CHECK_DATA(p->data(), lowers, 20);
elements/test/packettest.cc:48:    CHECK(!p->mac_header());
elements/test/packettest.cc:49:    CHECK(!p->network_header());
elements/test/packettest.cc:50:    CHECK(!p->transport_header());
elements/test/packettest.cc:51:    p->set_mac_header(p->data(), 10);
elements/test/packettest.cc:52:    CHECK(p->network_header() == p->data() + 10);
elements/test/packettest.cc:53:    p->set_dst_ip_anno(addr);
elements/test/packettest.cc:55:    WritablePacket *p1 = p->push(5);
elements/test/packettest.cc:62:    CHECK(p1->mac_header() == p->data() + 5);
elements/test/packettest.cc:63:    CHECK(p1->network_header() == p->data() + 15);
elements/test/packettest.cc:96:	p->clone()->kill();
elements/test/packettest.cc:97:    p->kill();
elements/test/packettest.cc:103:    CHECK(p->headroom() == 10 && p->tailroom() == 4);
elements/test/packettest.cc:104:    p = p->shift_data(-2);
elements/test/packettest.cc:105:    CHECK(p->headroom() == 8 && p->tailroom() == 6);
elements/test/packettest.cc:106:    CHECK(p->length() == 60);
elements/test/packettest.cc:107:    CHECK_DATA(p->data(), lowers, 60);
elements/test/packettest.cc:108:    CHECK_ALIGNED(p->data());
elements/test/packettest.cc:109:    p->kill();
elements/test/packettest.cc:112:    p = p->shift_data(3);
elements/test/packettest.cc:113:    CHECK(p->headroom() == 12 && p->tailroom() == 1 && p->length() == 60);
elements/test/packettest.cc:114:    CHECK_DATA(p->data(), lowers, 60);
elements/test/packettest.cc:115:    CHECK_ALIGNED(p->data());
elements/test/packettest.cc:116:    p->kill();
elements/test/packettest.cc:119:    p = p->shift_data(-5);
elements/test/packettest.cc:120:    CHECK(p->tailroom() >= 9 && p->length() == 60);
elements/test/packettest.cc:121:    CHECK_DATA(p->data(), lowers, 60);
elements/test/packettest.cc:122:    CHECK_ALIGNED(p->data());
elements/test/packettest.cc:123:    p->kill();
elements/test/packettest.cc:126:    p = p->shift_data(3);
elements/test/packettest.cc:127:    CHECK(p->headroom() >= 8 && p->length() == 60);
elements/test/packettest.cc:128:    CHECK_DATA(p->data(), lowers, 60);
elements/test/packettest.cc:129:    CHECK_ALIGNED(p->data());
elements/test/packettest.cc:130:    p->kill();
elements/test/packettest.cc:133:    p->set_mac_header(p->data(), 2);
elements/test/packettest.cc:134:    p->pull(2);
elements/test/packettest.cc:135:    p = p->shift_data(-3);
elements/test/packettest.cc:136:    CHECK(p->mac_header() == p->data() - 2);
elements/test/packettest.cc:137:    CHECK(p->headroom() >= 2 && p->length() == 58);
elements/test/packettest.cc:138:    CHECK_DATA(p->mac_header(), lowers, 2);
elements/test/packettest.cc:139:    CHECK_DATA(p->data(), lowers + 2, 58);
elements/test/packettest.cc:140:    CHECK_ALIGNED(p->data());
elements/test/packettest.cc:141:    p->kill();
tools/click-undead/click-undead.cc:288:	    args[pp-1] = args[pp];
tools/click-undead/click-undead.cc:302:	p--;
tools/click-undead/click-undead.cc:339:    for (int p = hnext.size() - 1; p >= (is_pull_tee ? 1 : 0); p--)
tools/click-undead/click-undead.cc:563:      set_clickpath(clp->vstr);
tools/click-undead/click-undead.cc:573:      router_file = clp->vstr;
tools/click-undead/click-undead.cc:578:      if (!click_maybe_define(clp->vstr, p_errh))
tools/click-undead/click-undead.cc:587:      output_file = clp->vstr;
tools/click-undead/click-undead.cc:591:      config_only = !clp->negated;
tools/click-undead/click-undead.cc:595:      check_kernel = (clp->negated ? 0 : 1);
tools/click-undead/click-undead.cc:599:      check_userlevel = (clp->negated ? 0 : 1);
tools/click-undead/click-undead.cc:603:      verbose = !clp->negated;
tools/click-undead/click-undead.cc:639:  emap->parse_all_files(r, CLICK_DATADIR, p_errh);
tools/click-undead/click-undead.cc:642:  bool indifferent = emap->driver_indifferent(r, Driver::ALLMASK, default_errh);
tools/click-undead/click-undead.cc:649:      check_kernel = emap->driver_compatible(r, Driver::LINUXMODULE);
tools/click-undead/click-undead.cc:650:      check_userlevel = emap->driver_compatible(r, Driver::USERLEVEL);
tools/click-fastclassifier/click-fastclassifier.cc:596:      source << "  p->kill();\n";
tools/click-fastclassifier/click-fastclassifier.cc:698:	String emap_package = "elementmap-" + package_name + ".xml";
tools/click-fastclassifier/click-fastclassifier.cc:771:	|| ae.name == "elementmap-fastclassifier.xml")
tools/click-fastclassifier/click-fastclassifier.cc:826:      set_clickpath(clp->vstr);
tools/click-fastclassifier/click-fastclassifier.cc:836:      router_file = clp->vstr;
tools/click-fastclassifier/click-fastclassifier.cc:841:      if (!click_maybe_define(clp->vstr, errh))
tools/click-fastclassifier/click-fastclassifier.cc:850:      output_file = clp->vstr;
tools/click-fastclassifier/click-fastclassifier.cc:854:      combine_classifiers = !clp->negated;
tools/click-fastclassifier/click-fastclassifier.cc:858:      do_compile = !clp->negated;
tools/click-fastclassifier/click-fastclassifier.cc:862:      reverse = !clp->negated;
tools/click-fastclassifier/click-fastclassifier.cc:866:      source_only = !clp->negated;
tools/click-fastclassifier/click-fastclassifier.cc:870:      config_only = !clp->negated;
tools/click-fastclassifier/click-fastclassifier.cc:882:      quiet_arg = (clp->negated ? "" : "-q ");
tools/click-fastclassifier/click-fastclassifier.cc:886:      verbose = !clp->negated;
tools/click-fastclassifier/fc_ipclassifier.cc:30:  source << "  const unsigned *ip_data = (const unsigned *)p->ip_header();\n\
tools/click-fastclassifier/fc_ipclassifier.cc:31:  const unsigned *transp_data = (const unsigned *)p->transport_header();\n\
tools/click-fastclassifier/fc_ipclassifier.cc:32:  int l = p->length() + " << IPCLASSIFIER_TRANSP_FAKE_OFFSET << " - p->transport_header_offset();\n";
tools/click-fastclassifier/fc_ipclassifier.cc:81:      source << " {\n    p->kill();\n    return;\n  }\n";
tools/click-fastclassifier/fc_ipclassifier.cc:89:      source << "  p->kill();\n  return;\n";
tools/click-fastclassifier/fc_ipclassifier.cc:100:  source << "  const unsigned *ip_data = (const unsigned *)p->ip_header();\n\
tools/click-fastclassifier/fc_ipclassifier.cc:101:  const unsigned *transp_data = (const unsigned *)p->transport_header();\n";
tools/click-fastclassifier/fc_ipclassifier.cc:125:      source << " {\n    p->kill();\n    return;\n  }\n";
tools/click-fastclassifier/fc_ipclassifier.cc:131:      source << "  p->kill();\n  return;\n";
tools/click-fastclassifier/fc_ipclassifier.cc:144:  if (p->length() + " << IPCLASSIFIER_TRANSP_FAKE_OFFSET << " - p->transport_header_offset() < " << c.safe_length << ")\n\
tools/click-fastclassifier/fc_classifier.cc:28:  source << "  const unsigned *data = (const unsigned *)(p->data() - "
tools/click-fastclassifier/fc_classifier.cc:29:	 << align_off << ");\n  int l = p->length();\n";
tools/click-fastclassifier/fc_classifier.cc:66:      source << " {\n    p->kill();\n    return;\n  }\n";
tools/click-fastclassifier/fc_classifier.cc:74:      source << "  p->kill();\n  return;\n";
tools/click-fastclassifier/fc_classifier.cc:86:  source << "  const unsigned *data = (const unsigned *)(p->data() - "
tools/click-fastclassifier/fc_classifier.cc:106:      source << " {\n    p->kill();\n    return;\n  }\n";
tools/click-fastclassifier/fc_classifier.cc:112:      source << "  p->kill();\n  return;\n";
tools/click-fastclassifier/fc_classifier.cc:123:  sa << "  if (p->length() < ";
tools/click-xform/adjacency.cc:284:  //for (int i = 0; i < pat_n; i++) fprintf(stderr,"%d ", match[i]);/* >= 0 ? input->_crap->ename(match[i]).c_str() : "<crap>");*/fputs("\n",stderr);
tools/click-xform/click-xform.cc:536:      read_pattern_file(clp->vstr, errh);
tools/click-xform/click-xform.cc:545:      router_file = clp->vstr;
tools/click-xform/click-xform.cc:554:      output_file = clp->vstr;
tools/click-xform/click-xform.cc:558:      reverse = !clp->negated;
tools/click-xform/click-xform.cc:562:      if (click_maybe_define(clp->vstr, errh))
tools/click-xform/click-xform.cc:568:	router_file = clp->vstr;
tools/click-xform/click-xform.cc:570:	read_pattern_file(clp->vstr, errh);
tools/click-devirtualize/cxxclass.cc:159:	p--;
tools/click-devirtualize/cxxclass.cc:162:	      && (p == 0 || ts[p-1] != ':' || ts[p] != ':')
tools/click-devirtualize/cxxclass.cc:163:	      && (p == 0 || ts[p-1] != '-' || ts[p] != '>'))) {
tools/click-devirtualize/cxxclass.cc:274:    for (p--; p >= 0 && isspace((unsigned char) s[p]); p--)
tools/click-devirtualize/cxxclass.cc:282:      p--;
tools/click-devirtualize/cxxclass.cc:285:      p--;
tools/click-devirtualize/cxxclass.cc:288:    if (p >= 0 && (s[p] == '.' || (p > 0 && s[p-1] == '-' && s[p] == '>')))
tools/click-devirtualize/cxxclass.cc:311:	  && (p == 0 || isspace((unsigned char) s[p-1]))
tools/click-devirtualize/cxxclass.cc:601:  for (p = open_brace_p - 1; p >= paren_p && isspace((unsigned char) s[p]); p--)
tools/click-devirtualize/cxxclass.cc:606:  for (p = paren_p - 1; p > fn_start_p && isspace((unsigned char) s[p]); p--)
tools/click-devirtualize/cxxclass.cc:610:    p--;
tools/click-devirtualize/cxxclass.cc:613:  if (p >= fn_start_p + 2 && s[p] == ':' && s[p-1] == ':') {
tools/click-devirtualize/cxxclass.cc:615:    for (p -= 2; p >= fn_start_p && (isalnum((unsigned char) s[p]) || s[p] == '_' || s[p] == '~'); p--)
tools/click-devirtualize/cxxclass.cc:646:    p--;
tools/click-devirtualize/click-devirtualize.cc:179:	|| ae.name == "elementmap-devirtualize.xml")
tools/click-devirtualize/click-devirtualize.cc:267:      set_clickpath(clp->vstr);
tools/click-devirtualize/click-devirtualize.cc:277:      router_file = clp->vstr;
tools/click-devirtualize/click-devirtualize.cc:282:      if (!click_maybe_define(clp->vstr, p_errh))
tools/click-devirtualize/click-devirtualize.cc:291:      output_file = clp->vstr;
tools/click-devirtualize/click-devirtualize.cc:295:      source_only = !clp->negated;
tools/click-devirtualize/click-devirtualize.cc:299:      config_only = !clp->negated;
tools/click-devirtualize/click-devirtualize.cc:303:      compile_kernel = !clp->negated;
tools/click-devirtualize/click-devirtualize.cc:307:      compile_user = !clp->negated;
tools/click-devirtualize/click-devirtualize.cc:311:      specializing.set(clp->vstr, !clp->negated);
tools/click-devirtualize/click-devirtualize.cc:315:      specializing.set(clp->vstr, 0);
tools/click-devirtualize/click-devirtualize.cc:319:      instruction_files.push_back(clp->vstr);
tools/click-devirtualize/click-devirtualize.cc:323:      reverse = !clp->negated;
tools/click-devirtualize/click-devirtualize.cc:503:    if (router->archive_index("elementmap-devirtualize.xml") < 0)
tools/click-devirtualize/click-devirtualize.cc:504:      router->add_archive(init_archive_element("elementmap-devirtualize.xml", 0600));
tools/click-devirtualize/click-devirtualize.cc:505:    ArchiveElement &ae = router->archive("elementmap-devirtualize.xml");
tools/click-devirtualize/specializer.cc:414:	   << "    output_push(i, p);\n  else\n    p->kill();\n";
tools/click-devirtualize/specializer.cc:416:	sa << "\n  p->kill();\n";
tools/click-pretty/click-pretty.cc:84:<meta http-equiv='Content-Type' content='text/html; charset=ISO-8859-1'>\n\
tools/click-pretty/click-pretty.cc:85:<meta http-equiv='Content-Style-Type' content='text/css'>\n\
tools/click-pretty/click-pretty.cc:1313:	    set_clickpath(clp->vstr);
tools/click-pretty/click-pretty.cc:1317:	    package_hrefs.set("x", clp->vstr);
tools/click-pretty/click-pretty.cc:1321:	      String s = clp->vstr;
tools/click-pretty/click-pretty.cc:1332:	    html_template = file_string(clp->vstr, p_errh);
tools/click-pretty/click-pretty.cc:1336:	      String s = clp->vstr;
tools/click-pretty/click-pretty.cc:1352:	    router_file = clp->vstr;
tools/click-pretty/click-pretty.cc:1357:	    if (!click_maybe_define(clp->vstr, p_errh))
tools/click-pretty/click-pretty.cc:1366:	    output_file = clp->vstr;
tools/click2xml/click2xml.cc:342:	    set_clickpath(clp->vstr);
tools/click2xml/click2xml.cc:352:	    router_file = clp->vstr;
tools/click2xml/click2xml.cc:357:	    if (!click_maybe_define(clp->vstr, p_errh))
tools/click2xml/click2xml.cc:366:	    output_file = clp->vstr;
tools/click2xml/click2xml.cc:380:	    flatten = !clp->negated;
tools/click2xml/xml2click.cc:722:	    set_clickpath(clp->vstr);
tools/click2xml/xml2click.cc:732:	    router_file = clp->vstr;
tools/click2xml/xml2click.cc:741:	    output_file = clp->vstr;
tools/click2xml/xml2click.cc:745:	    flatten = !clp->negated;
tools/click-align/click-align.cc:388:      router_file = clp->vstr;
tools/click-align/click-align.cc:403:      if (!click_maybe_define(clp->vstr, errh))
tools/click-align/click-align.cc:412:      output_file = clp->vstr;
tools/click-mkmindriver/click-mkmindriver.cc:435:	    set_clickpath(clp->vstr);
tools/click-mkmindriver/click-mkmindriver.cc:447:	    package_name = clp->vstr;
tools/click-mkmindriver/click-mkmindriver.cc:451:	    directory = clp->vstr;
tools/click-mkmindriver/click-mkmindriver.cc:457:	    specifier = (clp->negated ? "x" : "a");
tools/click-mkmindriver/click-mkmindriver.cc:461:	    check = !clp->negated;
tools/click-mkmindriver/click-mkmindriver.cc:466:	      cp_spacevec(clp->vstr, elements);
tools/click-mkmindriver/click-mkmindriver.cc:476:	    extras = !clp->negated;
tools/click-mkmindriver/click-mkmindriver.cc:480:	    verbose = !clp->negated;
tools/click-mkmindriver/click-mkmindriver.cc:485:	    router_filenames.push_back(specifier + String("f") + clp->vstr);
tools/click-mkmindriver/click-mkmindriver.cc:489:	    if (!click_maybe_define(clp->vstr, &arg_lerrh))
tools/click-mkmindriver/click-mkmindriver.cc:494:	    router_filenames.push_back(specifier + String("e") + clp->vstr);
tools/click-check/click-check.cc:180:      set_clickpath(clp->vstr);
tools/click-check/click-check.cc:190:      router_file = clp->vstr;
tools/click-check/click-check.cc:195:      if (!click_maybe_define(clp->vstr, p_errh))
tools/click-check/click-check.cc:204:      output_file = clp->vstr;
tools/click-check/click-check.cc:218:      quiet = !clp->negated;
tools/click-check/click-check.cc:225:       driver_mask = (clp->negated ? driver_mask & ~dm : driver_mask | dm);
tools/click-flatten/click-flatten.cc:157:      set_clickpath(clp->vstr);
tools/click-flatten/click-flatten.cc:168:      expand_vars = !clp->negated;
tools/click-flatten/click-flatten.cc:176:      output_file = clp->vstr;
tools/click-flatten/click-flatten.cc:186:      router_file = clp->vstr;
tools/click-flatten/click-flatten.cc:191:      if (!click_maybe_define(clp->vstr, p_errh))
tools/lib/elementmap.hh:102:    operator bool()			{ return _index < _emap->size(); }
tools/lib/elementmap.hh:105:    const ElementTraits& value() const	{ return _emap->traits_at(_index); }
tools/lib/elementmap.cc:642:	String mapname = "elementmap-" + req + ".xml";
tools/lib/elementmap.cc:722:    while (_index < _emap->size()) {
tools/lib/elementmap.cc:723:	const ElementTraits &t = _emap->traits_at(_index);
tools/lib/elementmap.cc:724:	if ((t.driver_mask & _emap->driver_mask())
tools/lib/processingt.cc:651:	    for (p -= 2; *p != '['; p--)
tools/lib/processingt.cc:654:	    p--;
tools/lib/processingt.cc:677:	    p--;		// don't skip over final '\0'
tools/lib/eclasst.cc:119:    return &emap->traits(_name);
tools/lib/eclasst.hh:172:    if (_traits_version != emap->version()) {
tools/lib/eclasst.hh:174:	_traits_version = emap->version();
tools/click-combine/click-combine.cc:385:      cc_read_router(String(), next_name, next_number, clp->vstr, false, errh);
tools/click-combine/click-combine.cc:389:      cc_read_router(String(), next_name, next_number, clp->vstr, true, errh);
tools/click-combine/click-combine.cc:397:      output_file = clp->vstr;
tools/click-combine/click-combine.cc:403:      next_name = clp->vstr;
tools/click-combine/click-combine.cc:407:      link_texts.push_back(clp->vstr);
tools/click-combine/click-combine.cc:415:      if (const char *s = strchr(clp->vstr, ':'))
tools/click-combine/click-combine.cc:416:	cc_read_router(String(clp->vstr, s - clp->vstr), next_name, next_number, s + 1, false, errh);
tools/click-combine/click-combine.cc:417:      else if (const char *eq = strchr(clp->vstr, '=')) {
tools/click-combine/click-combine.cc:418:	const char *dot = strchr(clp->vstr, '.');
tools/click-combine/click-combine.cc:420:	  cc_read_router(String(clp->vstr, eq - clp->vstr), next_name, next_number, eq + 1, false, errh);
tools/click-combine/click-combine.cc:422:	  link_texts.push_back(clp->vstr);
tools/click-combine/click-combine.cc:424:	cc_read_router(String(), next_name, next_number, clp->vstr, false, errh);
tools/click-combine/click-uncombine.cc:231:  // remove top-level links
tools/click-combine/click-uncombine.cc:319:      router_file = clp->vstr;
tools/click-combine/click-uncombine.cc:327:      output_file = clp->vstr;
tools/click-combine/click-uncombine.cc:335:      component = clp->vstr;
tools/click-combine/click-uncombine.cc:344:	component = clp->vstr;
tools/click-combine/click-uncombine.cc:346:	router_file = clp->vstr;
tools/click-install/click-install.cc:347:      set_clickpath(clp->vstr);
tools/click-install/click-install.cc:357:      router_file = clp->vstr;
tools/click-install/click-install.cc:362:      if (!click_maybe_define(clp->vstr, errh))
tools/click-install/click-install.cc:368:      threads = clp->val.u;
tools/click-install/click-install.cc:376:      accessible = clp->negated;
tools/click-install/click-install.cc:380:      priority = clp->val.i;
tools/click-install/click-install.cc:387:	output_map = !clp->negated;
tools/click-install/click-install.cc:392:	greedy = !clp->negated;
tools/click-install/click-install.cc:396:	const char *colon = find(clp->vstr, clp->vstr + strlen(clp->vstr), ':');
tools/click-install/click-install.cc:397:	if (colon > clp->vstr) {
tools/click-install/click-install.cc:398:	    String s(clp->vstr, colon);
tools/click-install/click-install.cc:411:	    clp->vstr = colon + 1;
tools/click-install/click-install.cc:419:	if (!cp_integer(clp->vstr, &gid)) {
tools/click-install/click-install.cc:421:	    struct group *grp = getgrnam(clp->vstr);
tools/click-install/click-install.cc:425:		errh->error("no such group '%s'", clp->vstr);
tools/click-install/click-install.cc:427:		gid = grp->gr_gid;
tools/click-install/click-install.cc:433:      cpu = clp->val.i;
tools/click-install/click-install.cc:438:      uninstall = !clp->negated;
tools/click-install/click-install.cc:442:      hotswap = !clp->negated;
tools/click-install/click-install.cc:446:      verbose = !clp->negated;
tools/click-install/click-uninstall.cc:93:      verbose = !clp->negated;
lib/clp.c:81: *             fprintf(stderr, "animal is %s\n", clp->val.s);
lib/clp.c:84: *             if (clp->negated)
lib/clp.c:86: *             else if (clp->have_val)
lib/clp.c:87: *                 fprintf(stderr, "vegetable is %s\n", clp->val.s);
lib/clp.c:92: *             fprintf(stderr, "%d minerals\n", clp->val.i);
lib/clp.c:98: *             fprintf(stderr, "non-option %s\n", clp->vstr);
lib/clp.c:379:    Clp_Internal *cli = clp->internal;
lib/clp.c:478:    clp->negated = 0;
lib/clp.c:479:    clp->have_val = 0;
lib/clp.c:480:    clp->vstr = 0;
lib/clp.c:481:    clp->user_data = 0;
lib/clp.c:482:    clp->internal = cli;
lib/clp.c:548:    cli = clp->internal;
lib/clp.c:578:    Clp_Internal *cli = clp->internal;
lib/clp.c:599:    Clp_Internal *cli = clp->internal;
lib/clp.c:615:    Clp_Internal *cli = clp->internal;
lib/clp.c:675:    Clp_Internal *cli = clp->internal;
lib/clp.c:754:    Clp_Internal *cli = clp->internal;
lib/clp.c:843:    Clp_Internal *cli = clp->internal;
lib/clp.c:866:    Clp_Internal *cli = clp->internal;
lib/clp.c:928:    int negated = clp && clp->negated;
lib/clp.c:929:    int first_charlen = (clp ? clp_utf8_charlen(clp->internal, arg) : 1);
lib/clp.c:938:	if (clp && clp->internal->could_be_short
lib/clp.c:990: * parse the argument into values (usually in @a clp->val, but sometimes
lib/clp.c:1016:    Clp_Internal *cli = clp->internal;
lib/clp.c:1061:    clp->val.s = arg;
lib/clp.c:1074:	clp->val.u = strtoul(arg, &val, 0);
lib/clp.c:1080:	    clp->val.u = strtol(arg, &val, 0);
lib/clp.c:1083:	clp->val.i = strtol(arg, &val, 0);
lib/clp.c:1103:	clp->val.d = strtod(arg, &val);
lib/clp.c:1128:	clp->val.i = 1;
lib/clp.c:1133:	clp->val.i = 0;
lib/clp.c:1160:	clp->val.i = sl->items[idx].option_id;
lib/clp.c:1234: * sets @a clp->val.i to an integer.  The value string is matched against
lib/clp.c:1309: * sets @a clp->val.i to an integer.  The value string is matched against the
lib/clp.c:1324: * <li><tt>--animal=cat</tt> will succeed and set @a clp->val.i = 1.</li>
lib/clp.c:1325: * <li><tt>--animal=cattle</tt> will succeed and set @a clp->val.i = 2.</li>
lib/clp.c:1326: * <li><tt>--animal=dog</tt> will succeed and set @a clp->val.i = 3.</li>
lib/clp.c:1327: * <li><tt>--animal=d</tt> will succeed and set @a clp->val.i = 3.</li>
lib/clp.c:1329: * <li><tt>--animal=4</tt> will succeed and set @a clp->val.i = 4.</li>
lib/clp.c:1374:    return clp->internal->program_name;
lib/clp.c:1386:    const char *old = clp->internal->program_name;
lib/clp.c:1387:    clp->internal->program_name = name;
lib/clp.c:1448:    Clp_Internal *cli = clp->internal;
lib/clp.c:1481:    Clp_Internal *cli = clp->internal;
lib/clp.c:1515:    if (clp->internal->utf8) {
lib/clp.c:1531:	Returns 0, sets clp->have_val = 1, and sets clp->vstr to the argument
lib/clp.c:1546:    Clp_Internal *cli = clp->internal;
lib/clp.c:1551:    clp->have_val = 0;
lib/clp.c:1552:    clp->vstr = 0;
lib/clp.c:1562:	    clp->have_val = 1;
lib/clp.c:1564:		clp->vstr = cli->xtext + 1;
lib/clp.c:1566:		clp->vstr = cli->xtext;
lib/clp.c:1647:	clp->have_val = 1;
lib/clp.c:1648:	clp->vstr = text;
lib/clp.c:1663:    Clp_Internal *cli = clp->internal;
lib/clp.c:1677:	clp->have_val = 1 and clp->vstr to that argument. Sets cli->ambiguous
lib/clp.c:1680:    Clp_Internal *cli = clp->internal;
lib/clp.c:1699:	clp->negated = !clp->negated;
lib/clp.c:1719:    lmm = (clp->negated ? iopt->lmmneg : iopt->lmmpos);
lib/clp.c:1721:	&& (clp->negated ? iopt->lmmneg_short : iopt->lmmpos_short)) {
lib/clp.c:1728:	clp->have_val = 1;
lib/clp.c:1729:	clp->vstr = arg + len + 1;
lib/clp.c:1739:    Clp_Internal *cli = clp->internal;
lib/clp.c:1743:    if (clp->internal->utf8)
lib/clp.c:1750:	    && (clp->negated ? iopt[i].ineg : iopt[i].ipos))
lib/clp.c:1771: * clp->vstr (and @a clp->val.s).</dd>
lib/clp.c:1802:    Clp_Internal *cli = clp->internal;
lib/clp.c:1814:	clp->val.s = clp->vstr;
lib/clp.c:1815:	return clp->have_val ? Clp_NotOption : Clp_Done;
lib/clp.c:1818:    clp->negated = cli->whole_negated;
lib/clp.c:1832:    if (optno < 0 || (clp->negated && !cli->iopt[optno].ineg)) {
lib/clp.c:1859:    cli->negated_by_no = clp->negated && !cli->whole_negated;
lib/clp.c:1862:    if (clp->negated
lib/clp.c:1864:	if (clp->have_val) {
lib/clp.c:1882:    complain = (clp->have_val != 0) || cli->iopt[optno].imandatory;
lib/clp.c:1885:    if (cli->iopt[optno].imandatory && !clp->have_val) {
lib/clp.c:1891:	if (!clp->have_val) {
lib/clp.c:1901:    } else if (cli->is_short && !clp->have_val
lib/clp.c:1908:    if (clp->have_val) {
lib/clp.c:1910:	if (atr->func(clp, clp->vstr, complain, atr->user_data) <= 0) {
lib/clp.c:1912:	    clp->have_val = 0;
lib/clp.c:1939:    if (!clp->have_val)
lib/clp.c:1941:    return clp->vstr;
lib/clp.c:2020:    Clp_Internal *cli = clp->internal;
lib/clp.c:2153:    if (clp->internal->error_handler != 0)
lib/clp.c:2154:	(*clp->internal->error_handler)(clp, text);
lib/clp.c:2221:    Clp_Internal *cli = clp->internal;
lib/clp.c:2229:    if (clp->internal->program_name && clp->internal->program_name[0]) {
lib/clp.c:2230:	append_build_string(bs, clp->internal->program_name, -1);
lib/clp.c:2289:    Clp_Internal *cli = clp->internal;
lib/notifier.cc:170:    for (i = 0, vmp = _v.vm; vmp->mask && vmp->value < value; ++i, ++vmp)
lib/notifier.cc:172:    if (vmp->mask && vmp->value == value) {
lib/notifier.cc:173:	vmp->mask |= mask;
lib/notifier.cc:176:    for (n = i; vmp->mask; ++n, ++vmp)
lib/packet.cc:172: * if (WritablePacket *q = p->uniqueify()) {
lib/packet.cc:322:    if (!p->alloc_data(headroom, length, tailroom)) {
lib/packet.cc:327:	memcpy(p->data(), data, length);
lib/packet.cc:355:	p->_head = p->_data = data;
lib/packet.cc:356:	p->_tail = p->_end = data + length;
lib/packet.cc:357:	p->_destructor = destructor;
lib/packet.cc:395:    p->_use_count = 1;
lib/packet.cc:396:    p->_data_packet = this;
lib/packet.cc:398:    p->_destructor = 0;
lib/packet.cc:400:    p->_m = m;
lib/packet.cc:483:	WritablePacket *q = (p ? p->expensive_uniqueify(extra_headroom, extra_tailroom, true) : 0);
lib/packet.cc:536:  m2 = p->m();
lib/packet.cc:539:  p->_m = 0;
lib/packet.cc:540:  p->kill();
lib/master.cc:777:	    int fd = (int) p->ident;
lib/master.cc:778:	    if (p->filter == EVFILT_READ && fd < _read_elements.size()
lib/master.cc:781:	    else if (p->filter == EVFILT_WRITE && fd < _write_elements.size()
lib/master.cc:842:	    if (p->revents) {
lib/master.cc:849:		int fd = p->fd;
lib/master.cc:850:		Element *read_elt = (p->revents & ~POLLOUT ? _read_elements[fd] : 0);
lib/master.cc:851:		Element *write_elt = (p->revents & ~POLLIN ? _write_elements[fd] : 0);
lib/master.cc:861:		if (p < my_pollfds.end() && fd != p->fd)
lib/master.cc:862:		    p--;
lib/master.cc:911:	    if (p->fd > FD_SETSIZE || FD_ISSET(p->fd, &read_mask) || FD_ISSET(p->fd, &write_mask)) {
lib/master.cc:918:		int fd = p->fd;
lib/master.cc:930:		if (p < _pollfds.end() && fd != p->fd)
lib/master.cc:931:		    p--;
lib/ipflowid.cc:31:    const click_ip *iph = p->ip_header();
lib/ipflowid.cc:32:    const click_udp *udph = p->udp_header();
lib/ipflowid.cc:33:    assert(p->has_network_header() && p->has_transport_header()
lib/element.cc:255:    output(0).push(p->clone());
lib/element.cc:261:clones.  @c p->clone() would return null, and passing a null pointer to
lib/element.cc:266:    if (Packet *clone = p->clone())
lib/element.cc:287:    p->kill();            // free packet
lib/element.cc:302:    if (!p->has_network_header())
lib/element.cc:315:    if (!p->has_network_header()) {
lib/element.cc:316:        p->kill();
lib/element.cc:325:    assert(p->has_network_header());
lib/element.cc:332:    if (p->has_network_header())
lib/element.cc:941:	    for (p -= 2; *p != '['; p--)
lib/element.cc:944:	    p--;
lib/element.cc:967:	    p--;			// don't skip over final '\0'
lib/driver.cc:124:	p->provided++;
lib/driver.cc:131:    if (p && p->provided > 0)
lib/driver.cc:132:	p->provided--;
lib/driver.cc:139:    return (p && p->provided > 0);
lib/driver.cc:298:    if (!p || p->loaded)
lib/driver.cc:338:    p->loaded = true;
lib/error.cc:1014:	return ipp->unparse();
lib/error.cc:1024:	return ethp->unparse();
lib/router.cc:604:	if (pp == ports.begin() || pp[-1].idx != pp->idx)
lib/router.cc:605:	    results.push_back(_elements[pp->idx]);
lib/router.cc:850:	    if (!stop_filter || !stop_filter->check_match(_elements[rp->idx], !forward, rp->port)) {
lib/router.cc:851:		_elements[rp->idx]->port_flow(!forward, rp->port, &scratch);
lib/router.cc:854:			sources.push_back(Port(rp->idx, port));
lib/lexer.cc:1607:    VariableEnvironment new_ve(ve.parent_of(found_comp->depth()));
lib/lexer.cc:1608:    for (int i = 0; i < found_comp->nformals(); i++)
lib/lexer.cc:1609:      new_ve.define(found_comp->scope().name(i), args[i], true);
lib/lexer.cc:1610:    for (int i = found_comp->nformals(); i < found_comp->scope().size(); i++)
lib/lexer.cc:1611:      new_ve.define(found_comp->scope().name(i), cp_expand(found_comp->scope().value(i), new_ve), true);
lib/lexer.cc:1613:    found_comp->expand_into(this, which, new_ve);
lib/lexer.cc:1805:    dp->expand(this, into);
lib/ip6flowid.cc:31:  const click_ip6 *iph = p->ip6_header();
lib/ip6flowid.cc:35:  const click_udp *udph = p->udp_header();
configure:14151:	linux_system_map=/boot/System.map-"$linux_system_map_boot"
configure:19502:    test $ac_file = include/click/config.h:config.h.in && echo > stamp-h
config.status:1020:    test $ac_file = include/click/config.h:config.h.in && echo > stamp-h
config.guess:517:	echo romp-ibm-aix      # uname -m gives an 8 hex-code CPU id
config.guess:569:    ibmrt:4.4BSD:*|romp-ibm:BSD:*)
config.guess:570:	echo romp-ibm-bsd4.4
config.guess:572:    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
config.guess:573:	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
config.guess:574:	exit 0 ;;                           # report: romp-ibm BSD 4.3
config.guess:582:	echo m68k-hp-bsd
config.guess:585:	echo m68k-hp-bsd4.4
config.guess:657:	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
config.guess:661:	echo ia64-hp-hpux${HPUX_REV}
config.guess:694:	echo hppa1.1-hp-bsd
config.guess:697:	echo hppa1.0-hp-bsd
config.guess:700:	echo hppa1.0-hp-mpeix
config.guess:703:	echo hppa1.1-hp-osf
config.guess:706:	echo hppa1.0-hp-osf
config.guess:716:	echo hppa1.1-hp-lites
config.guess:737:	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
config.guess:1200:    *:NonStop-UX:*:*)
config.guess:1286:  printf ("m68k-hp-bsd\n"); exit (0);
config.guess:1444:# time-stamp-start: "timestamp='"
config.guess:1445:# time-stamp-format: "%:y-%02m-%02d"
config.guess:1446:# time-stamp-end: "'"
mkinstalldirs:155:# time-stamp-start: "scriptversion="
mkinstalldirs:156:# time-stamp-format: "%:y-%02m-%02d.%02H"
mkinstalldirs:157:# time-stamp-end: "$"
doc/texinfo.tex:142:\hyphenation{ap-pen-dix}
doc/texinfo.tex:219:        \vskip-\topandbottommargin
doc/texinfo.tex:1710:\def\itemxpar{\par\ifitemxneedsnegativevskip\nobreak\vskip-\parskip\nobreak\fi}
doc/texinfo.tex:1752:    \nobreak \vskip-\parskip
doc/texinfo.tex:2204:\global\advance\multitableparskip-7pt %% to keep parskip somewhat smaller
doc/texinfo.tex:2209:\global\advance\multitableparskip-7pt %% to keep parskip somewhat smaller
doc/texinfo.tex:2892:            \ifdim\lastskip = 0pt \else \nobreak\vskip-\lastskip \fi
doc/texinfo.tex:5565:    \vskip-\baselineskip
doc/texinfo.tex:5989:@c time-stamp-start: "def\\\\texinfoversion{"
doc/texinfo.tex:5990:@c time-stamp-format: "%:y-%02m-%02d.%02H"
doc/texinfo.tex:5991:@c time-stamp-end: "}"
